Disassembly Listing for XPRESS-XC8
Generated From:
/home/phil/Projects/XPRESS-Loader/MPLAB.X/dist/XPRESS/production/MPLAB.X.production.elf
01-Nov-2019 00:05:29

---  /tmp/xcXhK62it.s  ----------------------------------------------------------------------------------
000B  3028     MOVLW 0x28
07FA  00FE     MOVWF 0x7E
07FB  0012     MOVIW FSR0++
07FC  001E     MOVWI FSR1++
07FD  0BFE     DECFSZ 0x7E, F
07FE  2FFB     GOTO 0x7FB
07FF  3400     RETLW 0x0
000A  0022     MOVLB 0x2
000C  00EE     MOVWF __pdataBANK2
000D  305E     MOVLW 0x5E
000E  0084     MOVWF FSR0L
000F  3088     MOVLW 0x88
0010  0085     MOVWF FSR0H
0011  30DC     MOVLW 0xDC
0012  0086     MOVWF FSR1L
0013  3001     MOVLW 0x1
0014  0087     MOVWF FSR1H
0015  3013     MOVLW 0x13
0016  3187     MOVLP 0x7
0849  0064     CLRWDT
084A  0180     CLRF INDF0
084B  3101     ADDFSR 0, 1
084C  0B89     DECFSZ WREG, F
084D  284A     GOTO 0x4A
084E  3400     RETLW 0x0
0019  30E5     MOVLW 0xE5
001A  0084     MOVWF FSR0L
001B  3000     MOVLW 0x0
001C  0085     MOVWF FSR0H
001D  300B     MOVLW 0xB
001E  3188     MOVLP 0x8
0021  3020     MOVLW 0x20
0022  0084     MOVWF FSR0L
0023  3001     MOVLW 0x1
0024  0085     MOVWF FSR0H
0025  304E     MOVLW 0x4E
0026  3188     MOVLP 0x8
0029  30A0     MOVLW 0xA0
002A  0084     MOVWF FSR0L
002B  3001     MOVLW 0x1
002C  0085     MOVWF FSR0H
002D  303C     MOVLW 0x3C
002E  3188     MOVLP 0x8
0031  3020     MOVLW 0x20
0032  0084     MOVWF FSR0L
0033  3002     MOVLW 0x2
0034  0085     MOVWF FSR0H
0035  3038     MOVLW 0x38
0036  3188     MOVLP 0x8
0039  30A0     MOVLW 0xA0
003A  0084     MOVWF FSR0L
003B  3002     MOVLW 0x2
003C  0085     MOVWF FSR0H
003D  3040     MOVLW 0x40
003E  3188     MOVLP 0x8
0041  3020     MOVLW 0x20
0042  0084     MOVWF FSR0L
0043  3003     MOVLW 0x3
0044  0085     MOVWF FSR0H
0045  3040     MOVLW 0x40
0046  3188     MOVLP 0x8
0049  107E     BCF 0x17E, 0x0
004A  0020     MOVLB 0x0
004B  284C     GOTO 0x4C
---  /opt/microchip/xc8/v2.10/pic/sources/c90/common/strncpy.c  -----------------------------------------
1:             #include	<string.h>
2:             
3:             #ifdef _PIC16
4:             __far char *
5:             strncpy(register __far char * to, register const char * from, register size_t size)
6:             #else /* _PIC16 */
7:             char *
8:             strncpy(register char * to, register const char * from, register size_t size)
143D  00F6     MOVWF ep
9:             #endif /* _PIC16 */
10:            {
11:            
12:            #ifdef _PIC16
13:            	register __far char *	cp;
14:            #else /* _PIC16 */
15:            	register char *	cp;
16:            #endif /* _PIC16 */
17:            
18:            	cp = to;
143E  00F7     MOVWF p
19:            	while(size) {
143F  0872     MOVF EPNum, W
1440  0473     IORWF handle, W
1442  1903     BTFSC STATUS, 0x2
1443  2C63     GOTO 0x463
20:            		size--;
1441  3001     MOVLW 0x1
1444  02F2     SUBWF EPNum, F
1445  3000     MOVLW 0x0
1446  3BF3     SUBWFB handle, F
21:            		if(!(*cp++ = *from++))
1447  0877     MOVF p, W
1448  0086     MOVWF FSR1
1449  3002     MOVLW 0x2
144A  0087     MOVWF FSR1H
144B  0AF7     INCF p, F
144C  0871     MOVF data, W
144D  00F5     MOVWF byteToRead
144E  0870     MOVF __pcstackCOMMON, W
144F  00F4     MOVWF options
1450  0AF0     INCF __pcstackCOMMON, F
1451  1903     BTFSC STATUS, 0x2
1452  0AF1     INCF data, F
1453  0084     MOVWF FSR0
1454  0875     MOVF byteToRead, W
1455  0085     MOVWF FSR0H
1456  0800     MOVF INDF0, W
1457  3FC0     MOVWI 0[FSR1]
1458  0889     MOVF WREG, F
1459  1903     BTFSC STATUS, 0x2
145A  2C62     GOTO 0x462
145B  2C3F     GOTO 0x43F
22:            			break;
23:            	}
24:            	while(size--)
1462  3001     MOVLW 0x1
25:            		*cp++ = 0;
145C  0877     MOVF p, W
145D  0086     MOVWF FSR1
145E  3002     MOVLW 0x2
145F  0087     MOVWF FSR1H
1460  0181     CLRF INDF1
1461  0AF7     INCF p, F
1462  3001     MOVLW 0x1
1463  02F2     SUBWF EPNum, F
1464  3000     MOVLW 0x0
1465  3BF3     SUBWFB handle, F
1466  0F72     INCFSZ EPNum, W
1467  2C5C     GOTO 0x45C
1468  0A73     INCF handle, W
1469  1903     BTFSC STATUS, 0x2
146A  0008     RETURN
146B  2C5C     GOTO 0x45C
26:            	return to;
27:            }
---  /opt/microchip/xc8/v2.10/pic/sources/c90/common/memset.c  ------------------------------------------
1:             #include	<string.h>
2:             
3:             #ifdef _PIC16
4:             __far void *
5:             memset(__far void * p1, int c, register size_t n)
6:             #else /*  _PIC16 */
7:             void *
8:             memset(void * p1, int c, register size_t n)
9:             #endif /* _PIC16 */
10:            {
11:            
12:            #ifdef _PIC16
13:            	register __far char *	p;
14:            #else /*  _PIC16 */
15:            	register char *		p;
16:            #endif /* _PIC16 */
17:            
18:            	p = p1;
0526  0871     MOVF data, W
0527  00F7     MOVWF p
0528  0870     MOVF __pcstackCOMMON, W
0529  00F6     MOVWF ep
19:            	while(n--)
052A  3001     MOVLW 0x1
052B  02F4     SUBWF options, F
052C  3000     MOVLW 0x0
052D  3BF5     SUBWFB byteToRead, F
052E  0F74     INCFSZ options, W
052F  2D33     GOTO 0x533
0530  0A75     INCF byteToRead, W
0531  1903     BTFSC STATUS, 0x2
0532  0008     RETURN
053C  2D2A     GOTO 0x52A
20:            		*p++ = c;
0533  0876     MOVF ep, W
0534  0086     MOVWF FSR1
0535  0877     MOVF p, W
0536  0087     MOVWF FSR1H
0537  0872     MOVF EPNum, W
0538  0081     MOVWF INDF1
0539  0AF6     INCF ep, F
053A  1903     BTFSC STATUS, 0x2
053B  0AF7     INCF p, F
053C  2D2A     GOTO 0x52A
21:            	return p1;
22:            }
0004  147E     BSF 0x7E, 0x0
---  /home/phil/Projects/XPRESS-Loader/framework/usb/src/usb_device_msd.c  ------------------------------
1:             // DOM-IGNORE-BEGIN
2:             /*******************************************************************************
3:             Copyright 2015 Microchip Technology Inc. (www.microchip.com)
4:             
5:             Licensed under the Apache License, Version 2.0 (the "License");
6:             you may not use this file except in compliance with the License.
7:             You may obtain a copy of the License at
8:             
9:                 http://www.apache.org/licenses/LICENSE-2.0
10:            
11:            Unless required by applicable law or agreed to in writing, software
12:            distributed under the License is distributed on an "AS IS" BASIS,
13:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
14:            See the License for the specific language governing permissions and
15:            limitations under the License.
16:            
17:            To request to license the code under the MLA license (www.microchip.com/mla_license), 
18:            please contact mla_licensing@microchip.com
19:            *******************************************************************************/
20:            //DOM-IGNORE-END
21:             
22:            /** I N C L U D E S **************************************************/
23:            #include "usb.h"
24:            #include "system.h"
25:            #include "system_config.h"
26:            
27:            #include <usb_device_msd.h>
28:            
29:            #ifdef USB_USE_MSD
30:            
31:            #if MAX_LUN == 0
32:                #define LUN_INDEX 0
33:            #else
34:                #define LUN_INDEX gblCBW.bCBWLUN
35:            #endif
36:            
37:            extern LUN_FUNCTIONS LUN[MAX_LUN + 1];
38:            #define LUNMediaInitialize()                LUN[LUN_INDEX].MediaInitialize(LUN[LUN_INDEX].mediaParameters)
39:            #define LUNReadCapacity()                   LUN[LUN_INDEX].ReadCapacity(LUN[LUN_INDEX].mediaParameters)
40:            #define LUNReadSectorSize()                 LUN[LUN_INDEX].ReadSectorSize(LUN[LUN_INDEX].mediaParameters)
41:            #define LUNMediaDetect()                    LUN[LUN_INDEX].MediaDetect(LUN[LUN_INDEX].mediaParameters)
42:            #define LUNSectorWrite(bLBA,pDest,seg)      LUN[LUN_INDEX].SectorWrite(LUN[LUN_INDEX].mediaParameters, bLBA, pDest, seg)
43:            #define LUNWriteProtectState()              LUN[LUN_INDEX].WriteProtectState(LUN[LUN_INDEX].mediaParameters)
44:            #define LUNSectorRead(bLBA,pSrc,seg)        LUN[LUN_INDEX].SectorRead(LUN[LUN_INDEX].mediaParameters, bLBA, pSrc, seg)
45:            
46:            //Adjustable user options
47:            #define MSD_FAILED_READ_MAX_ATTEMPTS  (uint8_t)1u    //Used for error case handling
48:            #define MSD_FAILED_WRITE_MAX_ATTEMPTS (uint8_t)1u    //Used for error case handling
49:            
50:            /** V A R I A B L E S ************************************************/
51:            #if defined(__18CXX)
52:                #pragma udata
53:            #endif
54:            // buffers
55:            //Check if the MSD application specific USB endpoint buffer placement address 
56:            //macros have already been defined or not (ex: in a processor specific header)
57:            //The msd_cbw and msd_csw buffers must be USB module accessible (and therefore
58:            //must be at a certain address range on certain microcontrollers).
59:            #if !defined(MSD_CBW_ADDR_TAG)
60:                //Not previously defined.  Assume in this case all microcontroller RAM is
61:                //USB module accessible, and therefore, no specific address tag value is needed.
62:                #define MSD_CBW_ADDR_TAG
63:                #define MSD_CSW_ADDR_TAG
64:            #endif
65:            volatile USB_MSD_CBW msd_cbw MSD_CBW_ADDR_TAG;  //Must be located in USB module accessible RAM
66:            volatile USB_MSD_CSW msd_csw MSD_CSW_ADDR_TAG;  //Must be located in USB module accessible RAM
67:            
68:            #if defined(__18CXX) || defined(__XC8)
69:                volatile char msd_buffer[64];
70:            #else
71:                volatile char msd_buffer[512];
72:            #endif
73:            
74:            //State machine variables
75:            uint8_t MSD_State;			// Takes values MSD_WAIT, MSD_DATA_IN or MSD_DATA_OUT
76:            uint8_t MSDCommandState;
77:            uint8_t MSDReadState;
78:            uint8_t MSDWriteState;
79:            uint8_t MSDRetryAttempt;
80:            //Other variables
81:            USB_MSD_CBW gblCBW;	
82:            uint8_t gblCBWLength;
83:            RequestSenseResponse gblSenseData[MAX_LUN + 1];
84:            uint8_t *ptrNextData;
85:            USB_HANDLE USBMSDOutHandle;
86:            USB_HANDLE USBMSDInHandle;
87:            uint16_t MSBBufferIndex;
88:            uint16_t gblMediaPresent; 
89:            bool SoftDetach[MAX_LUN + 1];
90:            bool MSDHostNoData;
91:            bool MSDCBWValid;
92:            
93:            static USB_MSD_TRANSFER_LENGTH TransferLength;
94:            static USB_MSD_LBA LBA;
95:            
96:            /* 
97:             * Number of Blocks and Block Length are global because 
98:             * for every READ_10 and WRITE_10 command need to verify if the last LBA 
99:             * is less than gblNumBLKS	
100:            */	
101:           USB_MSD_BLK gblNumBLKS,gblBLKLen;
102:           extern const InquiryResponse inq_resp;
103:           
104:           /** P R I V A T E  P R O T O T Y P E S ***************************************/
105:           uint8_t MSDProcessCommand(void);
106:           void MSDProcessCommandMediaAbsent(void);
107:           void MSDProcessCommandMediaPresent(void);
108:           uint8_t MSDReadHandler(void);
109:           uint8_t MSDWriteHandler(void);
110:           void ResetSenseData(void);
111:           uint8_t MSDCheckForErrorCases(uint32_t);
112:           void MSDErrorHandler(uint8_t);
113:           static void MSDComputeDeviceInAndResidue(uint16_t);
114:           
115:           /** D E C L A R A T I O N S **************************************************/
116:           #if defined(__18CXX)
117:               #pragma code
118:           #endif
119:           
120:           /** C L A S S  S P E C I F I C  R E Q ****************************************/
121:           
122:           /******************************************************************************
123:             Function:
124:               void USBMSDInit(void)
125:               
126:             Summary:
127:               This routine initializes the MSD class packet handles, prepares to
128:               receive a MSD packet, and initializes the MSD state machine. This
129:               \function should be called once after the device is enumerated.
130:           
131:             Description:
132:               This routine initializes the MSD class packet handles, prepares to
133:               receive a MSD packet, and initializes the MSD state machine. This
134:               \function should be called once after the device is enumerated.
135:               
136:               Typical Usage:
137:               <code>
138:               void USBCBInitEP(void)
139:               {
140:                   USBEnableEndpoint(MSD_DATA_IN_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
141:                   USBMSDInit();
142:               }
143:               </code>
144:             Conditions:
145:               The device should already be enumerated with a configuration that
146:               supports MSD before calling this function.
147:               
148:             Parameters: None
149:           
150:             Remarks:
151:               None                                                                                                          
152:             ****************************************************************************/	
153:           void USBMSDInit(void)
154:           {
155:               //Prepare to receive the first CBW
156:               USBMSDOutHandle = USBRxOnePacket(MSD_DATA_OUT_EP,(uint8_t*)&msd_cbw,MSD_OUT_EP_SIZE);
0871  3185     MOVLP 0x5
0872  2598     CALL 0x598
0873  3188     MOVLP 0x8
0874  3184     MOVLP 0x4
0875  2427     CALL 0x427
0876  3188     MOVLP 0x8
0877  0021     MOVLB 0x1
0878  00ED     MOVWF USBMSDOutHandle
157:               //Initialize IN handle to point to first available IN MSD bulk endpoint entry
158:               USBMSDInHandle = USBGetNextHandle(MSD_DATA_IN_EP, IN_TO_HOST);
0879  0022     MOVLB 0x2
087A  0839     MOVF 0x139, W
087B  0021     MOVLB 0x1
087C  00E5     MOVWF USBMSDInHandle
159:               MSD_State = MSD_WAIT;
087D  2101     CALL 0x101
087E  3188     MOVLP 0x8
160:               MSDCommandState = MSD_COMMAND_WAIT;
161:               MSDReadState = MSD_READ10_WAIT;
162:               MSDWriteState = MSD_WRITE10_WAIT;
163:               MSDHostNoData = false;
087F  01C8     CLRF 0xC8
164:               gblNumBLKS.Val = 0;
165:               gblBLKLen.Val = 0;
166:               MSDCBWValid = true;
0880  01DF     CLRF 0xDF
0881  0ADF     INCF 0xDF, F
167:           
168:               gblMediaPresent = 0;
0882  01C2     CLRF 0xC2
0883  01C3     CLRF 0xC3
169:           
170:               //For each of the possible logical units
171:               for(gblCBW.bCBWLUN=0;gblCBW.bCBWLUN<(MAX_LUN + 1);gblCBW.bCBWLUN++)
0884  0023     MOVLB 0x3
0885  01AD     CLRF 0x1AD
0886  082D     MOVF 0x1AD, W
0887  1D03     BTFSS STATUS, 0x2
0888  0008     RETURN
08B7  0AAD     INCF 0x1AD, F
08B8  2886     GOTO 0x86
172:               {
173:                   //clear all of the soft detach variables
174:                   SoftDetach[gblCBW.bCBWLUN] =  false;
0889  3E49     ADDLW 0x49
088A  0086     MOVWF FSR1L
088B  3001     MOVLW 0x1
088C  0087     MOVWF FSR1H
088D  0181     CLRF INDF1
175:           
176:                   //see if the media is attached
177:                   if(LUNMediaDetect())
088E  086A     MOVF 0x1EA, W
088F  00F0     MOVWF 0x1F0
0890  3006     MOVLW 0x6
0891  3EDC     ADDLW 0xDC
0892  0086     MOVWF FSR1L
0893  3F41     MOVIW 1[FSR1]
0894  008A     MOVWF PCLATH
0895  3F40     MOVIW 0[FSR1]
0896  000A     CALLW
0897  3188     MOVLP 0x8
0898  3A00     XORLW 0x0
0899  1903     BTFSC STATUS, 0x2
089A  28B4     GOTO 0xB4
178:                   {
179:                       //initialize the media
180:                       if(LUNMediaInitialize())
089B  086A     MOVF 0x1EA, W
089C  00F0     MOVWF 0x1F0
089D  085D     MOVF 0x1DD, W
089E  008A     MOVWF PCLATH
089F  085C     MOVF LUN, W
08A0  000A     CALLW
08A1  3188     MOVLP 0x8
08A2  3A00     XORLW 0x0
08A3  1903     BTFSC STATUS, 0x2
08A4  28B4     GOTO 0xB4
181:                       {
182:                           //if the media was present and successfully initialized
183:                           //  then mark and indicator that the media is ready
184:                           gblMediaPresent |= ((uint16_t)1<<gblCBW.bCBWLUN);
08A5  3001     MOVLW 0x1
08A6  00F8     MOVWF 0x1F8
08A7  01F9     CLRF 0x1F9
08A8  0023     MOVLB 0x3
08A9  0A2D     INCF 0x1AD, W
08AA  28AD     GOTO 0xAD
08AB  35F8     LSLF 0x1F8, F
08AC  0DF9     RLF 0x1F9, F
08AD  0B89     DECFSZ WREG, F
08AE  28AB     GOTO 0xAB
08AF  0878     MOVF 0x1F8, W
08B0  0022     MOVLB 0x2
08B1  04C2     IORWF gblMediaPresent, F
08B2  0879     MOVF 0x179, W
08B3  04C3     IORWF 0x143, F
185:                       }
186:                   }
187:                   ResetSenseData();
08B4  3185     MOVLP 0x5
08B5  253D     CALL 0x53D
08B6  3188     MOVLP 0x8
08B7  0AAD     INCF 0x12D, F
08B8  2886     GOTO 0x86
188:               }
189:           }
190:           
191:           /******************************************************************************
192:            	Function:
193:            		void USBCheckMSDRequest(void)
194:           
195:            	Summary:
196:            		This routine handles MSD specific request that happen on EP0.  
197:                   This function should be called from the USBCBCheckOtherReq() call back 
198:                   function whenever implementing an MSD device.
199:           
200:            	Description:
201:            		This routine handles MSD specific request that happen on EP0.  These
202:                   include, but are not limited to, the standard RESET and GET_MAX_LUN 
203:            		command requests.  This function should be called from the 
204:                   USBCBCheckOtherReq() call back function whenever using an MSD device.	
205:           
206:                   Typical Usage:
207:                   <code>
208:                   void USBCBCheckOtherReq(void)
209:                   {
210:                       //Since the stack didn't handle the request I need to check
211:                       //  my class drivers to see if it is for them
212:                       USBCheckMSDRequest();
213:                   }
214:                   </code>
215:           
216:            	PreCondition:
217:            		None
218:            		
219:            	Parameters:
220:            		None
221:            	
222:            	Return Values:
223:            		None
224:            		
225:            	Remarks:
226:            		None
227:            
228:            *****************************************************************************/	
229:           void USBCheckMSDRequest(void)
230:           {
231:               if(SetupPkt.Recipient != USB_SETUP_RECIPIENT_INTERFACE_BITFIELD)
08B9  0020     MOVLB 0x0
08BA  0860     MOVF SetupPkt, W
08BB  391F     ANDLW 0x1F
08BC  3A01     XORLW 0x1
08BD  1D03     BTFSS STATUS, 0x2
08BE  0008     RETURN
232:               {
233:                   return;
234:               }
235:               
236:               if(SetupPkt.bIntfID != MSD_INTF_ID) 
08BF  0864     MOVF 0x64, W
08C0  1D03     BTFSS STATUS, 0x2
08C1  0008     RETURN
08C2  28F8     GOTO 0xF8
237:               {
238:                   return;
239:               }
240:           
241:               switch(SetupPkt.bRequest)
08F8  0861     MOVF 0x61, W
08F9  3AFE     XORLW 0xFE
08FA  1903     BTFSC STATUS, 0x2
08FB  28E5     GOTO 0xE5
08FC  3A01     XORLW 0x1
08FD  1903     BTFSC STATUS, 0x2
08FE  28C3     GOTO 0xC3
08FF  2900     GOTO 0x100
242:               {
243:                   case MSD_RESET:
244:                       //First make sure all request parameters are correct:
245:                       //MSD BOT specs require wValue to be == 0x0000 and wLength == 0x0000
246:                       if((SetupPkt.wValue != 0) || (SetupPkt.wLength != 0))
08C3  0862     MOVF 0x62, W
08C4  0463     IORWF 0x63, W
08C5  1D03     BTFSS STATUS, 0x2
08C6  0008     RETURN
08C7  0866     MOVF 0x66, W
08C8  0467     IORWF 0x67, W
08C9  1D03     BTFSS STATUS, 0x2
08CA  0008     RETURN
08CB  2101     CALL 0x101
08CC  3188     MOVLP 0x8
247:                       {
248:                           return; //Return without handling the request (results in STALL)
249:                       }
250:           
251:                       //Host would typically issue this after a STALL event on an MSD
252:                       //bulk endpoint.  The MSD reset should re-initialize status
253:                       //so as to prepare for a new CBW.  Any currently ongoing command
254:                       //block should be aborted, but the STALL and DTS states need to be
255:                       //maintained (host will re-initialize these separately using
256:                       //CLEAR_FEATURE, endpoint halt).
257:                       MSD_State = MSD_WAIT;
258:                       MSDCommandState = MSD_COMMAND_WAIT;
259:                       MSDReadState = MSD_READ10_WAIT;
260:                       MSDWriteState = MSD_WRITE10_WAIT;
261:                       MSDCBWValid = true;
08CD  01DF     CLRF 0x5F
08CE  0ADF     INCF 0x5F, F
262:                       //Need to re-arm MSD bulk OUT endpoint, if it isn't currently armed,
263:                       //to be able to receive next CBW.  If it is already armed, don't need
264:                       //to do anything, since we can already receive the next CBW (or we are
265:                       //STALLed, and the host will issue clear halt first).
266:                       if(!USBHandleBusy(USBGetNextHandle(MSD_DATA_OUT_EP, OUT_FROM_HOST)))
08CF  083D     MOVF 0x3D, W
08D0  00F8     MOVWF seg
08D1  0878     MOVF seg, W
08D2  1903     BTFSC STATUS, 0x2
08D3  28DA     GOTO 0xDA
08D4  083D     MOVF 0x3D, W
08D5  00F9     MOVWF buffer
08D6  0086     MOVWF FSR1
08D7  0187     CLRF FSR1H
08D8  1B81     BTFSC INDF1, 0x7
08D9  28E1     GOTO 0xE1
267:                       {
268:                           USBMSDOutHandle = USBRxOnePacket(MSD_DATA_OUT_EP,(uint8_t*)&msd_cbw,MSD_OUT_EP_SIZE);
08DA  3185     MOVLP 0x5
08DB  2598     CALL 0x598
08DC  3188     MOVLP 0x8
08DD  3184     MOVLP 0x4
08DE  2427     CALL 0x427
08DF  0021     MOVLB 0x1
08E0  00ED     MOVWF USBMSDOutHandle
269:                       }
270:           
271:                       //Let USB stack know we took care of handling the EP0 SETUP request.
272:                       //Allow zero byte status stage to proceed normally now.
273:                       USBEP0Transmit(USB_EP0_NO_DATA);
08E1  3080     MOVLW 0x80
08E2  0022     MOVLB 0x2
08E3  00A9     MOVWF 0x129
274:                       break;
08E4  0008     RETURN
275:                       
276:                   case GET_MAX_LUN:
277:                       //First make sure all request parameters are correct:
278:                       //MSD BOT specs require wValue to be == 0x0000, and wLengh == 1
279:                       if((SetupPkt.wValue != 0) || (SetupPkt.wLength != 1))
08E5  0862     MOVF 0x162, W
08E6  0463     IORWF 0x163, W
08E7  1D03     BTFSS STATUS, 0x2
08E8  0008     RETURN
08E9  0366     DECF 0x166, W
08EA  0467     IORWF 0x167, W
08EB  1D03     BTFSS STATUS, 0x2
08EC  0008     RETURN
280:                       {
281:                           break;  //Return without handling the request (results in STALL)
282:                       }
283:           
284:                       //If the host asks for the maximum number of logical units
285:                       //  then send out a packet with that information
286:                       CtrlTrfData[0] = MAX_LUN;
08ED  01E8     CLRF 0x168
287:                       USBEP0SendRAMPtr((uint8_t*)&CtrlTrfData[0],1,USB_EP0_INCLUDE_ZERO);
08EE  3068     MOVLW 0x68
08EF  0022     MOVLB 0x2
08F0  00A7     MOVWF inPipes
08F1  30C1     MOVLW 0xC1
08F2  01A8     CLRF 0x128
08F3  01AA     CLRF 0x12A
08F4  0AAA     INCF 0x12A, F
08F5  01AB     CLRF 0x12B
08F6  00A9     MOVWF 0x129
288:                       break;
08F7  0008     RETURN
289:               }	//end switch(SetupPkt.bRequest)
290:           }
0900  0008     RETURN
291:           
292:           /*********************************************************************************
293:             Function:
294:                   uint8_t MSDTasks(void)
295:               
296:             Summary:
297:               This function runs the MSD class state machines and all of its
298:               sub-systems. This function should be called periodically once the
299:               device is in the configured state in order to keep the MSD state
300:               machine going.
301:             Description:
302:               This function runs the MSD class state machines and all of its
303:               sub-systems. This function should be called periodically once the
304:               device is in the configured state in order to keep the MSD state
305:               machine going.
306:               
307:               Typical Usage:
308:               <code>
309:               void main(void)
310:               {
311:                   USBDeviceInit();
312:                   while(1)
313:                   {
314:                       USBDeviceTasks();
315:                       if((USBGetDeviceState() \< CONFIGURED_STATE) ||
316:                          (USBIsDeviceSuspended() == true))
317:                       {
318:                           //Either the device is not configured or we are suspended
319:                           //  so we don't want to do execute any application code
320:                           continue;   //go back to the top of the while loop
321:                       }
322:                       else
323:                       {
324:                           //Keep the MSD state machine going
325:                           MSDTasks();
326:               
327:                           //Run application code.
328:                           UserApplication();
329:                       }
330:                   }
331:               }
332:               </code>
333:             Conditions:
334:               None
335:             Return Values:
336:               uint8_t -  the current state of the MSD state machine the valid values are
337:                       defined in MSD.h under the MSDTasks state machine declaration section.
338:                       The possible values are the following\:
339:                       * MSD_WAIT
340:                       * MSD_DATA_IN
341:                       * MSD_DATA_OUT
342:                       * MSD_SEND_CSW
343:             Remarks:
344:               None                                                                          
345:             *********************************************************************************/	
346:           uint8_t MSDTasks(void)
347:           {
348:               uint8_t i;
349:               
350:               //Error check to make sure we have are in the CONFIGURED_STATE, prior to
351:               //performing MSDTasks().  Some of the MSDTasks require that the device be
352:               //configured first.
353:               if(USBGetDeviceState() != CONFIGURED_STATE)
02CC  3020     MOVLW 0x20
02CD  0021     MOVLB 0x1
02CE  066E     XORWF USBDeviceState, W
02CF  1D03     BTFSS STATUS, 0x2
02D0  0008     RETURN
354:               {
355:                   return MSD_WAIT;
356:               }
357:               
358:               //Note: Both the USB stack code (usb_device.c) and this MSD handler code 
359:               //have the ability to modify the BDT values for the MSD bulk endpoints.  If the 
360:               //USB stack operates in USB_INTERRUPT mode (user option in usb_config.h), we
361:               //should temporarily disable USB interrupts, to avoid any possibility of both 
362:               //the USB stack and this MSD handler from modifying the same BDT entry, or
363:               //MSD state machine variables (ex: in the case of MSD_RESET) at the same time.
364:               USBMaskInterrupts();
365:               
366:               //Main MSD task dispatcher.  Receives MSD Command Block Wrappers (CBW) and
367:               //dispatches appropriate lower level handlers to service the requests.
368:               switch(MSD_State)
02D1  0022     MOVLB 0x2
02D2  084D     MOVF MSD_State, W
02D3  3A00     XORLW 0x0
02D4  1903     BTFSC STATUS, 0x2
02D5  2AE1     GOTO 0x2E1
02D6  3A01     XORLW 0x1
02D7  1903     BTFSC STATUS, 0x2
02D8  2B77     GOTO 0x377
02D9  3A03     XORLW 0x3
02DA  1903     BTFSC STATUS, 0x2
02DB  2B80     GOTO 0x380
02DC  3A01     XORLW 0x1
02DD  1903     BTFSC STATUS, 0x2
02DE  2B91     GOTO 0x391
02DF  2BBC     GOTO 0x3BC
369:               {
370:                   case MSD_WAIT: //idle state, when we are waiting for a command from the host
371:                   {
372:                       //Check if we have received a new command block wrapper (CBW)
373:                       if(!USBHandleBusy(USBMSDOutHandle))
02E1  0021     MOVLB 0x1
02E2  086D     MOVF USBMSDOutHandle, W
02E3  1903     BTFSC STATUS, 0x2
02E4  2AEA     GOTO 0x2EA
02E5  086D     MOVF USBMSDOutHandle, W
02E6  0086     MOVWF FSR1L
02E7  0187     CLRF FSR1H
02E8  1B81     BTFSC INDF1, 0x7
02E9  0008     RETURN
374:                       {
375:                           //If we are in the MSD_WAIT state, and we received an OUT transaction
376:                           //on the MSD OUT endpoint, then we must have just received an MSD
377:                           //Command Block Wrapper (CBW).
378:                           //First copy the the received data to to the gblCBW structure, so
379:                           //that we keep track of the command, but free up the MSD OUT endpoint
380:                           //buffer for fulfilling whatever request may have been received.
381:                           //gblCBW = msd_cbw; //we are doing this, but below method can yield smaller code size
382:                           for(i = 0; i < MSD_CBW_SIZE; i++)
02EA  01E3     CLRF i
02F7  301F     MOVLW 0x1F
02F8  0AE3     INCF i, F
02F9  0263     SUBWF i, W
02FA  1C03     BTFSS STATUS, 0x0
02FB  2AEB     GOTO 0x2EB
383:                           {
384:                               *((uint8_t*)&gblCBW.dCBWSignature + i) = *((uint8_t*)&msd_cbw.dCBWSignature + i);
02EB  0863     MOVF i, W
02EC  3EA0     ADDLW 0xA0
02ED  0086     MOVWF FSR1L
02EE  3001     MOVLW 0x1
02EF  0087     MOVWF FSR1H
02F0  0863     MOVF i, W
02F1  3E24     ADDLW 0x24
02F2  0084     MOVWF FSR0L
02F3  3002     MOVLW 0x2
02F4  0085     MOVWF FSR0H
02F5  0800     MOVF INDF0, W
02F6  0081     MOVWF INDF1
385:                           }
386:           
387:                           //If this CBW is valid?
388:                           if((USBHandleGetLength(USBMSDOutHandle) == MSD_CBW_SIZE) && (gblCBW.dCBWSignature == MSD_VALID_CBW_SIGNATURE))
02FC  0A6D     INCF USBMSDOutHandle, W
02FD  0086     MOVWF FSR1L
02FE  301F     MOVLW 0x1F
02FF  0187     CLRF FSR1H
0300  0601     XORWF INDF1, W
0301  1D03     BTFSS STATUS, 0x2
0302  2B6C     GOTO 0x36C
0303  3055     MOVLW 0x55
0304  0023     MOVLB 0x3
0305  0620     XORWF gblCBW, W
0306  3053     MOVLW 0x53
0307  1903     BTFSC STATUS, 0x2
0308  0621     XORWF 0x1A1, W
0309  3042     MOVLW 0x42
030A  1903     BTFSC STATUS, 0x2
030B  0622     XORWF 0x1A2, W
030C  3043     MOVLW 0x43
030D  1903     BTFSC STATUS, 0x2
030E  0623     XORWF 0x1A3, W
030F  1D03     BTFSS STATUS, 0x2
0310  2B6C     GOTO 0x36C
389:                           {
390:                               //The CBW was valid, set flag meaning any stalls after this point
391:                               //should not be "persistent" (as in the case of non-valid CBWs).
392:                               MSDCBWValid = true;
0311  0022     MOVLB 0x2
0312  01DF     CLRF MSDCBWValid
0313  0ADF     INCF MSDCBWValid, F
393:           
394:                               //Is this CBW meaningful?
395:                               if((gblCBW.bCBWLUN <= MAX_LUN)                                      //Verify the command is addressed to a supported LUN
396:                                   &&(gblCBW.bCBWCBLength <= MSD_MAX_CB_SIZE)                          //Verify the claimed CB length is reasonable/valid
397:                                   &&(gblCBW.bCBWCBLength >= 0x01)                                     //Verify the claimed CB length is reasonable/valid
398:                                   &&((gblCBW.bCBWFlags & MSD_CBWFLAGS_RESERVED_BITS_MASK) == 0x00))   //Verify reserved bits are clear
0314  0023     MOVLB 0x3
0315  082D     MOVF 0x1AD, W
0316  1D03     BTFSS STATUS, 0x2
0317  2B64     GOTO 0x364
0318  3011     MOVLW 0x11
0319  022E     SUBWF 0x1AE, W
031A  1803     BTFSC STATUS, 0x0
031B  2B64     GOTO 0x364
031C  082E     MOVF 0x1AE, W
031D  1903     BTFSC STATUS, 0x2
031E  2B64     GOTO 0x364
031F  082C     MOVF 0x1AC, W
0320  393F     ANDLW 0x3F
0321  1D03     BTFSS STATUS, 0x2
0322  2B64     GOTO 0x364
399:                               {
400:           
401:                                   //The CBW was both valid and meaningful.
402:                                   //Begin preparing a valid Command Status Wrapper (CSW),
403:                                   //in anticipation of completing the request successfully.
404:                                   //If an error detected is later, we will change the status
405:                                   //before sending the CSW.
406:                                   msd_csw.dCSWSignature = MSD_VALID_CSW_SIGNATURE;
0323  3053     MOVLW 0x53
0324  0022     MOVLB 0x2
0325  00E3     MOVWF 0x163
0326  3042     MOVLW 0x42
0327  00E2     MOVWF 0x162
0328  3053     MOVLW 0x53
0329  00E1     MOVWF 0x161
032A  3055     MOVLW 0x55
032B  00E0     MOVWF msd_csw
407:                                   msd_csw.dCSWTag = gblCBW.dCBWTag;
032C  3004     MOVLW 0x4
032D  318F     MOVLP 0xF
032E  27DC     CALL 0x7DC
032F  3180     MOVLP 0x0
0330  00E4     MOVWF 0x164
0331  3F41     MOVIW 1[FSR1]
0332  00E5     MOVWF 0x165
0333  3F42     MOVIW 2[FSR1]
0334  00E6     MOVWF 0x166
0335  3F43     MOVIW 3[FSR1]
0336  00E7     MOVWF 0x167
408:                                   msd_csw.dCSWDataResidue = 0x0;
0337  01E8     CLRF 0x168
0338  01E9     CLRF 0x169
0339  01EA     CLRF 0x16A
033A  01EB     CLRF 0x16B
409:                                   msd_csw.bCSWStatus = MSD_CSW_COMMAND_PASSED;
033B  01EC     CLRF 0x16C
410:           
411:                                   //Since a new CBW just arrived, we should re-init the
412:                                   //lower level state machines to their default states.
413:                                   //Even if the prior operation didn't fully complete
414:                                   //normally, we should abandon the prior operation, when
415:                                   //a new CBW arrives.
416:                                   MSDCommandState = MSD_COMMAND_WAIT;
033C  30FF     MOVLW 0xFF
033D  0021     MOVLB 0x1
033E  00E6     MOVWF MSDCommandState
417:                                   MSDReadState = MSD_READ10_WAIT;
033F  0022     MOVLB 0x2
0341  01CC     CLRF MSDReadState
418:                                   MSDWriteState = MSD_WRITE10_WAIT;
0342  01CB     CLRF MSDWriteState
419:           
420:                                   //Keep track of retry attempts, in case of temporary
421:                                   //failures during read or write of the media.
422:                                   MSDRetryAttempt = 0;
423:           
424:                                   //Check the command.  With the exception of the REQUEST_SENSE
425:                                   //command, we should reset the sense key info for each new command block.
426:                                   //Assume the command will get processed successfully (and hence "NO SENSE"
427:                                   //response, which is used for success cases), unless handler code
428:                                   //later on detects some kind of error.  If it does, it should
429:                                   //update the sense keys to reflect the type of error detected,
430:                                   //prior to sending the CSW.
431:                                   if(gblCBW.CBWCB[0] != MSD_REQUEST_SENSE)
0340  3003     MOVLW 0x3
0343  0023     MOVLB 0x3
0344  062F     XORWF 0x1AF, W
0345  1903     BTFSC STATUS, 0x2
0346  2B4B     GOTO 0x34B
432:                                   {
433:                                       gblSenseData[LUN_INDEX].SenseKey=S_NO_SENSE;
0347  30F0     MOVLW 0xF0
0348  05C1     ANDWF 0x1C1, F
434:                                       gblSenseData[LUN_INDEX].ASC=ASC_NO_ADDITIONAL_SENSE_INFORMATION;
0349  01CB     CLRF 0x1CB
435:                                       gblSenseData[LUN_INDEX].ASCQ=ASCQ_NO_ADDITIONAL_SENSE_INFORMATION;
034A  01CC     CLRF 0x1CC
436:                                   }
437:           
438:                                   //Isolate the data direction bit.  The direction bit is bit 7 of the bCBWFlags byte.
439:                                   //Then, based on the direction of the data transfer, prepare the MSD state machine
440:                                   //so it knows how to proceed with processing the request.
441:                                   //If bit7 = 0, then direction is OUT from host.  If bit7 = 1, direction is IN to host
442:                                   if (gblCBW.bCBWFlags & MSD_CBW_DIRECTION_BITMASK)
034B  1FAC     BTFSS 0x1AC, 0x7
034C  2B51     GOTO 0x351
443:                                   {
444:                                       MSD_State = MSD_DATA_IN;
034D  0022     MOVLB 0x2
034E  01CD     CLRF MSD_State
034F  0ACD     INCF MSD_State, F
445:                                   }
0350  2B54     GOTO 0x354
446:                                   else //else direction must be OUT from host
447:                                   {
448:                                       MSD_State = MSD_DATA_OUT;
0351  3002     MOVLW 0x2
0352  0022     MOVLB 0x2
0353  00CD     MOVWF MSD_State
449:                                   }
450:           
451:                                   //Determine if the host is expecting there to be data transfer or not.
452:                                   //Doing this now will make for quicker error checking later.
453:                                   if(gblCBW.dCBWDataTransferLength != 0)
0354  318F     MOVLP 0xF
0355  27C4     CALL 0x7C4
0356  3180     MOVLP 0x0
0357  1903     BTFSC STATUS, 0x2
0358  2B5C     GOTO 0x35C
454:                                   {
455:                                       MSDHostNoData = false;
0359  0022     MOVLB 0x2
035A  01C8     CLRF MSDHostNoData
456:                                   }
035B  2B5F     GOTO 0x35F
457:                                   else
458:                                   {
459:                                       MSDHostNoData = true;
035C  0022     MOVLB 0x2
035D  01C8     CLRF MSDHostNoData
035E  0AC8     INCF MSDHostNoData, F
460:                                   }
461:           
462:                                   //Copy the received command to the lower level command
463:                                   //state machine, so it knows what to do.
464:                                   MSDCommandState = gblCBW.CBWCB[0];
035F  0023     MOVLB 0x3
0360  082F     MOVF 0x1AF, W
0361  0021     MOVLB 0x1
0362  00E6     MOVWF MSDCommandState
465:                               }
0363  0008     RETURN
466:                               else
467:                               {
468:                                   //else the CBW wasn't meaningful.  Section 6.4 of BOT specs v1.0 says,
469:                                   //"The response of a device to a CBW that is not meaningful is not specified."
470:                                   //Lets STALL the bulk endpoints, so as to promote the possibility of recovery.
471:                                   USBStallEndpoint(MSD_DATA_IN_EP, IN_TO_HOST);
0364  3001     MOVLW 0x1
0365  01F0     CLRF 0xF0
0366  0AF0     INCF 0xF0, F
0367  226B     CALL 0x26B
0368  3180     MOVLP 0x0
472:                                   USBStallEndpoint(MSD_DATA_OUT_EP, OUT_FROM_HOST);
0369  3001     MOVLW 0x1
036A  01F0     CLRF 0xF0
036B  2A6B     GOTO 0x26B
473:                               }
474:                           }//end of: if((USBHandleGetLength(USBMSDOutHandle) == MSD_CBW_SIZE) && (gblCBW.dCBWSignature == MSD_VALID_CBW_SIGNATURE))
475:                           else  //The CBW was not valid.
476:                           {
477:                               //Section 6.6.1 of the BOT specifications rev. 1.0 says the device shall STALL bulk IN and OUT
478:                               //endpoints (or should discard OUT data if not stalled), and should stay in this state until a
479:                               //"Reset Recovery" (MSD Reset + clear endpoint halt commands on EP0, see section 5.3.4)
480:                               USBStallEndpoint(MSD_DATA_IN_EP, IN_TO_HOST);
036C  3001     MOVLW 0x1
036D  01F0     CLRF 0xF0
036E  0AF0     INCF 0xF0, F
036F  226B     CALL 0x26B
0370  3180     MOVLP 0x0
481:                               USBStallEndpoint(MSD_DATA_OUT_EP, OUT_FROM_HOST);
0371  3001     MOVLW 0x1
0372  01F0     CLRF 0xF0
0373  226B     CALL 0x26B
482:                               MSDCBWValid = false;    //Flag so as to enable a "persistent"
0374  0022     MOVLB 0x2
0375  01DF     CLRF MSDCBWValid
0376  0008     RETURN
483:                               //stall (cannot be cleared by clear endpoint halt, unless preceded
484:                               //by an MSD reset).
485:                           }
486:                       }//if(!USBHandleBusy(USBMSDOutHandle))
487:                       break;
488:                   }//end of: case MSD_WAIT:
489:                   case MSD_DATA_IN:
490:                       if(MSDProcessCommand() == MSD_COMMAND_WAIT)
0377  23C2     CALL 0x3C2
0378  3180     MOVLP 0x0
0379  3AFF     XORLW 0xFF
037A  1D03     BTFSS STATUS, 0x2
037B  0008     RETURN
491:                       {
492:                           // Done processing the command, send the status
493:                           MSD_State = MSD_SEND_CSW;
037C  3003     MOVLW 0x3
037D  0022     MOVLB 0x2
037E  00CD     MOVWF MSD_State
037F  0008     RETURN
494:                       }
495:                       break;
496:                   case MSD_DATA_OUT:
497:                       if(MSDProcessCommand() == MSD_COMMAND_WAIT)
0380  23C2     CALL 0x3C2
0381  3180     MOVLP 0x0
0382  3AFF     XORLW 0xFF
0383  1D03     BTFSS STATUS, 0x2
0384  0008     RETURN
498:                       {
499:                           /* Finished receiving the data prepare and send the status */
500:                           if ((msd_csw.bCSWStatus == MSD_CSW_COMMAND_PASSED)&&(msd_csw.dCSWDataResidue!=0))
0385  0022     MOVLB 0x2
0386  086C     MOVF 0x16C, W
0387  1D03     BTFSS STATUS, 0x2
0388  2B7C     GOTO 0x37C
0389  318F     MOVLP 0xF
038A  27E8     CALL 0x7E8
038B  3180     MOVLP 0x0
038C  1903     BTFSC STATUS, 0x2
038D  2B7C     GOTO 0x37C
501:                           {
502:                               msd_csw.bCSWStatus = MSD_CSW_PHASE_ERROR;
038E  3002     MOVLW 0x2
038F  00EC     MOVWF 0x16C
0390  2B7C     GOTO 0x37C
503:                           }
504:                           MSD_State = MSD_SEND_CSW;
505:                       }
506:                       break;
507:                   case MSD_SEND_CSW:
508:                       //Check to make sure the bulk IN endpoint is available before sending CSW.
509:                       //The endpoint might still be busy sending the last packet on the IN endpoint.
510:                       if(USBHandleBusy(USBGetNextHandle(MSD_DATA_IN_EP, IN_TO_HOST)) == true)
0391  0839     MOVF 0x139, W
0392  0021     MOVLB 0x1
0393  00E1     MOVWF 0xE1
0394  0861     MOVF 0xE1, W
0395  1903     BTFSC STATUS, 0x2
0396  2B9F     GOTO 0x39F
0397  0022     MOVLB 0x2
0398  0839     MOVF 0x139, W
0399  0021     MOVLB 0x1
039A  00E2     MOVWF 0xE2
039B  0086     MOVWF FSR1L
039C  0187     CLRF FSR1H
039D  1B81     BTFSC INDF1, 0x7
039E  0008     RETURN
511:                       {
512:                           break;  //Not available yet.  Just stay in this state and try again later.
513:                       }
514:                       
515:                       //Send the Command Status Wrapper (CSW) packet            
516:                       USBMSDInHandle = USBTxOnePacket(MSD_DATA_IN_EP,(uint8_t*)&msd_csw,MSD_CSW_SIZE);
039F  3060     MOVLW 0x60
03A0  01F0     CLRF 0xF0
03A1  0AF0     INCF 0xF0, F
03A2  00F1     MOVWF 0xF1
03A3  3001     MOVLW 0x1
03A4  00F2     MOVWF 0xF2
03A5  300D     MOVLW 0xD
03A6  00F3     MOVWF 0xF3
03A7  3001     MOVLW 0x1
03A8  2427     CALL 0x427
03A9  3180     MOVLP 0x0
03AA  0021     MOVLB 0x1
03AB  00E5     MOVWF USBMSDInHandle
517:                       //If the bulk OUT endpoint isn't already armed, make sure to do so 
518:                       //now so we can receive the next CBW packet from the host.
519:                       if(!USBHandleBusy(USBMSDOutHandle))
03AC  086D     MOVF USBMSDOutHandle, W
03AD  1903     BTFSC STATUS, 0x2
03AE  2BB4     GOTO 0x3B4
03AF  086D     MOVF USBMSDOutHandle, W
03B0  0086     MOVWF FSR1L
03B1  0187     CLRF FSR1H
03B2  1B81     BTFSC INDF1, 0x7
03B3  2BB9     GOTO 0x3B9
520:                       {
521:                           USBMSDOutHandle = USBRxOnePacket(MSD_DATA_OUT_EP,(uint8_t*)&msd_cbw,MSD_OUT_EP_SIZE);
03B4  2598     CALL 0x598
03B5  3180     MOVLP 0x0
03B6  2427     CALL 0x427
03B7  0021     MOVLB 0x1
03B8  00ED     MOVWF USBMSDOutHandle
522:                       }
523:                       MSD_State=MSD_WAIT;
03B9  0022     MOVLB 0x2
03BA  01CD     CLRF MSD_State
524:                       break;
03BB  0008     RETURN
525:                   default:
526:                       //Illegal condition that should not happen, but might occur if the
527:                       //device firmware incorrectly calls MSDTasks() prior to calling
528:                       //USBMSDInit() during the set-configuration portion of enumeration.
529:                       MSD_State=MSD_WAIT;
03BD  01CD     CLRF MSD_State
530:                       msd_csw.bCSWStatus = MSD_CSW_PHASE_ERROR;
03BC  3002     MOVLW 0x2
03BE  00EC     MOVWF 0x16C
531:                       USBStallEndpoint(MSD_DATA_OUT_EP, OUT_FROM_HOST);
03BF  3001     MOVLW 0x1
03C0  01F0     CLRF 0x170
03C1  2A6B     GOTO 0x26B
532:               }//switch(MSD_State)
533:               
534:               //Safe to re-enable USB interrupts now.
535:               USBUnmaskInterrupts();
536:               
537:               return MSD_State;
538:           }
02E0  0008     RETURN
02E1  0021     MOVLB 0x1
02E2  086D     MOVF USBMSDOutHandle, W
02E3  1903     BTFSC STATUS, 0x2
02E4  2AEA     GOTO 0x2EA
02E5  086D     MOVF USBMSDOutHandle, W
02E6  0086     MOVWF FSR1L
02E7  0187     CLRF FSR1H
02E8  1B81     BTFSC INDF1, 0x7
02E9  0008     RETURN
02EA  01E3     CLRF i
02EB  0863     MOVF i, W
02EC  3EA0     ADDLW 0xA0
02ED  0086     MOVWF FSR1L
02EE  3001     MOVLW 0x1
02EF  0087     MOVWF FSR1H
02F0  0863     MOVF i, W
02F1  3E24     ADDLW 0x24
02F2  0084     MOVWF FSR0L
02F3  3002     MOVLW 0x2
02F4  0085     MOVWF FSR0H
02F5  0800     MOVF INDF0, W
02F6  0081     MOVWF INDF1
02F7  301F     MOVLW 0x1F
02F8  0AE3     INCF i, F
02F9  0263     SUBWF i, W
02FA  1C03     BTFSS STATUS, 0x0
02FB  2AEB     GOTO 0x2EB
02FC  0A6D     INCF USBMSDOutHandle, W
02FD  0086     MOVWF FSR1L
02FE  301F     MOVLW 0x1F
02FF  0187     CLRF FSR1H
0300  0601     XORWF INDF1, W
0301  1D03     BTFSS STATUS, 0x2
0302  2B6C     GOTO 0x36C
0303  3055     MOVLW 0x55
0304  0023     MOVLB 0x3
0305  0620     XORWF gblCBW, W
0306  3053     MOVLW 0x53
0307  1903     BTFSC STATUS, 0x2
0308  0621     XORWF 0x1A1, W
0309  3042     MOVLW 0x42
030A  1903     BTFSC STATUS, 0x2
030B  0622     XORWF 0x1A2, W
030C  3043     MOVLW 0x43
030D  1903     BTFSC STATUS, 0x2
030E  0623     XORWF 0x1A3, W
030F  1D03     BTFSS STATUS, 0x2
0310  2B6C     GOTO 0x36C
0311  0022     MOVLB 0x2
0312  01DF     CLRF MSDCBWValid
0313  0ADF     INCF MSDCBWValid, F
0314  0023     MOVLB 0x3
0315  082D     MOVF 0x1AD, W
0316  1D03     BTFSS STATUS, 0x2
0317  2B64     GOTO 0x364
0318  3011     MOVLW 0x11
0319  022E     SUBWF 0x1AE, W
031A  1803     BTFSC STATUS, 0x0
031B  2B64     GOTO 0x364
031C  082E     MOVF 0x1AE, W
031D  1903     BTFSC STATUS, 0x2
031E  2B64     GOTO 0x364
031F  082C     MOVF 0x1AC, W
0320  393F     ANDLW 0x3F
0321  1D03     BTFSS STATUS, 0x2
0322  2B64     GOTO 0x364
0323  3053     MOVLW 0x53
0324  0022     MOVLB 0x2
0325  00E3     MOVWF 0x163
0326  3042     MOVLW 0x42
0327  00E2     MOVWF 0x162
0328  3053     MOVLW 0x53
0329  00E1     MOVWF 0x161
032A  3055     MOVLW 0x55
032B  00E0     MOVWF msd_csw
032C  3004     MOVLW 0x4
032D  318F     MOVLP 0xF
032E  27DC     CALL 0x7DC
032F  3180     MOVLP 0x0
0330  00E4     MOVWF 0x164
0331  3F41     MOVIW 1[FSR1]
0332  00E5     MOVWF 0x165
0333  3F42     MOVIW 2[FSR1]
0334  00E6     MOVWF 0x166
0335  3F43     MOVIW 3[FSR1]
0336  00E7     MOVWF 0x167
0337  01E8     CLRF 0x168
0338  01E9     CLRF 0x169
0339  01EA     CLRF 0x16A
033A  01EB     CLRF 0x16B
033B  01EC     CLRF 0x16C
033C  30FF     MOVLW 0xFF
033D  0021     MOVLB 0x1
033E  00E6     MOVWF MSDCommandState
033F  0022     MOVLB 0x2
0340  3003     MOVLW 0x3
0341  01CC     CLRF MSDReadState
0342  01CB     CLRF MSDWriteState
0343  0023     MOVLB 0x3
0344  062F     XORWF 0x1AF, W
0345  1903     BTFSC STATUS, 0x2
0346  2B4B     GOTO 0x34B
0347  30F0     MOVLW 0xF0
0348  05C1     ANDWF 0x1C1, F
0349  01CB     CLRF 0x1CB
034A  01CC     CLRF 0x1CC
034B  1FAC     BTFSS 0x1AC, 0x7
034C  2B51     GOTO 0x351
034D  0022     MOVLB 0x2
034E  01CD     CLRF MSD_State
034F  0ACD     INCF MSD_State, F
0350  2B54     GOTO 0x354
0351  3002     MOVLW 0x2
0352  0022     MOVLB 0x2
0353  00CD     MOVWF MSD_State
0354  318F     MOVLP 0xF
0355  27C4     CALL 0x7C4
0356  3180     MOVLP 0x0
0357  1903     BTFSC STATUS, 0x2
0358  2B5C     GOTO 0x35C
0359  0022     MOVLB 0x2
035A  01C8     CLRF MSDHostNoData
035B  2B5F     GOTO 0x35F
035C  0022     MOVLB 0x2
035D  01C8     CLRF MSDHostNoData
035E  0AC8     INCF MSDHostNoData, F
035F  0023     MOVLB 0x3
0360  082F     MOVF 0x1AF, W
0361  0021     MOVLB 0x1
0362  00E6     MOVWF MSDCommandState
0363  0008     RETURN
0364  3001     MOVLW 0x1
0365  01F0     CLRF 0xF0
0366  0AF0     INCF 0xF0, F
0367  226B     CALL 0x26B
0368  3180     MOVLP 0x0
0369  3001     MOVLW 0x1
036A  01F0     CLRF 0xF0
036B  2A6B     GOTO 0x26B
036C  3001     MOVLW 0x1
036D  01F0     CLRF 0xF0
036E  0AF0     INCF 0xF0, F
036F  226B     CALL 0x26B
0370  3180     MOVLP 0x0
0371  3001     MOVLW 0x1
0372  01F0     CLRF 0xF0
0373  226B     CALL 0x26B
0374  0022     MOVLB 0x2
0375  01DF     CLRF MSDCBWValid
0376  0008     RETURN
0377  23C2     CALL 0x3C2
0378  3180     MOVLP 0x0
0379  3AFF     XORLW 0xFF
037A  1D03     BTFSS STATUS, 0x2
037B  0008     RETURN
037C  3003     MOVLW 0x3
037D  0022     MOVLB 0x2
037E  00CD     MOVWF MSD_State
037F  0008     RETURN
0380  23C2     CALL 0x3C2
0381  3180     MOVLP 0x0
0382  3AFF     XORLW 0xFF
0383  1D03     BTFSS STATUS, 0x2
0384  0008     RETURN
0385  0022     MOVLB 0x2
0386  086C     MOVF 0x16C, W
0387  1D03     BTFSS STATUS, 0x2
0388  2B7C     GOTO 0x37C
0389  318F     MOVLP 0xF
038A  27E8     CALL 0x7E8
038B  3180     MOVLP 0x0
038C  1903     BTFSC STATUS, 0x2
038D  2B7C     GOTO 0x37C
038E  3002     MOVLW 0x2
038F  00EC     MOVWF 0x16C
0390  2B7C     GOTO 0x37C
0391  0839     MOVF 0x139, W
0392  0021     MOVLB 0x1
0393  00E1     MOVWF 0xE1
0394  0861     MOVF 0xE1, W
0395  1903     BTFSC STATUS, 0x2
0396  2B9F     GOTO 0x39F
0397  0022     MOVLB 0x2
0398  0839     MOVF 0x139, W
0399  0021     MOVLB 0x1
039A  00E2     MOVWF 0xE2
039B  0086     MOVWF FSR1L
039C  0187     CLRF FSR1H
039D  1B81     BTFSC INDF1, 0x7
039E  0008     RETURN
039F  3060     MOVLW 0x60
03A0  01F0     CLRF 0xF0
03A1  0AF0     INCF 0xF0, F
03A2  00F1     MOVWF 0xF1
03A3  3001     MOVLW 0x1
03A4  00F2     MOVWF 0xF2
03A5  300D     MOVLW 0xD
03A6  00F3     MOVWF 0xF3
03A7  3001     MOVLW 0x1
03A8  2427     CALL 0x427
03A9  3180     MOVLP 0x0
03AA  0021     MOVLB 0x1
03AB  00E5     MOVWF USBMSDInHandle
03AC  086D     MOVF USBMSDOutHandle, W
03AD  1903     BTFSC STATUS, 0x2
03AE  2BB4     GOTO 0x3B4
03AF  086D     MOVF USBMSDOutHandle, W
03B0  0086     MOVWF FSR1L
03B1  0187     CLRF FSR1H
03B2  1B81     BTFSC INDF1, 0x7
03B3  2BB9     GOTO 0x3B9
03B4  2598     CALL 0x598
03B5  3180     MOVLP 0x0
03B6  2427     CALL 0x427
03B7  0021     MOVLB 0x1
03B8  00ED     MOVWF USBMSDOutHandle
03B9  0022     MOVLB 0x2
03BA  01CD     CLRF MSD_State
03BB  0008     RETURN
03BC  3002     MOVLW 0x2
03BD  01CD     CLRF MSD_State
03BE  00EC     MOVWF 0x16C
03BF  3001     MOVLW 0x1
03C0  01F0     CLRF 0x170
03C1  2A6B     GOTO 0x26B
539:           
540:           
541:           /******************************************************************************
542:            	Function:
543:            		uint8_t MSDProcessCommand(void)
544:            		
545:            	Description:
546:            		This function processes a command received through the MSD
547:            		class driver
548:            		
549:            	PreCondition:
550:            		None
551:            		
552:            	Parameters:
553:            		None
554:            		
555:            	Return Values:
556:            		uint8_t - the current state of the MSDProcessCommand state
557:            		machine.  The valid values are defined in MSD.h under the
558:            		MSDProcessCommand state machine declaration section
559:            		
560:            	Remarks:
561:            		None
562:            
563:            *****************************************************************************/	
564:           uint8_t MSDProcessCommand(void)
565:           {   
566:               //Check if the media is either not present, or has been flagged by firmware
567:               //to pretend to be non-present (ex: SoftDetached).
568:               if((LUNMediaDetect() == false) || (SoftDetach[gblCBW.bCBWLUN] == true))
03C2  0023     MOVLB 0x3
03C3  086A     MOVF 0x1EA, W
03C4  00F0     MOVWF 0x1F0
03C5  3006     MOVLW 0x6
03C6  318F     MOVLP 0xF
03C7  278C     CALL 0x78C
03C8  3180     MOVLP 0x0
03C9  008A     MOVWF PCLATH
03CA  3F40     MOVIW 0[FSR1]
03CB  000A     CALLW
03CC  3183     MOVLP 0x3
03CD  3A00     XORLW 0x0
03CE  1903     BTFSC STATUS, 0x2
03CF  2BD7     GOTO 0x3D7
03D0  082D     MOVF 0x1AD, W
03D1  3E49     ADDLW 0x49
03D2  0086     MOVWF FSR1L
03D3  3001     MOVLW 0x1
03D4  0087     MOVWF FSR1H
03D5  0B01     DECFSZ INDF1, W
03D6  2BEA     GOTO 0x3EA
569:               {
570:                   //Clear flag so we know the media need initialization, if it becomes 
571:                   //present in the future.
572:                   gblMediaPresent &= ~((uint16_t)1<<gblCBW.bCBWLUN);
03D7  25A0     CALL 0x5A0
03D8  3180     MOVLP 0x0
03D9  2BDC     GOTO 0x3DC
03DA  35DD     LSLF 0x1DD, F
03DB  0DDE     RLF 0x1DE, F
03DC  0B89     DECFSZ WREG, F
03DD  2BDA     GOTO 0x3DA
03DE  09DD     COMF 0x1DD, F
03DF  09DE     COMF 0x1DE, F
03E0  085D     MOVF 0x1DD, W
03E1  0022     MOVLB 0x2
03E2  05C2     ANDWF gblMediaPresent, F
03E3  0021     MOVLB 0x1
03E4  085E     MOVF 0xDE, W
03E5  0022     MOVLB 0x2
03E6  05C3     ANDWF 0x143, F
573:                   MSDProcessCommandMediaAbsent();
03E7  2462     CALL 0x462
03E8  3180     MOVLP 0x0
574:              	}
03E9  2C24     GOTO 0x424
575:               else
576:               {
577:                   //Check if the media is present and hasn't been already flagged as initialized.
578:                   if((gblMediaPresent & ((uint16_t)1<<gblCBW.bCBWLUN)) == 0)
03EA  25A0     CALL 0x5A0
03EB  3180     MOVLP 0x0
03EC  2BEF     GOTO 0x3EF
03ED  35DD     LSLF state, F
03EE  0DDE     RLF 0x15E, F
03EF  0B89     DECFSZ WREG, F
03F0  2BED     GOTO 0x3ED
03F1  0022     MOVLB 0x2
03F2  0842     MOVF gblMediaPresent, W
03F3  0021     MOVLB 0x1
03F4  055D     ANDWF 0xDD, W
03F5  00DF     MOVWF 0xDF
03F6  0022     MOVLB 0x2
03F7  0843     MOVF 0x143, W
03F8  0021     MOVLB 0x1
03F9  055E     ANDWF 0xDE, W
03FA  00E0     MOVWF 0xE0
03FB  085F     MOVF 0xDF, W
03FC  0460     IORWF 0xE0, W
03FD  1D03     BTFSS STATUS, 0x2
03FE  2C22     GOTO 0x422
579:                   {
580:                       //Try to initialize the media
581:                       if(LUNMediaInitialize())
03FF  0023     MOVLB 0x3
0400  086A     MOVF 0x1EA, W
0401  00F0     MOVWF 0x1F0
0402  085D     MOVF 0x1DD, W
0403  008A     MOVWF PCLATH
0404  085C     MOVF LUN, W
0405  000A     CALLW
0406  3184     MOVLP 0x4
0407  3A00     XORLW 0x0
0408  1903     BTFSC STATUS, 0x2
0409  2BE7     GOTO 0x3E7
040A  25A0     CALL 0x5A0
040B  3180     MOVLP 0x0
582:                       {
583:                           //The media initialized successfully.  Set flag letting software
584:                           //know that it doesn't need re-initialization again (unless the 
585:                           //media is removable and is subsequently removed and re-inserted). 
586:                           gblMediaPresent |= ((uint16_t)1<<gblCBW.bCBWLUN);
040C  2C0F     GOTO 0x40F
040D  35DD     LSLF 0x1DD, F
040E  0DDE     RLF 0x1DE, F
040F  0B89     DECFSZ WREG, F
0410  2C0D     GOTO 0x40D
0411  085D     MOVF 0x1DD, W
0412  0022     MOVLB 0x2
0413  04C2     IORWF gblMediaPresent, F
0414  0021     MOVLB 0x1
0415  085E     MOVF 0xDE, W
0416  0022     MOVLB 0x2
0417  04C3     IORWF 0x143, F
587:           
588:                           //The media is present and has initialized successfully.  However,
589:                           //we should still notify the host that the media may have changed,
590:                           //from the host's perspective, since we just initialized it for 
591:                           //the first time.         
592:                           gblSenseData[LUN_INDEX].SenseKey = S_UNIT_ATTENTION;
0418  0023     MOVLB 0x3
0419  0841     MOVF 0x1C1, W
041A  39F0     ANDLW 0xF0
041B  3806     IORLW 0x6
041C  00C1     MOVWF 0x1C1
593:                           gblSenseData[LUN_INDEX].ASC = ASC_NOT_READY_TO_READY_CHANGE;
041D  3028     MOVLW 0x28
041E  00CB     MOVWF 0x1CB
594:                           gblSenseData[LUN_INDEX].ASCQ = ASCQ_MEDIUM_MAY_HAVE_CHANGED;
595:                           //Signify a soft error to the host, so it knows to check the 
596:                           //sense keys to learn that the media just changed.
597:                           msd_csw.bCSWStatus = MSD_CSW_COMMAND_FAILED; //No real "error" per se has occurred
041F  318F     MOVLP 0xF
0420  27F7     CALL 0x7F7
0421  3180     MOVLP 0x0
598:                           //Process the command now.
599:                           MSDProcessCommandMediaPresent();
0422  318B     MOVLP 0xB
0423  235D     CALL 0x35D
600:                       }
601:                       else
602:                       {
603:                           //The media failed to initialize for some reason.
604:                           MSDProcessCommandMediaAbsent();
605:                       }
606:                   }
607:                   else
608:                   {
609:                       //The media was present and was already initialized/ready to process
610:                       //the host's command.
611:                       MSDProcessCommandMediaPresent();
612:                   }
613:               }
614:           
615:               return MSDCommandState;
0424  0021     MOVLB 0x1
0425  0866     MOVF MSDCommandState, W
616:           }
0426  0008     RETURN
617:           
618:           /******************************************************************************
619:            	Function:
620:            		void MSDProcessCommandMediaAbsent(void)
621:            		
622:            	Description:
623:            		This funtion processes a command received through the MSD
624:            		class driver, when the removable MSD media (ex: MMC/SD card) is not 
625:            		present, or has been "soft detached" deliberately by the application
626:            		firmware.
627:            		
628:            	PreCondition:
629:            		The MSD function should have already been initialized (the media isn't
630:            		required to be initialized however).  Additionally, a valid MSD Command 
631:            		Block Wrapper (CBW) should have been received and partially parsed 
632:            		prior to calling this function.
633:            		
634:            	Parameters:
635:            		None
636:            	
637:            	Return Values:
638:            		uint8_t - the current state of the MSDProcessCommand state
639:            		machine.  The valid values are defined in usb_device_msd.h under the 
640:            		MSDProcessCommand state machine declaration section
641:            		
642:            	Remarks:
643:            		None
644:            
645:             *****************************************************************************/	
646:           void MSDProcessCommandMediaAbsent(void)
647:           {
648:               //Check what command we are currently processing, to decide how to handle it.
649:               switch(MSDCommandState)
0462  0021     MOVLB 0x1
0463  0866     MOVF MSDCommandState, W
0464  3A00     XORLW 0x0
0465  1903     BTFSC STATUS, 0x2
0466  2C7F     GOTO 0x47F
0467  3A03     XORLW 0x3
0468  1903     BTFSC STATUS, 0x2
0469  2C75     GOTO 0x475
046A  3A11     XORLW 0x11
046B  1903     BTFSC STATUS, 0x2
046C  2C7D     GOTO 0x47D
046D  3A0C     XORLW 0xC
046E  1903     BTFSC STATUS, 0x2
046F  2C7F     GOTO 0x47F
0470  3AE3     XORLW 0xE3
0471  1903     BTFSC STATUS, 0x2
0472  2C7D     GOTO 0x47D
0473  2C84     GOTO 0x484
650:               {
651:                   case MSD_REQUEST_SENSE:
652:                       //The host sends this request when it wants to check the status of 
653:                       //the device, and/or identify the reason for the last error that was 
654:                       //reported by the device.
655:                       //Set the sense keys to let the host know that the reason the last
656:                       //command failed was because the media was not present.
657:                       ResetSenseData();
0475  253D     CALL 0x53D
658:                       gblSenseData[LUN_INDEX].SenseKey=S_NOT_READY;
0476  0841     MOVF sector_addr, W
0477  39F0     ANDLW 0xF0
0478  3802     IORLW 0x2
0479  00C1     MOVWF sector_addr
659:                       gblSenseData[LUN_INDEX].ASC=ASC_MEDIUM_NOT_PRESENT;
047A  303A     MOVLW 0x3A
047B  00CB     MOVWF 0xCB
660:                       gblSenseData[LUN_INDEX].ASCQ=ASCQ_MEDIUM_NOT_PRESENT;
047C  01CC     CLRF 0xCC
661:           
662:                       //After initializing the sense keys above, the subsequent handling 
663:                       //code for this state is the same with or without media.
664:                       //Therefore, to save code size, we just call the media present handler.
665:                       MSDProcessCommandMediaPresent();
047D  318B     MOVLP 0xB
047E  2B5D     GOTO 0x35D
666:                       break;
667:           
668:                   case MSD_PREVENT_ALLOW_MEDIUM_REMOVAL:
669:                   case MSD_TEST_UNIT_READY:
670:                       //The host will typically periodically poll the device by sending this
671:                       //request.  Since this is a removable media device, and the media isn't
672:                       //present, we need to indicate an error to let the host know (to 
673:                       //check the sense keys, which will tell it the media isn't present).
674:                       msd_csw.bCSWStatus = MSD_CSW_COMMAND_FAILED;
047F  3001     MOVLW 0x1
0480  0022     MOVLB 0x2
0481  00EC     MOVWF 0x16C
675:                       MSDCommandState = MSD_COMMAND_WAIT;
0482  318F     MOVLP 0xF
0483  2FFC     GOTO 0x7FC
676:                       break;
677:           
678:                   case MSD_INQUIRY:
679:                       //The handling code for this state is the same with or without media.
680:                       //Therefore, to save code size, we just call the media present handler.
681:                       MSDProcessCommandMediaPresent();
682:                       break;
683:           
684:                   case MSD_COMMAND_RESPONSE:
685:                       //The handling code for this state is the same with or without media.
686:                       //Therefore, to save code size, we just call the media present handler.
687:                       MSDProcessCommandMediaPresent();
688:                       break;
689:           
690:                   default:
691:                       //An unsupported command was received.  Since we are uncertain how
692:                       //many bytes we should send/or receive, we should set sense key data
693:                       //and then STALL, to force the host to perform error recovery.
694:                       MSDErrorHandler(MSD_ERROR_UNSUPPORTED_COMMAND);
0484  307F     MOVLW 0x7F
695:                       break;
696:               }
697:           }//void MSDProcessCommandMediaAbsent(void)
0474  0008     RETURN
0475  253D     CALL 0x53D
0476  0841     MOVF 0x141, W
0477  39F0     ANDLW 0xF0
0478  3802     IORLW 0x2
0479  00C1     MOVWF 0x141
047A  303A     MOVLW 0x3A
047B  00CB     MOVWF MSDWriteState
047C  01CC     CLRF MSDReadState
047D  318B     MOVLP 0xB
047E  2B5D     GOTO 0x35D
047F  3001     MOVLW 0x1
0480  0022     MOVLB 0x2
0481  00EC     MOVWF 0x16C
0482  318F     MOVLP 0xF
0483  2FFC     GOTO 0x7FC
0484  307F     MOVLW 0x7F
0485  318D     MOVLP 0xD
0486  2D12     GOTO 0x512
698:           
699:           
700:           /******************************************************************************
701:            	Function:
702:            		void MSDProcessCommandMediaPresent(void)
703:            		
704:            	Description:
705:            		This function processes a command received through the MSD
706:            		class driver
707:            		
708:            	PreCondition:
709:            		None
710:            		
711:            	Parameters:
712:            		None
713:            	
714:            	Return Values:
715:            		uint8_t - the current state of the MSDProcessCommand state
716:            		machine.  The valid values are defined in MSD.h under the 
717:            		MSDProcessCommand state machine declaration section
718:            		
719:            	Remarks:
720:            		None
721:            
722:            *****************************************************************************/	
723:           void MSDProcessCommandMediaPresent(void)
724:           {
725:               uint8_t i; 
726:               uint8_t NumBytesInPacket;
727:           
728:               //Check what command we are currently processing, to decide how to handle it.
729:               switch(MSDCommandState)
0B5D  0021     MOVLB 0x1
0B5E  0866     MOVF MSDCommandState, W
0B5F  3A00     XORLW 0x0
0B60  1903     BTFSC STATUS, 0x2
0B61  2C47     GOTO 0x447
0B62  3A03     XORLW 0x3
0B63  1903     BTFSC STATUS, 0x2
0B64  2C06     GOTO 0x406
0B65  3A11     XORLW 0x11
0B66  1903     BTFSC STATUS, 0x2
0B67  2B8E     GOTO 0x38E
0B68  3A08     XORLW 0x8
0B69  1903     BTFSC STATUS, 0x2
0B6A  2C22     GOTO 0x422
0B6B  3A01     XORLW 0x1
0B6C  1903     BTFSC STATUS, 0x2
0B6D  2C44     GOTO 0x444
0B6E  3A05     XORLW 0x5
0B6F  1903     BTFSC STATUS, 0x2
0B70  2C3F     GOTO 0x43F
0B71  3A3B     XORLW 0x3B
0B72  1903     BTFSC STATUS, 0x2
0B73  2BBF     GOTO 0x3BF
0B74  3A0D     XORLW 0xD
0B75  1903     BTFSC STATUS, 0x2
0B76  2B85     GOTO 0x385
0B77  3A02     XORLW 0x2
0B78  1903     BTFSC STATUS, 0x2
0B79  2B8B     GOTO 0x38B
0B7A  3A05     XORLW 0x5
0B7B  1903     BTFSC STATUS, 0x2
0B7C  2C44     GOTO 0x444
0B7D  3AD2     XORLW 0xD2
0B7E  1903     BTFSC STATUS, 0x2
0B7F  2C5E     GOTO 0x45E
0B80  3A03     XORLW 0x3
0B81  1903     BTFSC STATUS, 0x2
0B82  2CC1     GOTO 0x4C1
0B83  2CC1     GOTO 0x4C1
730:               {
731:                   case MSD_READ_10:
732:                       //The host issues a "Read 10" request when it wants to read some number
733:                       //of 10-bit length blocks (512 byte blocks) of data from the media.
734:                       //Since this is a common request and is part of the "critical path"
735:                       //performance wise, we put this at the top of the state machine checks.
736:                       if(MSDReadHandler() == MSD_READ10_WAIT)
0B85  2651     CALL 0x651
0B86  318B     MOVLP 0xB
0B87  3A00     XORLW 0x0
0B88  1D03     BTFSS STATUS, 0x2
0B89  0008     RETURN
737:                       {
738:                           MSDCommandState = MSD_COMMAND_WAIT;
0B8A  2FFC     GOTO 0x7FC
739:                       }
740:                       break;
741:           
742:               	case MSD_WRITE_10:
743:                       //The host issues a "Write 10" request when it wants to write some number
744:                       //of 10-bit length blocks (512 byte blocks) of data to the media.
745:                       //Since this is a common request and is part of the "critical path"
746:                       //performance wise, we put this near the top of the state machine checks.
747:                       if(MSDWriteHandler() == MSD_WRITE10_WAIT)
0B8B  257E     CALL 0x57E
0B8C  318B     MOVLP 0xB
0B8D  2B87     GOTO 0x387
748:                       {
749:                           MSDCommandState = MSD_COMMAND_WAIT;
750:                       }
751:                       break;
752:                       
753:               	case MSD_INQUIRY:
754:               	{
755:                       //The host wants to learn more about our MSD device (spec version,
756:                       //supported abilities, etc.)
757:           
758:                       //Error check: If host doesn't want any data, then just advance to CSW phase.
759:                       if(MSDHostNoData == true)
0B8E  0022     MOVLB 0x2
0B8F  0B48     DECFSZ MSDHostNoData, W
0B90  2B92     GOTO 0x392
0B91  2B8A     GOTO 0x38A
760:                       {
761:                           MSDCommandState = MSD_COMMAND_WAIT;
762:                           break;
763:                       }    
764:                       
765:                       //Get the 16-bit "Allocation Length" (Number of bytes to respond 
766:                       //with.  Note: Value provided in CBWCB is in big endian format)
767:                       TransferLength.byte.HB = gblCBW.CBWCB[3]; //MSB
0B92  0023     MOVLB 0x3
0B93  0832     MOVF 0x1B2, W
0B94  0022     MOVLB 0x2
0B95  00C1     MOVWF 0x141
768:                       TransferLength.byte.LB = gblCBW.CBWCB[4]; //LSB
0B96  0023     MOVLB 0x3
0B97  0833     MOVF 0x1B3, W
0B98  0022     MOVLB 0x2
0B99  00C0     MOVWF TransferLength
769:                   	//Check for possible errors.  
770:                       if(MSDCheckForErrorCases(TransferLength.Val) != MSD_ERROR_CASE_NO_ERROR)
0B9A  00F7     MOVWF 0x177
0B9B  0841     MOVF 0x141, W
0B9C  00F8     MOVWF 0x178
0B9D  01F9     CLRF 0x179
0B9E  01FA     CLRF 0x17A
0B9F  26F0     CALL 0x6F0
0BA0  318B     MOVLP 0xB
0BA1  3A00     XORLW 0x0
0BA2  1D03     BTFSS STATUS, 0x2
0BA3  0008     RETURN
771:                       {
772:                           break;
773:                       }
774:           
775:                     	//Compute and load proper csw residue and device in number of byte.
776:                       MSDComputeDeviceInAndResidue(sizeof(InquiryResponse));
0BA4  3024     MOVLW 0x24
0BA5  00F0     MOVWF 0x170
0BA6  01F1     CLRF 0x171
0BA7  24C3     CALL 0x4C3
0BA8  318B     MOVLP 0xB
777:           
778:                       //If we get to here, this implies no errors were found and the command is legit.
779:           
780:                       //copy the inquiry results from the defined const buffer 
781:                       //  into the USB buffer so that it can be transmitted
782:                       memcpy((void *)&msd_buffer[0], (const void*)&inq_resp, sizeof(InquiryResponse));   //Inquiry response is 36 bytes total
0BA9  30A0     MOVLW 0xA0
0BAA  0086     MOVWF FSR1L
0BAB  3002     MOVLW 0x2
0BAC  0087     MOVWF FSR1H
0BAD  3078     MOVLW 0x78
0BAE  0084     MOVWF FSR0L
0BAF  3090     MOVLW 0x90
0BB0  0085     MOVWF FSR0H
0BB1  3024     MOVLW 0x24
0BB2  0021     MOVLB 0x1
0BB3  00CF     MOVWF 0xCF
0BB4  084F     MOVF 0xCF, W
0BB5  1903     BTFSC STATUS, 0x2
0BB6  2BBB     GOTO 0x3BB
0BB7  0012     MOVIW FSR0++
0BB8  001E     MOVWI FSR1++
0BB9  0BCF     DECFSZ 0xCF, F
0BBA  2BB7     GOTO 0x3B7
783:                       MSDCommandState = MSD_COMMAND_RESPONSE;
0BBB  30FD     MOVLW 0xFD
0BBC  0021     MOVLB 0x1
0BBD  00E6     MOVWF MSDCommandState
784:                       break;
0BBE  0008     RETURN
785:                   }
786:                   case MSD_READ_CAPACITY:
787:                   {
788:                       //The host asked for the total capacity of the device.  The response
789:                       //packet is 8-bytes (32-bits for last LBA implemented, 32-bits for block size).
790:                       USB_MSD_SECTOR_SIZE sectorSize;
791:                       USB_MSD_CAPACITY capacity;
792:           
793:                       //get the information from the physical media
794:                       capacity.Val = LUNReadCapacity();
0BBF  0023     MOVLB 0x3
0BC0  086A     MOVF 0x1EA, W
0BC1  00F0     MOVWF 0x1F0
0BC2  3002     MOVLW 0x2
0BC3  278C     CALL 0x78C
0BC4  008A     MOVWF PCLATH
0BC5  3F40     MOVIW 0[FSR1]
0BC6  000A     CALLW
0BC7  318B     MOVLP 0xB
0BC8  0873     MOVF 0x1F3, W
0BC9  0021     MOVLB 0x1
0BCA  00DB     MOVWF 0xDB
0BCB  0872     MOVF 0xF2, W
0BCC  00DA     MOVWF 0xDA
0BCD  0871     MOVF 0xF1, W
0BCE  00D9     MOVWF 0xD9
0BCF  0870     MOVF 0xF0, W
0BD0  00D8     MOVWF capacity
795:                       sectorSize.Val = LUNReadSectorSize();
0BD1  0023     MOVLB 0x3
0BD2  086A     MOVF 0x1EA, W
0BD3  00F0     MOVWF 0x1F0
0BD4  3004     MOVLW 0x4
0BD5  278C     CALL 0x78C
0BD6  008A     MOVWF PCLATH
0BD7  3F40     MOVIW 0[FSR1]
0BD8  000A     CALLW
0BD9  318B     MOVLP 0xB
0BDA  0870     MOVF 0x1F0, W
0BDB  0021     MOVLB 0x1
0BDC  00D4     MOVWF sectorSize
0BDD  0871     MOVF 0xF1, W
0BDE  00D5     MOVWF 0xD5
0BDF  01D6     CLRF 0xD6
0BE0  01D7     CLRF 0xD7
796:                       
797:                       //Copy the data to the buffer.  Host expects the response in big endian format.
798:                       msd_buffer[0]=capacity.v[3];
0BE1  085B     MOVF 0xDB, W
0BE2  0025     MOVLB 0x5
0BE3  00A0     MOVWF msd_buffer
799:                       msd_buffer[1]=capacity.v[2];
0BE4  0021     MOVLB 0x1
0BE5  085A     MOVF 0xDA, W
0BE6  0025     MOVLB 0x5
0BE7  00A1     MOVWF 0x2A1
800:                       msd_buffer[2]=capacity.v[1];
0BE8  0021     MOVLB 0x1
0BE9  0859     MOVF 0xD9, W
0BEA  0025     MOVLB 0x5
0BEB  00A2     MOVWF 0x2A2
801:                       msd_buffer[3]=capacity.v[0];
0BEC  0021     MOVLB 0x1
0BED  0858     MOVF capacity, W
0BEE  0025     MOVLB 0x5
0BEF  00A3     MOVWF 0x2A3
802:           
803:                       msd_buffer[4]=sectorSize.v[3];
0BF0  0021     MOVLB 0x1
0BF1  0857     MOVF 0xD7, W
0BF2  0025     MOVLB 0x5
0BF3  00A4     MOVWF 0x2A4
804:                       msd_buffer[5]=sectorSize.v[2];
0BF4  0021     MOVLB 0x1
0BF5  0856     MOVF 0xD6, W
0BF6  0025     MOVLB 0x5
0BF7  00A5     MOVWF 0x2A5
805:                       msd_buffer[6]=sectorSize.v[1];
0BF8  0021     MOVLB 0x1
0BF9  0855     MOVF 0xD5, W
0BFA  0025     MOVLB 0x5
0BFB  00A6     MOVWF 0x2A6
806:                       msd_buffer[7]=sectorSize.v[0];
0BFC  0021     MOVLB 0x1
0BFD  0854     MOVF sectorSize, W
0BFE  0025     MOVLB 0x5
0BFF  00A7     MOVWF 0x2A7
807:           
808:                       //Compute and load proper csw residue and device in number of byte.
809:                       TransferLength.Val = 0x08;      //READ_CAPACITY always has an 8-byte response.
0C00  3008     MOVLW 0x8
0C01  27D0     CALL 0x7D0
0C02  318B     MOVLP 0xB
810:                       MSDComputeDeviceInAndResidue(0x08);
0C03  24C3     CALL 0x4C3
0C04  318B     MOVLP 0xB
0C05  2BBB     GOTO 0x3BB
811:                   
812:                       MSDCommandState = MSD_COMMAND_RESPONSE;
813:                       break;
814:                   }
815:                   case MSD_REQUEST_SENSE:    
816:                       //The host normally sends this request after a CSW completed, where
817:                       //the device indicated some kind of error on the previous transfer.
818:                       //In this case, the host will typically issue this request, so it can
819:                       //learn more details about the cause/source of the error condition.
820:                       
821:                       //Error check: if the host doesn't want any data, just advance to CSW phase.
822:                       if(MSDHostNoData == true)
0C06  0022     MOVLB 0x2
0C07  0B48     DECFSZ MSDHostNoData, W
0C08  2C0A     GOTO 0x40A
0C09  2B8A     GOTO 0x38A
823:                       {
824:                           MSDCommandState = MSD_COMMAND_WAIT;
825:                           break;
826:                       }    
827:           
828:                     	//Compute and load proper csw residue and device in number of byte.
829:                       TransferLength.Val = sizeof(RequestSenseResponse);      //REQUEST_SENSE has an 18-byte response.
0C0A  3012     MOVLW 0x12
0C0B  00C0     MOVWF TransferLength
0C0C  01C1     CLRF 0x141
830:                       MSDComputeDeviceInAndResidue(sizeof(RequestSenseResponse));
0C0D  00F0     MOVWF 0x170
0C0E  01F1     CLRF 0x171
0C0F  24C3     CALL 0x4C3
0C10  318B     MOVLP 0xB
831:                        
832:                       //Copy the requested response data from flash to the USB ram buffer.
833:                       for(i=0;i<sizeof(RequestSenseResponse);i++)
0C11  0021     MOVLB 0x1
0C12  01DC     CLRF i
0C1C  3012     MOVLW 0x12
0C1D  0ADC     INCF i, F
0C1E  025C     SUBWF i, W
0C1F  1803     BTFSC STATUS, 0x0
0C20  2BBB     GOTO 0x3BB
0C21  2C13     GOTO 0x413
834:                       {
835:                           msd_buffer[i]=gblSenseData[LUN_INDEX]._byte[i];
0C13  27D6     CALL 0x7D6
0C14  318B     MOVLP 0xB
0C15  085C     MOVF i, W
0C16  3EBF     ADDLW 0xBF
0C17  0084     MOVWF FSR0L
0C18  3001     MOVLW 0x1
0C19  0085     MOVWF FSR0H
0C1A  0800     MOVF INDF0, W
0C1B  0081     MOVWF INDF1
836:                       }
837:                       MSDCommandState = MSD_COMMAND_RESPONSE;
838:                       break;
839:                       
840:                   case MSD_MODE_SENSE:
841:                       msd_buffer[0]=0x03;
0C22  3003     MOVLW 0x3
0C23  0025     MOVLB 0x5
0C24  00A0     MOVWF msd_buffer
842:                       msd_buffer[1]=0x00;
0C25  01A1     CLRF 0x2A1
843:                       msd_buffer[2]=(LUNWriteProtectState()) ? 0x80 : 0x00;
0C26  2782     CALL 0x782
0C27  008A     MOVWF PCLATH
0C28  3F40     MOVIW 0[FSR1]
0C29  000A     CALLW
0C2A  318C     MOVLP 0xC
0C2B  3A00     XORLW 0x0
0C2C  1D03     BTFSS STATUS, 0x2
0C2D  2C31     GOTO 0x431
0C2E  0021     MOVLB 0x1
0C2F  01D1     CLRF 0xD1
0C30  2C34     GOTO 0x434
0C31  3080     MOVLW 0x80
0C32  0021     MOVLB 0x1
0C33  00D1     MOVWF 0xD1
0C34  01D2     CLRF 0xD2
0C35  0851     MOVF 0xD1, W
0C36  0025     MOVLB 0x5
0C37  00A2     MOVWF 0x2A2
844:                       msd_buffer[3]= 0x00;
0C38  01A3     CLRF 0x2A3
845:           
846:                       //Compute and load proper csw residue and device in number of byte.
847:                       TransferLength.Val = 0x04;
0C39  3004     MOVLW 0x4
0C3A  27D0     CALL 0x7D0
0C3B  318B     MOVLP 0xB
848:                       MSDComputeDeviceInAndResidue(0x04);
0C3C  24C3     CALL 0x4C3
0C3D  318B     MOVLP 0xB
0C3E  2BBB     GOTO 0x3BB
849:                       MSDCommandState = MSD_COMMAND_RESPONSE;
850:               	    break;
851:           
852:                   case MSD_PREVENT_ALLOW_MEDIUM_REMOVAL:
853:                       gblSenseData[LUN_INDEX].SenseKey=S_ILLEGAL_REQUEST;
0C3F  0023     MOVLB 0x3
0C40  27AB     CALL 0x7AB
0C41  318B     MOVLP 0xB
0C42  27F7     CALL 0x7F7
0C43  318B     MOVLP 0xB
854:                       gblSenseData[LUN_INDEX].ASC=ASC_INVALID_COMMAND_OPCODE;
855:                       gblSenseData[LUN_INDEX].ASCQ=ASCQ_INVALID_COMMAND_OPCODE;
856:                       msd_csw.bCSWStatus = MSD_CSW_COMMAND_FAILED;
857:                       msd_csw.dCSWDataResidue = 0x00;
0C44  27CA     CALL 0x7CA
0C45  318B     MOVLP 0xB
0C46  2B8A     GOTO 0x38A
858:                       MSDCommandState = MSD_COMMAND_WAIT;
859:                       break;
860:           
861:                   case MSD_TEST_UNIT_READY:
862:                       //The host will typically send this command periodically to check if
863:                       //it is ready to be used and to obtain polled notification of changes
864:                       //in status (ex: user removed media from a removable media MSD volume).
865:                       //There is no data stage for this request.  The information we send to
866:                       //the host in response to this request is entirely contained in the CSW.
867:                       
868:                       //First check for possible errors.
869:                       if(MSDCheckForErrorCases(0) != MSD_ERROR_CASE_NO_ERROR)
0C47  01F7     CLRF 0x1F7
0C48  01F8     CLRF 0x1F8
0C49  01F9     CLRF 0x1F9
0C4A  01FA     CLRF 0x1FA
0C4B  26F0     CALL 0x6F0
0C4C  318B     MOVLP 0xB
0C4D  3A00     XORLW 0x0
0C4E  1D03     BTFSS STATUS, 0x2
0C4F  0008     RETURN
870:                       {
871:                           break;
872:                       }    
873:                       //The stack sets this condition when the status of the removable media
874:                       //has just changed (ex: the user just plugged in the removable media,
875:                       //in which case we want to notify the host of the changed status, by
876:                       //sending a deliberate "error" notification).  This doesn't mean any 
877:                       //real error has occurred.
878:                       if((gblSenseData[LUN_INDEX].SenseKey==S_UNIT_ATTENTION) && (msd_csw.bCSWStatus==MSD_CSW_COMMAND_FAILED))
0C50  0023     MOVLB 0x3
0C51  0841     MOVF 0x1C1, W
0C52  390F     ANDLW 0xF
0C53  3A06     XORLW 0x6
0C54  1D03     BTFSS STATUS, 0x2
0C55  2C5A     GOTO 0x45A
0C56  0022     MOVLB 0x2
0C57  0B6C     DECFSZ 0x16C, W
0C58  2C5A     GOTO 0x45A
0C59  2B8A     GOTO 0x38A
879:                       {
880:                           MSDCommandState = MSD_COMMAND_WAIT;
881:                       }
882:                       else
883:                       {
884:                       	ResetSenseData();
0C5A  3185     MOVLP 0x5
0C5B  253D     CALL 0x53D
0C5C  318B     MOVLP 0xB
0C5D  2C44     GOTO 0x444
885:                       	msd_csw.dCSWDataResidue=0x00;
886:                           MSDCommandState = MSD_COMMAND_WAIT;
887:                       }
888:                       break;
889:           
890:                   case MSD_VERIFY:
891:                   //Fall through to STOP_START
892:                       
893:                   case MSD_STOP_START:
894:                       msd_csw.dCSWDataResidue=0x00;
895:                       MSDCommandState = MSD_COMMAND_WAIT;
896:                       break;
897:                       
898:                   case MSD_COMMAND_RESPONSE:
899:                       //This command state didn't originate from the host.  This state was
900:                       //set by the firmware (for one of the other handlers) when it was 
901:                       //finished preparing the data to send to the host, and it is now time
902:                       //to transmit the data over the bulk IN endpoint.
903:                       if(USBHandleBusy(USBMSDInHandle) == false)
0C5E  0865     MOVF 0x165, W
0C5F  1903     BTFSC STATUS, 0x2
0C60  2C66     GOTO 0x466
0C61  0865     MOVF 0x165, W
0C62  0086     MOVWF FSR1L
0C63  0187     CLRF FSR1H
0C64  1B81     BTFSC INDF1, 0x7
0C65  0008     RETURN
904:                       {
905:                           //We still have more bytes needing to be sent.  Compute how many 
906:                           //bytes should be in the next IN packet that we send.
907:                           if(gblCBW.dCBWDataTransferLength >= MSD_IN_EP_SIZE)
0C66  0023     MOVLB 0x3
0C67  082B     MOVF 0x1AB, W
0C68  1D03     BTFSS STATUS, 0x2
0C69  2C74     GOTO 0x474
0C6A  082A     MOVF 0x1AA, W
0C6B  1D03     BTFSS STATUS, 0x2
0C6C  2C74     GOTO 0x474
0C6D  0829     MOVF 0x1A9, W
0C6E  3040     MOVLW 0x40
0C6F  1D03     BTFSS STATUS, 0x2
0C70  2C75     GOTO 0x475
0C71  0228     SUBWF 0x1A8, W
0C72  1C03     BTFSS STATUS, 0x0
0C73  2C7A     GOTO 0x47A
908:                           {
909:                               NumBytesInPacket = MSD_IN_EP_SIZE;
0C74  3040     MOVLW 0x40
0C75  0021     MOVLB 0x1
0C76  00D3     MOVWF NumBytesInPacket
910:                               gblCBW.dCBWDataTransferLength -= MSD_IN_EP_SIZE;
0C77  27A3     CALL 0x7A3
0C78  318B     MOVLP 0xB
911:                           }   
0C79  2C82     GOTO 0x482
912:                           else
913:                           {
914:                               //This is a short packet and will be our last IN packet sent
915:                               //in the transfer.
916:                               NumBytesInPacket = gblCBW.dCBWDataTransferLength;
0C7A  0828     MOVF i, W
0C7B  0021     MOVLB 0x1
0C7C  00D3     MOVWF NumBytesInPacket
917:                               gblCBW.dCBWDataTransferLength = 0;
0C7D  0023     MOVLB 0x3
0C7E  01A8     CLRF 0x1A8
0C7F  01A9     CLRF 0x1A9
0C80  01AA     CLRF 0x1AA
0C81  01AB     CLRF 0x1AB
918:                           } 
919:                           
920:                           //We still have more bytes needing to be sent.  Check if we have
921:                           //already fulfilled the device input expected quantity of bytes.
922:                           //If so, we need to keep sending IN packets, but pad the extra
923:                           //bytes with value = 0x00 (see error case 5 MSD device BOT v1.0 
924:                           //spec handling).
925:                           if(TransferLength.Val >= NumBytesInPacket)
0C82  0021     MOVLB 0x1
0C83  0853     MOVF NumBytesInPacket, W
0C84  00CF     MOVWF 0xCF
0C85  01D0     CLRF 0xD0
0C86  0850     MOVF 0xD0, W
0C87  0022     MOVLB 0x2
0C88  0241     SUBWF 0x141, W
0C89  1D03     BTFSS STATUS, 0x2
0C8A  2C8F     GOTO 0x48F
0C8B  0021     MOVLB 0x1
0C8C  084F     MOVF 0xCF, W
0C8D  0022     MOVLB 0x2
0C8E  0240     SUBWF TransferLength, W
0C8F  1C03     BTFSS STATUS, 0x0
0C90  2C98     GOTO 0x498
926:                           {
927:                               //No problem, just send the requested data and keep track of remaining count.
928:                               TransferLength.Val -= NumBytesInPacket;
0C91  0021     MOVLB 0x1
0C92  0853     MOVF NumBytesInPacket, W
0C93  0022     MOVLB 0x2
0C94  02C0     SUBWF TransferLength, F
0C95  1C03     BTFSS STATUS, 0x0
0C96  03C1     DECF 0x141, F
929:                           }    
0C97  2CAF     GOTO 0x4AF
930:                           else
931:                           {
932:                               //The host is reading more bytes than the device has to send.
933:                               //In this case, we still need to send the quantity of bytes requested,
934:                               //but we have to fill the pad bytes with 0x00.  The below for loop
935:                               //is execution speed inefficient, but performance isn't important 
936:                               //since this code only executes in the case of a host error 
937:                               //anyway (Hi > Di).
938:                               for(i = 0; i < NumBytesInPacket; i++)
0C98  0021     MOVLB 0x1
0C99  01DC     CLRF i
0C9A  0853     MOVF NumBytesInPacket, W
0C9B  025C     SUBWF i, W
0C9C  1803     BTFSC STATUS, 0x0
0C9D  2CAF     GOTO 0x4AF
0CAC  0021     MOVLB 0x1
0CAD  0ADC     INCF i, F
0CAE  2C9A     GOTO 0x49A
939:                               {
940:                                   if(TransferLength.Val != 0)
0C9E  0022     MOVLB 0x2
0C9F  0840     MOVF TransferLength, W
0CA0  0441     IORWF 0x141, W
0CA1  1903     BTFSC STATUS, 0x2
0CA2  2CA8     GOTO 0x4A8
941:                                   {
942:                                       TransferLength.Val--;     
0CA3  3001     MOVLW 0x1
0CA4  02C0     SUBWF TransferLength, F
0CA5  3000     MOVLW 0x0
0CA6  3BC1     SUBWFB 0x141, F
943:                                   }    
0CA7  2CAC     GOTO 0x4AC
944:                                   else
945:                                   {
946:                                       msd_buffer[i] = 0x00;
0CA8  0021     MOVLB 0x1
0CA9  27D6     CALL 0x7D6
0CAA  318B     MOVLP 0xB
0CAB  0181     CLRF INDF1
947:                                   }    
948:                               }    
949:                           }    
950:                           
951:                           //We are now ready to send the packet to the host.                   
952:                           USBMSDInHandle = USBTxOnePacket(MSD_DATA_IN_EP,(uint8_t*)&msd_buffer[0],NumBytesInPacket);
0CAF  30A0     MOVLW 0xA0
0CB0  01F0     CLRF 0xF0
0CB1  0AF0     INCF 0xF0, F
0CB2  00F1     MOVWF 0xF1
0CB3  3002     MOVLW 0x2
0CB4  00F2     MOVWF 0xF2
0CB5  0021     MOVLB 0x1
0CB6  0853     MOVF NumBytesInPacket, W
0CB7  00F3     MOVWF 0xF3
0CB8  3001     MOVLW 0x1
0CB9  3184     MOVLP 0x4
0CBA  2427     CALL 0x427
0CBB  318B     MOVLP 0xB
0CBC  0021     MOVLB 0x1
0CBD  00E5     MOVWF USBMSDInHandle
0CBE  27C4     CALL 0x7C4
0CBF  318B     MOVLP 0xB
953:                           
954:                           //Check to see if we are done sending all requested bytes of data
955:                           if(gblCBW.dCBWDataTransferLength == 0)
0CC0  2B88     GOTO 0x388
956:                           {
957:                               //We have sent all the requested bytes.  Go ahead and
958:                               //advance state so as to send the CSW.
959:                               MSDCommandState = MSD_COMMAND_WAIT;
960:                               break;                    
961:                           }                    
962:                       }
963:                       break;
964:                   case MSD_COMMAND_ERROR:
965:                       default:
966:                           //An unsupported command was received.  Since we are uncertain how many
967:                           //bytes we should send/or receive, we should set sense key data and then
968:                           //STALL, to force the host to perform error recovery.
969:                           MSDErrorHandler(MSD_ERROR_UNSUPPORTED_COMMAND);
0CC1  307F     MOVLW 0x7F
0CC2  2D12     GOTO 0x512
970:                           break;
971:           	} // end switch	
972:           }//void MSDProcessCommandMediaPresent(void)
0B84  0008     RETURN
0B85  2651     CALL 0x651
0B86  318B     MOVLP 0xB
0B87  3A00     XORLW 0x0
0B88  1D03     BTFSS STATUS, 0x2
0B89  0008     RETURN
0B8A  2FFC     GOTO 0x7FC
0B8B  257E     CALL 0x57E
0B8C  318B     MOVLP 0xB
0B8D  2B87     GOTO 0x387
0B8E  0022     MOVLB 0x2
0B8F  0B48     DECFSZ MSDHostNoData, W
0B90  2B92     GOTO 0x392
0B91  2B8A     GOTO 0x38A
0B92  0023     MOVLB 0x3
0B93  0832     MOVF 0x1B2, W
0B94  0022     MOVLB 0x2
0B95  00C1     MOVWF 0x141
0B96  0023     MOVLB 0x3
0B97  0833     MOVF 0x1B3, W
0B98  0022     MOVLB 0x2
0B99  00C0     MOVWF TransferLength
0B9A  00F7     MOVWF 0x177
0B9B  0841     MOVF 0x141, W
0B9C  00F8     MOVWF 0x178
0B9D  01F9     CLRF 0x179
0B9E  01FA     CLRF 0x17A
0B9F  26F0     CALL 0x6F0
0BA0  318B     MOVLP 0xB
0BA1  3A00     XORLW 0x0
0BA2  1D03     BTFSS STATUS, 0x2
0BA3  0008     RETURN
0BA4  3024     MOVLW 0x24
0BA5  00F0     MOVWF 0x170
0BA6  01F1     CLRF 0x171
0BA7  24C3     CALL 0x4C3
0BA8  318B     MOVLP 0xB
0BA9  30A0     MOVLW 0xA0
0BAA  0086     MOVWF FSR1L
0BAB  3002     MOVLW 0x2
0BAC  0087     MOVWF FSR1H
0BAD  3078     MOVLW 0x78
0BAE  0084     MOVWF FSR0L
0BAF  3090     MOVLW 0x90
0BB0  0085     MOVWF FSR0H
0BB1  3024     MOVLW 0x24
0BB2  0021     MOVLB 0x1
0BB3  00CF     MOVWF 0xCF
0BB4  084F     MOVF 0xCF, W
0BB5  1903     BTFSC STATUS, 0x2
0BB6  2BBB     GOTO 0x3BB
0BB7  0012     MOVIW FSR0++
0BB8  001E     MOVWI FSR1++
0BB9  0BCF     DECFSZ 0xCF, F
0BBA  2BB7     GOTO 0x3B7
0BBB  30FD     MOVLW 0xFD
0BBC  0021     MOVLB 0x1
0BBD  00E6     MOVWF MSDCommandState
0BBE  0008     RETURN
0BBF  0023     MOVLB 0x3
0BC0  086A     MOVF 0x1EA, W
0BC1  00F0     MOVWF 0x1F0
0BC2  3002     MOVLW 0x2
0BC3  278C     CALL 0x78C
0BC4  008A     MOVWF PCLATH
0BC5  3F40     MOVIW 0[FSR1]
0BC6  000A     CALLW
0BC7  318B     MOVLP 0xB
0BC8  0873     MOVF 0x1F3, W
0BC9  0021     MOVLB 0x1
0BCA  00DB     MOVWF 0xDB
0BCB  0872     MOVF 0xF2, W
0BCC  00DA     MOVWF 0xDA
0BCD  0871     MOVF 0xF1, W
0BCE  00D9     MOVWF 0xD9
0BCF  0870     MOVF 0xF0, W
0BD0  00D8     MOVWF capacity
0BD1  0023     MOVLB 0x3
0BD2  086A     MOVF 0x1EA, W
0BD3  00F0     MOVWF 0x1F0
0BD4  3004     MOVLW 0x4
0BD5  278C     CALL 0x78C
0BD6  008A     MOVWF PCLATH
0BD7  3F40     MOVIW 0[FSR1]
0BD8  000A     CALLW
0BD9  318B     MOVLP 0xB
0BDA  0870     MOVF 0x1F0, W
0BDB  0021     MOVLB 0x1
0BDC  00D4     MOVWF sectorSize
0BDD  0871     MOVF 0xF1, W
0BDE  00D5     MOVWF 0xD5
0BDF  01D6     CLRF 0xD6
0BE0  01D7     CLRF 0xD7
0BE1  085B     MOVF 0xDB, W
0BE2  0025     MOVLB 0x5
0BE3  00A0     MOVWF msd_buffer
0BE4  0021     MOVLB 0x1
0BE5  085A     MOVF 0xDA, W
0BE6  0025     MOVLB 0x5
0BE7  00A1     MOVWF 0x2A1
0BE8  0021     MOVLB 0x1
0BE9  0859     MOVF 0xD9, W
0BEA  0025     MOVLB 0x5
0BEB  00A2     MOVWF 0x2A2
0BEC  0021     MOVLB 0x1
0BED  0858     MOVF capacity, W
0BEE  0025     MOVLB 0x5
0BEF  00A3     MOVWF 0x2A3
0BF0  0021     MOVLB 0x1
0BF1  0857     MOVF 0xD7, W
0BF2  0025     MOVLB 0x5
0BF3  00A4     MOVWF 0x2A4
0BF4  0021     MOVLB 0x1
0BF5  0856     MOVF 0xD6, W
0BF6  0025     MOVLB 0x5
0BF7  00A5     MOVWF 0x2A5
0BF8  0021     MOVLB 0x1
0BF9  0855     MOVF 0xD5, W
0BFA  0025     MOVLB 0x5
0BFB  00A6     MOVWF 0x2A6
0BFC  0021     MOVLB 0x1
0BFD  0854     MOVF sectorSize, W
0BFE  0025     MOVLB 0x5
0BFF  00A7     MOVWF 0x2A7
0C00  3008     MOVLW 0x8
0C01  27D0     CALL 0x7D0
0C02  318B     MOVLP 0xB
0C03  24C3     CALL 0x4C3
0C04  318B     MOVLP 0xB
0C05  2BBB     GOTO 0x3BB
0C06  0022     MOVLB 0x2
0C07  0B48     DECFSZ MSDHostNoData, W
0C08  2C0A     GOTO 0x40A
0C09  2B8A     GOTO 0x38A
0C0A  3012     MOVLW 0x12
0C0B  00C0     MOVWF TransferLength
0C0C  01C1     CLRF 0x141
0C0D  00F0     MOVWF 0x170
0C0E  01F1     CLRF 0x171
0C0F  24C3     CALL 0x4C3
0C10  318B     MOVLP 0xB
0C11  0021     MOVLB 0x1
0C12  01DC     CLRF i
0C13  27D6     CALL 0x7D6
0C14  318B     MOVLP 0xB
0C15  085C     MOVF i, W
0C16  3EBF     ADDLW 0xBF
0C17  0084     MOVWF FSR0L
0C18  3001     MOVLW 0x1
0C19  0085     MOVWF FSR0H
0C1A  0800     MOVF INDF0, W
0C1B  0081     MOVWF INDF1
0C1C  3012     MOVLW 0x12
0C1D  0ADC     INCF i, F
0C1E  025C     SUBWF i, W
0C1F  1803     BTFSC STATUS, 0x0
0C20  2BBB     GOTO 0x3BB
0C21  2C13     GOTO 0x413
0C22  3003     MOVLW 0x3
0C23  0025     MOVLB 0x5
0C24  00A0     MOVWF msd_buffer
0C25  01A1     CLRF 0x2A1
0C26  2782     CALL 0x782
0C27  008A     MOVWF PCLATH
0C28  3F40     MOVIW 0[FSR1]
0C29  000A     CALLW
0C2A  318C     MOVLP 0xC
0C2B  3A00     XORLW 0x0
0C2C  1D03     BTFSS STATUS, 0x2
0C2D  2C31     GOTO 0x431
0C2E  0021     MOVLB 0x1
0C2F  01D1     CLRF 0xD1
0C30  2C34     GOTO 0x434
0C31  3080     MOVLW 0x80
0C32  0021     MOVLB 0x1
0C33  00D1     MOVWF 0xD1
0C34  01D2     CLRF 0xD2
0C35  0851     MOVF 0xD1, W
0C36  0025     MOVLB 0x5
0C37  00A2     MOVWF 0x2A2
0C38  01A3     CLRF 0x2A3
0C39  3004     MOVLW 0x4
0C3A  27D0     CALL 0x7D0
0C3B  318B     MOVLP 0xB
0C3C  24C3     CALL 0x4C3
0C3D  318B     MOVLP 0xB
0C3E  2BBB     GOTO 0x3BB
0C3F  0023     MOVLB 0x3
0C40  27AB     CALL 0x7AB
0C41  318B     MOVLP 0xB
0C42  27F7     CALL 0x7F7
0C43  318B     MOVLP 0xB
0C44  27CA     CALL 0x7CA
0C45  318B     MOVLP 0xB
0C46  2B8A     GOTO 0x38A
0C47  01F7     CLRF 0x1F7
0C48  01F8     CLRF 0x1F8
0C49  01F9     CLRF 0x1F9
0C4A  01FA     CLRF 0x1FA
0C4B  26F0     CALL 0x6F0
0C4C  318B     MOVLP 0xB
0C4D  3A00     XORLW 0x0
0C4E  1D03     BTFSS STATUS, 0x2
0C4F  0008     RETURN
0C50  0023     MOVLB 0x3
0C51  0841     MOVF 0x1C1, W
0C52  390F     ANDLW 0xF
0C53  3A06     XORLW 0x6
0C54  1D03     BTFSS STATUS, 0x2
0C55  2C5A     GOTO 0x45A
0C56  0022     MOVLB 0x2
0C57  0B6C     DECFSZ 0x16C, W
0C58  2C5A     GOTO 0x45A
0C59  2B8A     GOTO 0x38A
0C5A  3185     MOVLP 0x5
0C5B  253D     CALL 0x53D
0C5C  318B     MOVLP 0xB
0C5D  2C44     GOTO 0x444
0C5E  0865     MOVF 0x165, W
0C5F  1903     BTFSC STATUS, 0x2
0C60  2C66     GOTO 0x466
0C61  0865     MOVF 0x165, W
0C62  0086     MOVWF FSR1L
0C63  0187     CLRF FSR1H
0C64  1B81     BTFSC INDF1, 0x7
0C65  0008     RETURN
0C66  0023     MOVLB 0x3
0C67  082B     MOVF 0x1AB, W
0C68  1D03     BTFSS STATUS, 0x2
0C69  2C74     GOTO 0x474
0C6A  082A     MOVF 0x1AA, W
0C6B  1D03     BTFSS STATUS, 0x2
0C6C  2C74     GOTO 0x474
0C6D  0829     MOVF 0x1A9, W
0C6E  3040     MOVLW 0x40
0C6F  1D03     BTFSS STATUS, 0x2
0C70  2C75     GOTO 0x475
0C71  0228     SUBWF 0x1A8, W
0C72  1C03     BTFSS STATUS, 0x0
0C73  2C7A     GOTO 0x47A
0C74  3040     MOVLW 0x40
0C75  0021     MOVLB 0x1
0C76  00D3     MOVWF NumBytesInPacket
0C77  27A3     CALL 0x7A3
0C78  318B     MOVLP 0xB
0C79  2C82     GOTO 0x482
0C7A  0828     MOVF i, W
0C7B  0021     MOVLB 0x1
0C7C  00D3     MOVWF NumBytesInPacket
0C7D  0023     MOVLB 0x3
0C7E  01A8     CLRF 0x1A8
0C7F  01A9     CLRF 0x1A9
0C80  01AA     CLRF 0x1AA
0C81  01AB     CLRF 0x1AB
0C82  0021     MOVLB 0x1
0C83  0853     MOVF NumBytesInPacket, W
0C84  00CF     MOVWF 0xCF
0C85  01D0     CLRF 0xD0
0C86  0850     MOVF 0xD0, W
0C87  0022     MOVLB 0x2
0C88  0241     SUBWF 0x141, W
0C89  1D03     BTFSS STATUS, 0x2
0C8A  2C8F     GOTO 0x48F
0C8B  0021     MOVLB 0x1
0C8C  084F     MOVF 0xCF, W
0C8D  0022     MOVLB 0x2
0C8E  0240     SUBWF TransferLength, W
0C8F  1C03     BTFSS STATUS, 0x0
0C90  2C98     GOTO 0x498
0C91  0021     MOVLB 0x1
0C92  0853     MOVF NumBytesInPacket, W
0C93  0022     MOVLB 0x2
0C94  02C0     SUBWF TransferLength, F
0C95  1C03     BTFSS STATUS, 0x0
0C96  03C1     DECF 0x141, F
0C97  2CAF     GOTO 0x4AF
0C98  0021     MOVLB 0x1
0C99  01DC     CLRF i
0C9A  0853     MOVF NumBytesInPacket, W
0C9B  025C     SUBWF i, W
0C9C  1803     BTFSC STATUS, 0x0
0C9D  2CAF     GOTO 0x4AF
0C9E  0022     MOVLB 0x2
0C9F  0840     MOVF TransferLength, W
0CA0  0441     IORWF 0x141, W
0CA1  1903     BTFSC STATUS, 0x2
0CA2  2CA8     GOTO 0x4A8
0CA3  3001     MOVLW 0x1
0CA4  02C0     SUBWF TransferLength, F
0CA5  3000     MOVLW 0x0
0CA6  3BC1     SUBWFB 0x141, F
0CA7  2CAC     GOTO 0x4AC
0CA8  0021     MOVLB 0x1
0CA9  27D6     CALL 0x7D6
0CAA  318B     MOVLP 0xB
0CAB  0181     CLRF INDF1
0CAC  0021     MOVLB 0x1
0CAD  0ADC     INCF i, F
0CAE  2C9A     GOTO 0x49A
0CAF  30A0     MOVLW 0xA0
0CB0  01F0     CLRF 0xF0
0CB1  0AF0     INCF 0xF0, F
0CB2  00F1     MOVWF 0xF1
0CB3  3002     MOVLW 0x2
0CB4  00F2     MOVWF 0xF2
0CB5  0021     MOVLB 0x1
0CB6  0853     MOVF NumBytesInPacket, W
0CB7  00F3     MOVWF 0xF3
0CB8  3001     MOVLW 0x1
0CB9  3184     MOVLP 0x4
0CBA  2427     CALL 0x427
0CBB  318B     MOVLP 0xB
0CBC  0021     MOVLB 0x1
0CBD  00E5     MOVWF USBMSDInHandle
0CBE  27C4     CALL 0x7C4
0CBF  318B     MOVLP 0xB
0CC0  2B88     GOTO 0x388
0CC1  307F     MOVLW 0x7F
0CC2  2D12     GOTO 0x512
973:           
974:           
975:           /******************************************************************************
976:            	Function:
977:            		static void MSDComputeDeviceInAndResidue(uint16_t DiExpected)
978:            		
979:            	Description:
980:            		This is a private function that performs Hi > Di data size checking
981:            		and handling.  This function also computes the proper CSW data residue
982:            		and updates the global variable.
983:            		
984:            	PreCondition:
985:            		Should only be called in the context of the 
986:            		MSDProcessCommandMediaPresent() handler function, after receiving a new
987:            		command that needs processing.  Before calling this function, make sure
988:            		the gblCBW.dCBWDataTransferLength and TransferLength.Val variables have
989:            		been pre-loaded with the expected host and device data size values.
990:            		
991:            	Parameters:
992:            		uint16_t DiExpected - Input: Firmware can specify an additional value that 
993:            		might be smaller than the TransferLength.Val value.  The function will
994:            		update TransferLength.Val with the smaller of the original value, or
995:            		DiExpected.
996:            		
997:            	Return Values:
998:            		None
999:            		
1000:           	Remarks:
1001:           		None
1002:           
1003:            *****************************************************************************/
1004:          static void MSDComputeDeviceInAndResidue(uint16_t DiExpected)
1005:          {
1006:              //Error check number of bytes to send.  Check for Hi < Di
1007:              if(gblCBW.dCBWDataTransferLength < DiExpected)
0CC3  0870     MOVF 0xF0, W
0CC4  00F2     MOVWF 0xF2
0CC5  0871     MOVF 0xF1, W
0CC6  00F3     MOVWF 0xF3
0CC7  01F4     CLRF 0xF4
0CC8  01F5     CLRF 0xF5
0CC9  0875     MOVF 0xF5, W
0CCA  0023     MOVLB 0x3
0CCB  022B     SUBWF 0x1AB, W
0CCC  1D03     BTFSS STATUS, 0x2
0CCD  2CD8     GOTO 0x4D8
0CCE  0874     MOVF 0x1F4, W
0CCF  022A     SUBWF 0x1AA, W
0CD0  1D03     BTFSS STATUS, 0x2
0CD1  2CD8     GOTO 0x4D8
0CD2  0873     MOVF 0x1F3, W
0CD3  0229     SUBWF 0x1A9, W
0CD4  1D03     BTFSS STATUS, 0x2
0CD5  2CD8     GOTO 0x4D8
0CD6  0872     MOVF 0x1F2, W
0CD7  0228     SUBWF 0x1A8, W
0CD8  1803     BTFSC STATUS, 0x0
0CD9  2CE4     GOTO 0x4E4
0CDA  27CA     CALL 0x7CA
1008:              {
1009:                  //The host has requested less data than the entire response.  We
1010:                  //send only the host requested quantity of bytes.
1011:                  msd_csw.dCSWDataResidue = 0;
1012:                  TransferLength.Val = gblCBW.dCBWDataTransferLength;
0CDB  0023     MOVLB 0x3
0CDC  0829     MOVF 0x1A9, W
0CDD  0022     MOVLB 0x2
0CDE  00C1     MOVWF 0x141
0CDF  0023     MOVLB 0x3
0CE0  0828     MOVF 0x1A8, W
0CE1  0022     MOVLB 0x2
0CE2  00C0     MOVWF TransferLength
1013:              }   	
0CE3  0008     RETURN
1014:              else
1015:              {
1016:                  //The host requested greater than or equal to the number of bytes expected.
1017:                  if(DiExpected < TransferLength.Val)
0CE4  0022     MOVLB 0x2
0CE5  0841     MOVF 0x141, W
0CE6  0271     SUBWF 0x171, W
0CE7  1D03     BTFSS STATUS, 0x2
0CE8  2CEB     GOTO 0x4EB
0CE9  0840     MOVF TransferLength, W
0CEA  0270     SUBWF 0x170, W
0CEB  1803     BTFSC STATUS, 0x0
0CEC  2CF1     GOTO 0x4F1
1018:                  {
1019:                      TransferLength.Val = DiExpected;
0CED  0871     MOVF 0x171, W
0CEE  00C1     MOVWF 0x141
0CEF  0870     MOVF 0x170, W
0CF0  00C0     MOVWF TransferLength
1020:                  }    
1021:                  msd_csw.dCSWDataResidue = gblCBW.dCBWDataTransferLength - TransferLength.Val;
0CF1  0840     MOVF TransferLength, W
0CF2  00F2     MOVWF 0x172
0CF3  0841     MOVF 0x141, W
0CF4  00F3     MOVWF 0x173
0CF5  01F4     CLRF 0x174
0CF6  01F5     CLRF 0x175
0CF7  0023     MOVLB 0x3
0CF8  0828     MOVF 0x1A8, W
0CF9  00F6     MOVWF 0x1F6
0CFA  0829     MOVF 0x1A9, W
0CFB  00F7     MOVWF 0x1F7
0CFC  082A     MOVF 0x1AA, W
0CFD  00F8     MOVWF 0x1F8
0CFE  082B     MOVF 0x1AB, W
0CFF  00F9     MOVWF 0x1F9
0D00  0872     MOVF 0x1F2, W
0D01  02F6     SUBWF 0x1F6, F
0D02  0873     MOVF 0x1F3, W
0D03  3BF7     SUBWFB 0x1F7, F
0D04  0874     MOVF 0x1F4, W
0D05  3BF8     SUBWFB 0x1F8, F
0D06  0875     MOVF 0x1F5, W
0D07  3BF9     SUBWFB 0x1F9, F
0D08  0879     MOVF 0x1F9, W
0D09  0022     MOVLB 0x2
0D0A  00EB     MOVWF 0x16B
0D0B  0878     MOVF 0x178, W
0D0C  00EA     MOVWF 0x16A
0D0D  0877     MOVF 0x177, W
0D0E  00E9     MOVWF 0x169
0D0F  0876     MOVF 0x176, W
0D10  00E8     MOVWF 0x168
1022:              }     
1023:          }    
0D11  0008     RETURN
1024:          
1025:          
1026:          /******************************************************************************
1027:           	Function:
1028:           		uint8_t MSDReadHandler(void)
1029:           	Description:
1030:           		This function processes a read command received through 
1031:           		the MSD class driver
1032:           	Return Values:
1033:           		uint8_t - the current state of the MSDReadHandler state
1034:           		machine.  The valid values are defined in MSD.h under the 
1035:           		MSDReadHandler state machine declaration section
1036:            *****************************************************************************/
1037:          uint8_t MSDReadHandler(void)
1038:          {
1039:              static uint8_t segment;
1040:              
1041:              switch(MSDReadState)
0816  318E     MOVLP 0xE
0E51  2EE2     GOTO 0x6E2
0EE2  0022     MOVLB 0x2
0EE3  084C     MOVF MSDReadState, W
0EE4  0084     MOVWF FSR0L
0EE5  3005     MOVLW 0x5
0EE6  0204     SUBWF FSR0L, W
0EE7  1803     BTFSC STATUS, 0x0
0EE8  2EDD     GOTO 0x6DD
0EE9  3188     MOVLP 0x8
0EEA  3504     LSLF FSR0L, W
0EEB  3E16     ADDLW 0x16
0EEC  0082     MOVWF PCL
1042:              {
1043:                  case MSD_READ10_WAIT:
1044:                      //Extract the LBA from the CBW.  Note: Also need to perform endian 
1045:                      //swap, since the multi-byte CBW fields are stored big endian, but 
1046:                      //the Microchip C compilers are little endian.
1047:                      LBA.v[3]=gblCBW.CBWCB[2];
0E52  2763     CALL 0x763
0E53  318B     MOVLP 0xB
1048:                      LBA.v[2]=gblCBW.CBWCB[3];
1049:                      LBA.v[1]=gblCBW.CBWCB[4];
1050:                      LBA.v[0]=gblCBW.CBWCB[5];
1051:          
1052:                      TransferLength.byte.HB = gblCBW.CBWCB[7];   //MSB of Transfer Length (in number of blocks, not bytes)
1053:                      TransferLength.byte.LB = gblCBW.CBWCB[8];   //LSB of Transfer Length (in number of blocks, not bytes)
1054:          
1055:                      //Check for possible error cases before proceeding
1056:                      if(MSDCheckForErrorCases(TransferLength.Val * (uint32_t)FILEIO_CONFIG_MEDIA_SECTOR_SIZE) != MSD_ERROR_CASE_NO_ERROR)
0E54  27ED     CALL 0x7ED
0E55  318B     MOVLP 0xB
0E56  0B89     DECFSZ WREG, F
0E57  2E54     GOTO 0x654
0E58  26F0     CALL 0x6F0
0E59  318B     MOVLP 0xB
0E5A  3A00     XORLW 0x0
0E5B  1D03     BTFSS STATUS, 0x2
0E5C  2EED     GOTO 0x6ED
1057:                      {
1058:                          break;
1059:                      }    
1060:          
1061:                      MSDReadState = MSD_READ10_BLOCK;
0E5D  0022     MOVLB 0x2
0E5E  01CC     CLRF MSDReadState
0E5F  0ACC     INCF MSDReadState, F
1062:                      //Fall through to MSD_READ_BLOCK
1063:                      
1064:                  case MSD_READ10_BLOCK:
1065:                      if(TransferLength.Val == 0)
0E60  0840     MOVF TransferLength, W
0E61  0441     IORWF 0x141, W
0E62  1D03     BTFSS STATUS, 0x2
0E63  2E67     GOTO 0x667
1066:                      {
1067:                          MSDReadState = MSD_READ10_WAIT;
0E64  0022     MOVLB 0x2
0E65  01CC     CLRF MSDReadState
1068:                          break;
0E66  2EED     GOTO 0x6ED
1069:                      }
1070:                      
1071:                      TransferLength.Val--;					// we have read 1 LBA
0E67  3001     MOVLW 0x1
0E68  02C0     SUBWF TransferLength, F
0E69  3000     MOVLW 0x0
0E6A  3BC1     SUBWFB 0x141, F
1072:                      MSDReadState = MSD_READ10_SECTOR;
0E6B  3002     MOVLW 0x2
0E6C  00CC     MOVWF MSDReadState
1073:                      //Fall through to MSD_READ10_SECTOR
1074:                      
1075:                  case MSD_READ10_SECTOR:
1076:                      //if the old data isn't completely sent yet
1077:                      if(USBHandleBusy(USBMSDInHandle) != 0)
0E6D  0021     MOVLB 0x1
0E6E  0865     MOVF USBMSDInHandle, W
0E6F  1903     BTFSC STATUS, 0x2
0E70  2E76     GOTO 0x676
0E71  0865     MOVF USBMSDInHandle, W
0E72  0086     MOVWF FSR1L
0E73  0187     CLRF FSR1H
0E74  1B81     BTFSC INDF1, 0x7
0E75  2EED     GOTO 0x6ED
1078:                      {
1079:                          break;
1080:                      }
1081:                      
1082:                      LBA.Val++;
0E76  3001     MOVLW 0x1
0E77  0022     MOVLB 0x2
0E78  27E2     CALL 0x7E2
0E79  318B     MOVLP 0xB
1083:                      msd_csw.dCSWDataResidue=BLOCKLEN_512;//in order to send the 512 bytes of data read
0E7A  27B8     CALL 0x7B8
0E7B  318B     MOVLP 0xB
1084:                      segment = 0;    // !!!
0E7D  01C7     CLRF segment
1085:                      ptrNextData=(uint8_t *)&msd_buffer[0];
0E7C  30A0     MOVLW 0xA0
0E7E  00CA     MOVWF ptrNextData
1086:                      
1087:                      MSDReadState = MSD_READ10_TX_SECTOR;
0E7F  3003     MOVLW 0x3
0E80  00CC     MOVWF MSDReadState
1088:                      //Fall through to MSD_READ10_TX_SECTOR
1089:                      
1090:                  case MSD_READ10_TX_SECTOR:
1091:                      if(msd_csw.dCSWDataResidue == 0)
0E81  27E8     CALL 0x7E8
0E82  318B     MOVLP 0xB
0E83  1D03     BTFSS STATUS, 0x2
0E84  2E88     GOTO 0x688
1092:                      {
1093:                          MSDReadState = MSD_READ10_BLOCK;
0E85  01CC     CLRF MSDReadState
0E86  0ACC     INCF MSDReadState, F
1094:                          break;
0E87  2EED     GOTO 0x6ED
1095:                      }
1096:                      
1097:                      MSDReadState = MSD_READ10_TX_PACKET;
0E88  3004     MOVLW 0x4
0E89  00CC     MOVWF MSDReadState
1098:                      //Fall through to MSD_READ10_TX_PACKET
1099:                      
1100:                  case MSD_READ10_TX_PACKET:
1101:                      /* Write next chunk of data to EP Buffer and send */
1102:                      
1103:                      //Make sure the endpoint is available before using it.
1104:                      if(USBHandleBusy(USBMSDInHandle))
0E8A  0021     MOVLB 0x1
0E8B  0865     MOVF USBMSDInHandle, W
0E8C  1903     BTFSC STATUS, 0x2
0E8D  2E93     GOTO 0x693
0E8E  0865     MOVF USBMSDInHandle, W
0E8F  0086     MOVWF FSR1L
0E90  0187     CLRF FSR1H
0E91  1B81     BTFSC INDF1, 0x7
0E92  2EED     GOTO 0x6ED
1105:                      {
1106:                          break;
1107:                      }
1108:                      
1109:                      // get directly a packet of data from target !!!
1110:                      if(LUNSectorRead(LBA.Val, (uint8_t*)&msd_buffer[0], segment++) != true)
0E93  0023     MOVLB 0x3
0E94  086A     MOVF 0x1EA, W
0E95  0021     MOVLB 0x1
0E96  00A0     MOVWF __pcstackBANK1
0E97  0022     MOVLB 0x2
0E98  082F     MOVF 0x12F, W
0E99  0021     MOVLB 0x1
0E9A  00A4     MOVWF i
0E9B  0022     MOVLB 0x2
0E9C  082E     MOVF 0x12E, W
0E9D  0021     MOVLB 0x1
0E9E  00A3     MOVWF 0xA3
0E9F  0022     MOVLB 0x2
0EA0  082D     MOVF 0x12D, W
0EA1  0021     MOVLB 0x1
0EA2  00A2     MOVWF chk
0EA3  0022     MOVLB 0x2
0EA4  082C     MOVF LBA, W
0EA5  0021     MOVLB 0x1
0EA6  00A1     MOVWF sector_addr
0EA7  30A0     MOVLW 0xA0
0EA8  00A5     MOVWF address
0EA9  0022     MOVLB 0x2
0EAA  0847     MOVF segment, W
0EAB  0AC7     INCF segment, F
0EAC  0021     MOVLB 0x1
0EAD  00A6     MOVWF p
0EAE  3008     MOVLW 0x8
0EAF  278C     CALL 0x78C
0EB0  008A     MOVWF PCLATH
0EB1  3F40     MOVIW 0[FSR1]
0EB2  000A     CALLW
0EB3  318E     MOVLP 0xE
0EB4  3A01     XORLW 0x1
0EB5  1903     BTFSC STATUS, 0x2
0EB6  2EC8     GOTO 0x6C8
1111:                      {
1112:                          //Read failed, no retries!!!
1113:                          // we can't send the CSW immediately, since the host
1114:                          // still expects to receive sector read data on the IN endpoint
1115:                          // first.  Therefore, we still send dummy bytes, before
1116:                          // we send the CSW with the failed status in it.
1117:                          msd_csw.bCSWStatus=0x02;		// Indicate phase error 0x02
0EB7  3002     MOVLW 0x2
0EB8  0022     MOVLB 0x2
0EB9  00EC     MOVWF 0x16C
1118:                                                            // (option #1 from BOT section 6.6.2)
1119:                          //Set error status sense keys, so the host can check them later
1120:                          gblSenseData[LUN_INDEX].SenseKey=S_MEDIUM_ERROR;
0EBA  0023     MOVLB 0x3
0EBB  0841     MOVF 0x1C1, W
0EBC  39F0     ANDLW 0xF0
0EBD  3803     IORLW 0x3
0EBE  00C1     MOVWF 0x1C1
1121:                          gblSenseData[LUN_INDEX].ASC=ASC_NO_ADDITIONAL_SENSE_INFORMATION;
0EC0  01CB     CLRF 0x1CB
1122:                          gblSenseData[LUN_INDEX].ASCQ=ASCQ_NO_ADDITIONAL_SENSE_INFORMATION;
0EC1  01CC     CLRF 0x1CC
1123:                          USBStallEndpoint(MSD_DATA_IN_EP, IN_TO_HOST);
0EBF  3001     MOVLW 0x1
0EC2  01F0     CLRF 0x1F0
0EC3  0AF0     INCF 0x1F0, F
0EC4  3182     MOVLP 0x2
0EC5  226B     CALL 0x26B
0EC6  318B     MOVLP 0xB
0EC7  2E64     GOTO 0x664
1124:                          MSDReadState = MSD_READ10_WAIT;
1125:                          break;
1126:                      }//else we successfully read a packet worth of data from our media
1127:                      
1128:                      //Prepare the USB module to send an IN transaction worth of data to the host.
1129:                      USBMSDInHandle = USBTxOnePacket(MSD_DATA_IN_EP,ptrNextData,MSD_IN_EP_SIZE);
0EC8  01F0     CLRF 0x1F0
0EC9  0AF0     INCF 0x1F0, F
0ECA  2792     CALL 0x792
0ECB  3184     MOVLP 0x4
0ECC  2427     CALL 0x427
0ECD  318B     MOVLP 0xB
0ECE  0021     MOVLB 0x1
0ECF  00E5     MOVWF USBMSDInHandle
1130:                      
1131:                      MSDReadState = MSD_READ10_TX_SECTOR;
0ED0  3003     MOVLW 0x3
0ED1  0022     MOVLB 0x2
0ED2  00CC     MOVWF MSDReadState
0ED3  27A3     CALL 0x7A3
0ED4  318B     MOVLP 0xB
1132:          
1133:                      gblCBW.dCBWDataTransferLength-=	MSD_IN_EP_SIZE;
1134:                      msd_csw.dCSWDataResidue-=MSD_IN_EP_SIZE;
0ED5  3040     MOVLW 0x40
0ED6  0022     MOVLB 0x2
0ED7  02E8     SUBWF 0x168, F
0ED8  3000     MOVLW 0x0
0ED9  3BE9     SUBWFB 0x169, F
0EDA  3BEA     SUBWFB 0x16A, F
0EDB  3BEB     SUBWFB 0x16B, F
1135:          //            ptrNextData+=MSD_IN_EP_SIZE;  // keep the pointer fix!!!
1136:                      break;
0EDC  2EED     GOTO 0x6ED
1137:                  
1138:                  default:
1139:                      //Illegal condition, should never occur.  In the event that it ever
1140:                      //did occur anyway, try to notify the host of the error.
1141:                      msd_csw.bCSWStatus=0x02;  //indicate "Phase Error"
0EDD  27B2     CALL 0x7B2
1142:                      USBStallEndpoint(MSD_DATA_IN_EP, IN_TO_HOST);
0EDE  3182     MOVLP 0x2
0EDF  226B     CALL 0x26B
0EE0  318B     MOVLP 0xB
0EE1  2E64     GOTO 0x664
1143:                      //Advance state machine
1144:                      MSDReadState = MSD_READ10_WAIT;
1145:                      break;
1146:              }//switch(MSDReadState)
1147:              
1148:              return MSDReadState;
0EED  0022     MOVLB 0x2
0EEE  084C     MOVF MSDReadState, W
1149:          }
0EEF  0008     RETURN
1150:          
1151:          
1152:          /******************************************************************************
1153:           	Function:
1154:           		uint8_t MSDWriteHandler(void)
1155:           		
1156:           	Description:
1157:           		This function processes a write command received through 
1158:           		the MSD class driver
1159:           		
1160:           	PreCondition:
1161:           		None
1162:           		
1163:           	Parameters:
1164:           		None
1165:           		
1166:           	Return Values:
1167:           		uint8_t - the current state of the MSDWriteHandler state
1168:           		machine.  The valid values are defined in MSD.h under the 
1169:           		MSDWriteHandler state machine declaration section
1170:           		
1171:           	Remarks:
1172:           		None
1173:           
1174:           *****************************************************************************/
1175:          uint8_t MSDWriteHandler(void)
1176:          {
1177:              static uint8_t segment;
1178:              
1179:              switch(MSDWriteState)
080C  318D     MOVLP 0xD
0D7E  2E45     GOTO 0x645
0E45  0022     MOVLB 0x2
0E46  084B     MOVF MSDWriteState, W
0E47  0084     MOVWF FSR0L
0E48  3005     MOVLW 0x5
0E49  0204     SUBWF FSR0L, W
0E4A  1803     BTFSC STATUS, 0x0
0E4B  2E42     GOTO 0x642
0E4C  3188     MOVLP 0x8
0E4D  3504     LSLF FSR0L, W
0E4E  3E0C     ADDLW 0xC
0E4F  0082     MOVWF PCL
1180:              {
1181:                  case MSD_WRITE10_WAIT:
1182:                      /* Read the LBA, TransferLength fields from Command Block
1183:                      NOTE: CB is Big-Endian */
1184:                      LBA.v[3]=gblCBW.CBWCB[2];
0D7F  2763     CALL 0x763
0D80  318B     MOVLP 0xB
1185:                      LBA.v[2]=gblCBW.CBWCB[3];
1186:                      LBA.v[1]=gblCBW.CBWCB[4];
1187:                      LBA.v[0]=gblCBW.CBWCB[5];
1188:                      TransferLength.v[1]=gblCBW.CBWCB[7];
1189:                      TransferLength.v[0]=gblCBW.CBWCB[8];
1190:          
1191:                      //Do some error case checking.
1192:                      if(MSDCheckForErrorCases(TransferLength.Val * (uint32_t)FILEIO_CONFIG_MEDIA_SECTOR_SIZE) != MSD_ERROR_CASE_NO_ERROR)
0D81  27ED     CALL 0x7ED
0D82  318B     MOVLP 0xB
0D83  0B89     DECFSZ WREG, F
0D84  2D81     GOTO 0x581
0D85  26F0     CALL 0x6F0
0D86  318B     MOVLP 0xB
0D87  3A00     XORLW 0x0
0D88  1D03     BTFSS STATUS, 0x2
0D89  2DB0     GOTO 0x5B0
0D8A  2782     CALL 0x782
1193:                      {
1194:                          //An error was detected.  The MSDCheckForErrorCases() function will
1195:                          //have taken care of setting the proper states to report the error to the host.
1196:                          break;
1197:                      }
1198:                      
1199:                      //Check if the media is write protected before deciding what
1200:                      //to do with the data.
1201:                      if(LUNWriteProtectState())
0D8B  008A     MOVWF PCLATH
0D8C  3F40     MOVIW 0[FSR1]
0D8D  000A     CALLW
0D8E  318D     MOVLP 0xD
0D8F  3A00     XORLW 0x0
0D90  1903     BTFSC STATUS, 0x2
0D91  2DB3     GOTO 0x5B3
1202:                      {
1203:                          //The media appears to be write protected.
1204:                          //Let host know error occurred.  The bCSWStatus flag is also used by
1205:                          //the write handler, to know not to even attempt the write sequence.
1206:                          msd_csw.bCSWStatus = MSD_CSW_COMMAND_FAILED;
0D92  279C     CALL 0x79C
0D93  318B     MOVLP 0xB
1207:          
1208:                          //Set sense keys so the host knows what caused the error.
1209:                          gblSenseData[LUN_INDEX].SenseKey=S_DATA_PROTECT;
0D94  3807     IORLW 0x7
0D95  27F2     CALL 0x7F2
1210:                          gblSenseData[LUN_INDEX].ASC=ASC_WRITE_PROTECTED;
1211:                          gblSenseData[LUN_INDEX].ASCQ=ASCQ_WRITE_PROTECTED;
1212:          
1213:                          //Stall the OUT endpoint, so as to promptly inform the host
1214:                          //that the data cannot be accepted, due to write protected media.
1215:                          USBStallEndpoint(MSD_DATA_OUT_EP, OUT_FROM_HOST);
0D96  3001     MOVLW 0x1
0D97  01F0     CLRF 0x170
0D98  3182     MOVLP 0x2
0D99  226B     CALL 0x26B
0D9A  318B     MOVLP 0xB
1216:                          MSDWriteState = MSD_WRITE10_WAIT;
0D9B  0022     MOVLB 0x2
0D9C  01CB     CLRF MSDWriteState
1217:                          return MSDWriteState;
0DB0  0022     MOVLB 0x2
0DB1  084B     MOVF MSDWriteState, W
0DB2  0008     RETURN
1218:                      }
1219:                  	
1220:                      MSD_State = MSD_WRITE10_BLOCK;
0DB3  0022     MOVLB 0x2
0DB4  01CD     CLRF MSD_State
0DB5  0ACD     INCF MSD_State, F
1221:                      //Fall through to MSD_WRITE10_BLOCK
1222:                      
1223:                  case MSD_WRITE10_BLOCK:
1224:                      if(TransferLength.Val == 0)
0DB6  0840     MOVF TransferLength, W
0DB7  0441     IORWF 0x141, W
0DB8  1903     BTFSC STATUS, 0x2
0DB9  2D9B     GOTO 0x59B
1225:                      {
1226:                          MSDWriteState = MSD_WRITE10_WAIT;
1227:                          break;
1228:                      }
1229:                      
1230:                      MSDWriteState = MSD_WRITE10_RX_SECTOR;
0DBA  3003     MOVLW 0x3
0DBB  00CB     MOVWF MSDWriteState
1231:                      ptrNextData=(uint8_t *)&msd_buffer[0];
0DBC  30A0     MOVLW 0xA0
0DBD  00CA     MOVWF ptrNextData
0DBE  27B8     CALL 0x7B8
0DBF  318B     MOVLP 0xB
1232:                        
1233:                      msd_csw.dCSWDataResidue=BLOCKLEN_512;
1234:                      segment = 0;    // !!!
0DC0  01C6     CLRF segment
1235:                  	
1236:                      //Fall through to MSD_WRITE10_RX_SECTOR
1237:                  case MSD_WRITE10_RX_SECTOR:
1238:                  {
1239:                      if(msd_csw.dCSWDataResidue>0)
0D9D  2DB0     GOTO 0x5B0
0DC1  27E8     CALL 0x7E8
0DC2  318B     MOVLP 0xB
0DC3  1D03     BTFSS STATUS, 0x2
0DC4  2D9E     GOTO 0x59E
0DC5  2782     CALL 0x782
1240:                      {
1241:                          if(USBHandleBusy(USBMSDOutHandle) == true) break;
0D9E  0021     MOVLB 0x1
0D9F  086D     MOVF USBMSDOutHandle, W
0DA0  1903     BTFSC STATUS, 0x2
0DA1  2DA7     GOTO 0x5A7
0DA2  086D     MOVF USBMSDOutHandle, W
0DA3  0086     MOVWF FSR1L
0DA4  0187     CLRF FSR1H
0DA5  1B81     BTFSC INDF1, 0x7
0DA6  2DB0     GOTO 0x5B0
1242:                          USBMSDOutHandle = USBRxOnePacket(MSD_DATA_OUT_EP,ptrNextData,MSD_OUT_EP_SIZE);
0DA7  01F0     CLRF 0xF0
0DA8  2792     CALL 0x792
0DA9  3184     MOVLP 0x4
0DAA  2427     CALL 0x427
0DAB  0021     MOVLB 0x1
0DAC  00ED     MOVWF USBMSDOutHandle
1243:          
1244:                          MSDWriteState = MSD_WRITE10_RX_PACKET;
0DAD  3004     MOVLW 0x4
0DAE  0022     MOVLB 0x2
0DAF  00CB     MOVWF MSDWriteState
1245:                          //Fall through to MSD_WRITE10_RX_PACKET // do not!!!
1246:                          break;
1247:                	    }
1248:                	    else
1249:                	    {
1250:                          //We finished receiving a sector worth of data from the host.
1251:                          if(LUNWriteProtectState())
0DC6  008A     MOVWF PCLATH
0DC7  3F40     MOVIW 0[FSR1]
0DC8  000A     CALLW
0DC9  318D     MOVLP 0xD
0DCA  3A00     XORLW 0x0
0DCB  1903     BTFSC STATUS, 0x2
0DCC  2DD2     GOTO 0x5D2
0DCD  279C     CALL 0x79C
0DCE  318B     MOVLP 0xB
1252:                          {
1253:                              //The device appears to be write protected.
1254:                              //Let host know error occurred.  The bCSWStatus flag is also used by
1255:                              //the write handler, to know not to even attempt the write sequence.
1256:                              msd_csw.bCSWStatus=0x01;
1257:                              //Set sense keys so the host knows what caused the error.
1258:                              gblSenseData[LUN_INDEX].SenseKey=S_NOT_READY;
0DCF  3802     IORLW 0x2
0DD0  27F2     CALL 0x7F2
0DD1  318B     MOVLP 0xB
1259:                              gblSenseData[LUN_INDEX].ASC=ASC_WRITE_PROTECTED;
1260:                              gblSenseData[LUN_INDEX].ASCQ=ASCQ_WRITE_PROTECTED;
1261:                          }
1262:          
1263:                          MSDWriteState = MSD_WRITE10_SECTOR;
0DD2  3002     MOVLW 0x2
0DD3  2DAE     GOTO 0x5AE
1264:                          break;
1265:                      }
1266:                  }
1267:                  //Fall through to MSD_WRITE10_RX_PACKET
1268:                  case MSD_WRITE10_RX_PACKET:
1269:                      if(USBHandleBusy(USBMSDOutHandle) == true) break;
0DD4  0021     MOVLB 0x1
0DD5  086D     MOVF USBMSDOutHandle, W
0DD6  1903     BTFSC STATUS, 0x2
0DD7  2DDD     GOTO 0x5DD
0DD8  086D     MOVF USBMSDOutHandle, W
0DD9  0086     MOVWF FSR1L
0DDA  0187     CLRF FSR1H
0DDB  1B81     BTFSC INDF1, 0x7
0DDC  2DB0     GOTO 0x5B0
1270:                      // immediately write the data to target !!!
1271:                      if(msd_csw.bCSWStatus == 0x00)
0DDD  0022     MOVLB 0x2
0DDE  086C     MOVF 0x16C, W
0DDF  1D03     BTFSS STATUS, 0x2
0DE0  2E0F     GOTO 0x60F
1272:                      {   // notice the LBA.Val+1 !!!
1273:                          if (LUNSectorWrite(LBA.Val+1, (uint8_t*)&msd_buffer[0], segment++) != true)
0DE1  0023     MOVLB 0x3
0DE2  086A     MOVF 0x1EA, W
0DE3  0021     MOVLB 0x1
0DE4  00C0     MOVWF config
0DE5  3001     MOVLW 0x1
0DE6  0022     MOVLB 0x2
0DE7  072C     ADDWF LBA, W
0DE8  0021     MOVLB 0x1
0DE9  00C1     MOVWF sector_addr
0DEA  3000     MOVLW 0x0
0DEB  0022     MOVLB 0x2
0DEC  3D2D     ADDWFC 0x12D, W
0DED  0021     MOVLB 0x1
0DEE  00C2     MOVWF 0xC2
0DEF  3000     MOVLW 0x0
0DF0  0022     MOVLB 0x2
0DF1  3D2E     ADDWFC 0x12E, W
0DF2  0021     MOVLB 0x1
0DF3  00C3     MOVWF 0xC3
0DF4  3000     MOVLW 0x0
0DF5  0022     MOVLB 0x2
0DF6  3D2F     ADDWFC 0x12F, W
0DF7  0021     MOVLB 0x1
0DF8  00C4     MOVWF 0xC4
0DF9  30A0     MOVLW 0xA0
0DFA  00C5     MOVWF buffer
0DFB  0022     MOVLB 0x2
0DFC  0846     MOVF segment, W
0DFD  0AC6     INCF segment, F
0DFE  0021     MOVLB 0x1
0DFF  00C6     MOVWF seg
0E00  300C     MOVLW 0xC
0E01  278C     CALL 0x78C
0E02  008A     MOVWF PCLATH
0E03  3F40     MOVIW 0[FSR1]
0E04  000A     CALLW
0E05  318E     MOVLP 0xE
0E06  3A01     XORLW 0x1
0E07  1903     BTFSC STATUS, 0x2
0E08  2E0F     GOTO 0x60F
0E09  279C     CALL 0x79C
0E0A  318B     MOVLP 0xB
1274:                          {   // if failed, communicate immediately, no retries!
1275:                              msd_csw.bCSWStatus = MSD_CSW_COMMAND_FAILED;    // Indicate error during CSW phase
1276:                              // Set error status sense keys, so the host can check them later
1277:                              gblSenseData[LUN_INDEX].SenseKey = S_MEDIUM_ERROR;
0E0B  3803     IORLW 0x3
0E0C  00C1     MOVWF sector_addr
1278:                              gblSenseData[LUN_INDEX].ASC = ASC_NO_ADDITIONAL_SENSE_INFORMATION;
0E0D  01CB     CLRF 0xCB
1279:                              gblSenseData[LUN_INDEX].ASCQ = ASCQ_NO_ADDITIONAL_SENSE_INFORMATION;
0E0E  01CC     CLRF 0xCC
1280:                          }
1281:                      }
1282:                      gblCBW.dCBWDataTransferLength-=USBHandleGetLength(USBMSDOutHandle);		// 64B read
0E0F  0021     MOVLB 0x1
0E10  0A6D     INCF USBMSDOutHandle, W
0E11  0086     MOVWF FSR1L
0E12  0187     CLRF FSR1H
0E13  27BE     CALL 0x7BE
0E14  318B     MOVLP 0xB
0E15  0023     MOVLB 0x3
0E16  02A8     SUBWF 0x1A8, F
0E17  0021     MOVLB 0x1
0E18  084C     MOVF 0xCC, W
0E19  0023     MOVLB 0x3
0E1A  3BA9     SUBWFB 0x1A9, F
0E1B  0021     MOVLB 0x1
0E1C  084D     MOVF 0xCD, W
0E1D  0023     MOVLB 0x3
0E1E  3BAA     SUBWFB 0x1AA, F
0E1F  0021     MOVLB 0x1
0E20  084E     MOVF 0xCE, W
0E21  0023     MOVLB 0x3
0E22  3BAB     SUBWFB 0x1AB, F
1283:                      msd_csw.dCSWDataResidue-=USBHandleGetLength(USBMSDOutHandle);
0E23  0021     MOVLB 0x1
0E24  0A6D     INCF USBMSDOutHandle, W
0E25  0086     MOVWF FSR1L
0E26  27BE     CALL 0x7BE
0E27  318B     MOVLP 0xB
0E28  0022     MOVLB 0x2
0E29  02E8     SUBWF 0x168, F
0E2A  0021     MOVLB 0x1
0E2B  084C     MOVF 0xCC, W
0E2C  0022     MOVLB 0x2
0E2D  3BE9     SUBWFB 0x169, F
0E2E  0021     MOVLB 0x1
0E2F  084D     MOVF 0xCD, W
0E30  0022     MOVLB 0x2
0E31  3BEA     SUBWFB 0x16A, F
0E32  0021     MOVLB 0x1
0E33  084E     MOVF 0xCE, W
0E34  0022     MOVLB 0x2
0E35  3BEB     SUBWFB 0x16B, F
1284:          //            ptrNextData += MSD_OUT_EP_SIZE; // keep the pointer fixed !!!
1285:                      
1286:                      MSDWriteState = MSD_WRITE10_RX_SECTOR;
0E36  3003     MOVLW 0x3
0E37  2DAF     GOTO 0x5AF
1287:                      break;
1288:                      
1289:                  case MSD_WRITE10_SECTOR:
1290:                  {
1291:                      //Make sure that no error has been detected, before performing the write
1292:                      //operation.  If there was an error, skip the write operation, but allow
1293:                      //the TransferLength to continue decrementing, so that we can eventually
1294:                      //receive all OUT bytes that the host is planning on sending us.  Only
1295:                      //after that is complete will the host send the IN token for the CSW packet,
1296:                      //which will contain the bCSWStatus letting it know an error occurred.
1297:          
1298:                      //One LBA is written (unless an error occurred).  Advance state
1299:                      //variables so we can eventually finish handling the CBW request.
1300:                      LBA.Val++;
0E38  3001     MOVLW 0x1
0E39  27E2     CALL 0x7E2
0E3A  318B     MOVLP 0xB
1301:                      TransferLength.Val--;
0E3B  3001     MOVLW 0x1
0E3C  02C0     SUBWF TransferLength, F
0E3D  3000     MOVLW 0x0
0E3E  3BC1     SUBWFB 0x141, F
1302:                      MSDWriteState = MSD_WRITE10_BLOCK;
0E3F  01CB     CLRF MSDWriteState
0E40  0ACB     INCF MSDWriteState, F
1303:                      break;
0E41  2DB0     GOTO 0x5B0
1304:                  } 
1305:                  
1306:                  default:
1307:                      //Illegal condition which should not occur.  If for some reason it
1308:                      //does, try to let the host know know an error has occurred.
1309:                      msd_csw.bCSWStatus=0x02;    //Phase Error
0E42  3002     MOVLW 0x2
0E43  00EC     MOVWF 0x16C
0E44  2D96     GOTO 0x596
1310:                      USBStallEndpoint(MSD_DATA_OUT_EP, OUT_FROM_HOST);
1311:                      MSDWriteState = MSD_WRITE10_WAIT;
1312:                      break;
1313:              }
1314:              
1315:              return MSDWriteState;
1316:          }
0E50  0008     RETURN
1317:          
1318:          
1319:          
1320:          /******************************************************************************
1321:           	Function:
1322:           		void ResetSenseData(void)
1323:           		
1324:           	Description:
1325:           		This routine resets the Sense Data, initializing the
1326:           		structure RequestSenseResponse gblSenseData.
1327:           		
1328:           	PreCondition:
1329:           		None 
1330:           		
1331:           	Parameters:
1332:           		None
1333:           		
1334:           	Return Values:
1335:           		None
1336:           		
1337:           	Remarks:
1338:           		None
1339:           			
1340:            *****************************************************************************/
1341:          void ResetSenseData(void) 
1342:          {
1343:              gblSenseData[LUN_INDEX].ResponseCode=S_CURRENT;
053D  0023     MOVLB 0x3
053E  083F     MOVF gblSenseData, W
053F  3980     ANDLW 0x80
0540  3870     IORLW 0x70
0541  00BF     MOVWF gblSenseData
1344:              gblSenseData[LUN_INDEX].VALID=0;			// no data in the information field
0543  13BF     BCF gblSenseData, 0x7
1345:              gblSenseData[LUN_INDEX].Obsolete=0x0;
0544  01C0     CLRF 0x1C0
1346:              gblSenseData[LUN_INDEX].SenseKey=S_NO_SENSE;
0542  30F0     MOVLW 0xF0
0545  05C1     ANDWF 0x1C1, F
1347:              //gblSenseData.Resv;
1348:              gblSenseData[LUN_INDEX].ILI=0;
0547  12C1     BCF 0x1C1, 0x5
1349:              gblSenseData[LUN_INDEX].EOM=0;
0548  1341     BCF 0x1C1, 0x6
1350:              gblSenseData[LUN_INDEX].FILEMARK=0;
0549  13C1     BCF 0x1C1, 0x7
1351:              gblSenseData[LUN_INDEX].InformationB0=0x00;
054A  01C2     CLRF 0x1C2
1352:              gblSenseData[LUN_INDEX].InformationB1=0x00;
054B  01C3     CLRF 0x1C3
1353:              gblSenseData[LUN_INDEX].InformationB2=0x00;
054C  01C4     CLRF 0x1C4
1354:              gblSenseData[LUN_INDEX].InformationB3=0x00;
054D  01C5     CLRF 0x1C5
1355:              gblSenseData[LUN_INDEX].AddSenseLen=0x0a;	// n-7 (n=17 (0..17))
0546  300A     MOVLW 0xA
054E  00C6     MOVWF 0x1C6
1356:              gblSenseData[LUN_INDEX].CmdSpecificInfo.Val=0x0;
054F  01C7     CLRF 0x1C7
0550  01C8     CLRF 0x1C8
0551  01C9     CLRF 0x1C9
0552  01CA     CLRF 0x1CA
1357:              gblSenseData[LUN_INDEX].ASC=0x0;
0553  01CB     CLRF 0x1CB
1358:              gblSenseData[LUN_INDEX].ASCQ=0x0;
0554  01CC     CLRF 0x1CC
1359:              gblSenseData[LUN_INDEX].FRUC=0x0;
0555  01CD     CLRF 0x1CD
1360:              gblSenseData[LUN_INDEX].SenseKeySpecific[0]=0x0;
0556  01CE     CLRF 0x1CE
1361:              gblSenseData[LUN_INDEX].SenseKeySpecific[1]=0x0;
0557  01CF     CLRF 0x1CF
1362:              gblSenseData[LUN_INDEX].SenseKeySpecific[2]=0x0;
0558  01D0     CLRF 0x1D0
1363:          }
0559  0008     RETURN
1364:          
1365:          
1366:          
1367:          /******************************************************************************
1368:           	Function:
1369:           		uint8_t MSDCheckForErrorCases(uint32_t DeviceBytes)
1370:           		
1371:           	Description:
1372:           	   This function can be called to check for various error cases, primarily 
1373:           	   the "Thirteen Cases" errors described in the MSD BOT v1.0 specs.  If an
1374:           	   error is detected, the function internally calls the MSDErrorHandler()
1375:           	   handler function, to take care of appropriately responding to the host, 
1376:           	   based on the error condition.
1377:           	PreCondition:
1378:           	    None
1379:           	     		
1380:           	Parameters:
1381:           		uint32_t DeviceBytes - Input: This is the total number of bytes the MSD 
1382:           		            device firmware is expecting in the MSD transfer.  
1383:           	Return Values:
1384:           		uint8_t - Returns a byte containing the error code.  The possible error
1385:           		    cases that can be detected and reported are:
1386:                      MSD_ERROR_CASE_NO_ERROR - None of the "Thirteen cases" errors were detected
1387:                      MSD_ERROR_CASE_2 	            
1388:                      MSD_ERROR_CASE_3 	            
1389:                      MSD_ERROR_CASE_4 	            
1390:                      MSD_ERROR_CASE_5 	            
1391:                      MSD_ERROR_CASE_7 	            
1392:                      MSD_ERROR_CASE_8 	            
1393:                      MSD_ERROR_CASE_9 	            
1394:                      MSD_ERROR_CASE_11               
1395:                      MSD_ERROR_CASE_10               
1396:                      MSD_ERROR_CASE_13               
1397:           		
1398:           	Remarks:
1399:           		None
1400:           			
1401:            *****************************************************************************/
1402:          uint8_t MSDCheckForErrorCases(uint32_t DeviceBytes)
1403:          {
1404:              uint8_t MSDErrorCase;
1405:              bool HostMoreDataThanDevice;
1406:              bool DeviceNoData;
1407:            
1408:              //Check if device is expecting no data (Dn)
1409:              if(DeviceBytes == 0)
0EF0  087A     MOVF 0x1FA, W
0EF1  0479     IORWF 0x1F9, W
0EF2  0478     IORWF 0x1F8, W
0EF3  0477     IORWF 0x1F7, W
0EF4  1D03     BTFSS STATUS, 0x2
0EF5  2EF9     GOTO 0x6F9
1410:              {
1411:                  DeviceNoData = true;
0EF6  01FC     CLRF 0x1FC
0EF7  0AFC     INCF 0x1FC, F
1412:              }    
0EF8  2EFA     GOTO 0x6FA
1413:              else
1414:              {
1415:                  DeviceNoData = false;
0EF9  01FC     CLRF 0x1FC
1416:              }     
1417:              
1418:              //First check for the three good/non-error cases
1419:              
1420:              //Check for good case: Hn = Dn (Case 1)
1421:              if((MSDHostNoData == true) && (DeviceNoData == true))
0EFA  0022     MOVLB 0x2
0EFB  0B48     DECFSZ MSDHostNoData, W
0EFC  2F0F     GOTO 0x70F
0EFD  0B7C     DECFSZ 0x17C, W
0EFE  2F0F     GOTO 0x70F
0EFF  3400     RETLW 0x0
1422:              {
1423:                  return MSD_ERROR_CASE_NO_ERROR;
0F0D  3400     RETLW 0x0
1424:              }    
1425:          
1426:              //Check for good cases where the data sizes between host and device match
1427:              if(gblCBW.dCBWDataTransferLength == DeviceBytes)
0F0F  087A     MOVF 0x17A, W
0F10  0023     MOVLB 0x3
0F11  062B     XORWF 0x1AB, W
0F12  1D03     BTFSS STATUS, 0x2
0F13  2F1E     GOTO 0x71E
0F14  0879     MOVF 0x1F9, W
0F15  062A     XORWF 0x1AA, W
0F16  1D03     BTFSS STATUS, 0x2
0F17  2F1E     GOTO 0x71E
0F18  0878     MOVF 0x1F8, W
0F19  0629     XORWF 0x1A9, W
0F1A  1D03     BTFSS STATUS, 0x2
0F1B  2F1E     GOTO 0x71E
0F1C  0877     MOVF 0x1F7, W
0F1D  0628     XORWF 0x1A8, W
0F1E  1903     BTFSC STATUS, 0x2
0F1F  2F00     GOTO 0x700
1428:              {
1429:                  //Check for good case: Hi = Di (Case 6)
1430:                  if(MSD_State == MSD_DATA_IN)
0F00  0022     MOVLB 0x2
0F01  0B4D     DECFSZ MSD_State, W
0F02  2F09     GOTO 0x709
1431:                  {
1432:                      //Make sure Hi = Di, instead of Hi = Do
1433:                      if(MSDCommandState != MSD_WRITE_10)
0F03  302A     MOVLW 0x2A
0F04  0021     MOVLB 0x1
0F05  0666     XORWF MSDCommandState, W
0F06  1D03     BTFSS STATUS, 0x2
0F07  3400     RETLW 0x0
0F08  2F20     GOTO 0x720
1434:                      {
1435:                          return MSD_ERROR_CASE_NO_ERROR;
1436:                      }    
1437:                  }
1438:                  else //if(MSD_State == MSD_DATA_OUT)  
1439:                  {
1440:                      //Check for good case: Ho = Do (Case 12)
1441:                      //Make sure Ho = Do, instead of Ho = Di
1442:                      if(MSDCommandState == MSD_WRITE_10)
0F09  302A     MOVLW 0x2A
0F0A  0021     MOVLB 0x1
0F0B  0666     XORWF MSDCommandState, W
0F0C  1903     BTFSC STATUS, 0x2
0F0E  2F20     GOTO 0x720
1443:                      {
1444:                          return MSD_ERROR_CASE_NO_ERROR;
1445:                      }             
1446:                  }      
1447:              }    
1448:          
1449:              //If we get to here, this implies some kind of error is occurring.  Do some
1450:              //checks to find out which error occurred, so we know how to handle it.
1451:          
1452:              //Check if the host is expecting to transfer more bytes than the device. (Hx > Dx)
1453:              if(gblCBW.dCBWDataTransferLength > DeviceBytes)
0F20  0023     MOVLB 0x3
0F21  082B     MOVF 0x1AB, W
0F22  027A     SUBWF 0x1FA, W
0F23  1D03     BTFSS STATUS, 0x2
0F24  2F2F     GOTO 0x72F
0F25  082A     MOVF 0x1AA, W
0F26  0279     SUBWF 0x1F9, W
0F27  1D03     BTFSS STATUS, 0x2
0F28  2F2F     GOTO 0x72F
0F29  0829     MOVF 0x1A9, W
0F2A  0278     SUBWF 0x1F8, W
0F2B  1D03     BTFSS STATUS, 0x2
0F2C  2F2F     GOTO 0x72F
0F2D  0828     MOVF 0x1A8, W
0F2E  0277     SUBWF 0x1F7, W
0F30  1C03     BTFSS STATUS, 0x0
1454:              {
1455:                  HostMoreDataThanDevice = true;
0F2F  01FB     CLRF 0x1FB
0F31  0AFB     INCF 0x1FB, F
1456:              }   
1457:              else
1458:              {
1459:                  HostMoreDataThanDevice = false;
1460:              } 
1461:           
1462:              //Check host's expected data direction
1463:          	if(MSD_State == MSD_DATA_OUT)
0F32  3002     MOVLW 0x2
0F33  0022     MOVLB 0x2
0F34  064D     XORWF MSD_State, W
0F36  1D03     BTFSS STATUS, 0x2
0F37  2F4E     GOTO 0x74E
1464:          	{
1465:              	//First check for Ho <> Di (Case 10)
1466:              	if((MSDCommandState != MSD_WRITE_10) && (DeviceNoData == false))
0F35  302A     MOVLW 0x2A
0F38  0021     MOVLB 0x1
0F39  0666     XORWF MSDCommandState, W
0F3A  1903     BTFSC STATUS, 0x2
0F3B  2F41     GOTO 0x741
0F3C  087C     MOVF 0xFC, W
0F3D  1D03     BTFSS STATUS, 0x2
0F3E  2F41     GOTO 0x741
1467:              	    MSDErrorCase = MSD_ERROR_CASE_10;
0F3F  3005     MOVLW 0x5
0F40  2F5E     GOTO 0x75E
1468:             	   	//Check for Hn < Do  (Case 3)
1469:              	else if(MSDHostNoData == true)  
0F41  0022     MOVLB 0x2
0F42  0B48     DECFSZ MSDHostNoData, W
0F43  2F47     GOTO 0x747
1470:              	    MSDErrorCase = MSD_ERROR_CASE_3;
0F44  01FD     CLRF 0x17D
0F45  0AFD     INCF 0x17D, F
0F46  2F5F     GOTO 0x75F
1471:              	//Check for Ho > Dn  (Case 9)
1472:              	else if(DeviceNoData == true)
0F47  0B7C     DECFSZ 0x17C, W
0F48  2F4B     GOTO 0x74B
1473:              	    MSDErrorCase = MSD_ERROR_CASE_9;
0F49  3004     MOVLW 0x4
0F4A  2F5E     GOTO 0x75E
1474:              	//Check for Ho > Do  (Case 11)
1475:              	else if(HostMoreDataThanDevice == true)
0F4B  0B7B     DECFSZ 0x17B, W
0F4C  2F3F     GOTO 0x73F
0F4D  2F49     GOTO 0x749
1476:              	    MSDErrorCase = MSD_ERROR_CASE_11;
1477:              	//Check for Ho < Do  (Case 13)
1478:              	else //if(gblCBW.dCBWDataTransferLength < DeviceBytes)
1479:              	    MSDErrorCase = MSD_ERROR_CASE_13;
1480:              }    
1481:              else //else the MSD_State must be == MSD_DATA_IN
1482:              {
1483:              	//First check for Hi <> Do (Case 8)
1484:              	if(MSDCommandState == MSD_WRITE_10)
0F4E  0021     MOVLB 0x1
0F4F  0666     XORWF MSDCommandState, W
0F50  1D03     BTFSS STATUS, 0x2
0F51  2F54     GOTO 0x754
1485:              	    MSDErrorCase = MSD_ERROR_CASE_8;    	
0F52  3003     MOVLW 0x3
0F53  2F5E     GOTO 0x75E
1486:              	//Check for Hn < Di  (Case 2)
1487:              	else if(MSDHostNoData == true)  
0F54  0022     MOVLB 0x2
0F55  0B48     DECFSZ MSDHostNoData, W
0F56  2F58     GOTO 0x758
0F57  2F44     GOTO 0x744
1488:              	    MSDErrorCase = MSD_ERROR_CASE_2;
1489:              	//Check for Hi > Dn  (Case 4)
1490:              	else if(DeviceNoData == true)
0F58  0B7C     DECFSZ 0x17C, W
0F59  2F5B     GOTO 0x75B
0F5A  2F5D     GOTO 0x75D
1491:              	    MSDErrorCase = MSD_ERROR_CASE_4;
0F5D  3002     MOVLW 0x2
0F5E  00FD     MOVWF 0x17D
1492:              	//Check for Hi > Di  (Case 5)
1493:              	else if(HostMoreDataThanDevice == true)
0F5B  0B7B     DECFSZ 0x17B, W
0F5C  2F52     GOTO 0x752
1494:              	    MSDErrorCase = MSD_ERROR_CASE_5;
1495:                  //Check for Hi < Di  (Case 7)
1496:              	else //if(gblCBW.dCBWDataTransferLength < DeviceBytes)
1497:              	    MSDErrorCase = MSD_ERROR_CASE_7;
1498:              }        
1499:              //Now call the MSDErrorHandler(), based on the error that was detected.
1500:              MSDErrorHandler(MSDErrorCase);
0F5F  087D     MOVF 0x17D, W
0F60  2512     CALL 0x512
1501:              return MSDErrorCase;
0F61  087D     MOVF 0x17D, W
1502:          }    
0F62  0008     RETURN
1503:          
1504:          
1505:          /******************************************************************************
1506:           	Function:
1507:           		void MSDErrorHandler(uint8_t ErrorCase)
1508:           		
1509:           	Description:
1510:           	    Once an error condition has been detected, this function can be called
1511:           	    to set the proper states and perform the proper tasks needed to let the
1512:           	    host know about the error.
1513:           	PreCondition:
1514:           		Firmware should have already determined an error occurred, and it should
1515:           		know what the error code was before calling this handler.
1516:           		
1517:           	Parameters:
1518:           		uint8_t ErrorCase - Input: This is the error code that the firmware 
1519:           		                    detected.  This error code will determine how the
1520:           		                    handler will behave (ex: what status to send to host,
1521:           		                    what endpoint(s) should be stalled, etc.).
1522:           		                    The implemented error case possibilities are (suffix
1523:           		                    numbers correspond to the "Thirteen cases" numbers 
1524:           		                    described in the MSD BOT specs v1.0):
1525:           		                    
1526:                                      MSD_ERROR_CASE_2 	            
1527:                                      MSD_ERROR_CASE_3 	            
1528:                                      MSD_ERROR_CASE_4 	            
1529:                                      MSD_ERROR_CASE_5 	            
1530:                                      MSD_ERROR_CASE_7 	            
1531:                                      MSD_ERROR_CASE_8 	            
1532:                                      MSD_ERROR_CASE_9 	            
1533:                                      MSD_ERROR_CASE_11               
1534:                                      MSD_ERROR_CASE_10               
1535:                                      MSD_ERROR_CASE_13               
1536:                                      MSD_ERROR_UNSUPPORTED_COMMAND   
1537:          
1538:           	Return Values:
1539:           		None
1540:           		
1541:           	Remarks:
1542:           		None
1543:           			
1544:            *****************************************************************************/
1545:          void MSDErrorHandler(uint8_t ErrorCase)
0D12  00F5     MOVWF 0x175
1546:          {
1547:              uint8_t OldMSD_State;
1548:              
1549:              //Both MSD bulk IN and OUT endpoints should not be busy when these error cases are detected
1550:              //If for some reason this isn't true, then we should preserve the state machines states for now.
1551:              if((USBHandleBusy(USBMSDInHandle)) || (USBHandleBusy(USBMSDOutHandle)))
0D13  0021     MOVLB 0x1
0D14  0865     MOVF USBMSDInHandle, W
0D15  1903     BTFSC STATUS, 0x2
0D16  2D1C     GOTO 0x51C
0D17  0865     MOVF USBMSDInHandle, W
0D18  0086     MOVWF FSR1L
0D19  0187     CLRF FSR1H
0D1A  1B81     BTFSC INDF1, 0x7
0D1B  0008     RETURN
0D1C  086D     MOVF USBMSDOutHandle, W
0D1D  1903     BTFSC STATUS, 0x2
0D1E  2D24     GOTO 0x524
0D1F  086D     MOVF USBMSDOutHandle, W
0D20  0086     MOVWF FSR1L
0D21  0187     CLRF FSR1H
0D22  1B81     BTFSC INDF1, 0x7
0D23  0008     RETURN
1552:              {
1553:              	return;	
1554:              }
1555:          
1556:              //Save the old state before we change it.  The old state is needed to determine
1557:              //the proper handling behavior in the case of receiving unsupported commands.
1558:              OldMSD_State = MSD_State;
0D24  0022     MOVLB 0x2
0D25  084D     MOVF MSD_State, W
0D26  00F6     MOVWF 0x176
1559:          
1560:              //Reset main state machines back to idle values.
1561:              MSDCommandState = MSD_COMMAND_WAIT;
0D27  30FF     MOVLW 0xFF
0D28  0021     MOVLB 0x1
0D29  00E6     MOVWF MSDCommandState
1562:              MSDReadState = MSD_READ10_WAIT;
0D2A  0022     MOVLB 0x2
0D2C  01CC     CLRF MSDReadState
1563:              MSDWriteState = MSD_WRITE10_WAIT;
0D2D  01CB     CLRF MSDWriteState
0D2E  27DC     CALL 0x7DC
0D2F  318B     MOVLP 0xB
1564:              //After the conventional 13 test cases failures, the host still expects a valid CSW packet
1565:              msd_csw.dCSWDataResidue = gblCBW.dCBWDataTransferLength; //Indicate the un-consumed/unsent data
0D2B  3008     MOVLW 0x8
0D30  00E8     MOVWF 0x168
0D31  3F41     MOVIW 1[FSR1]
0D32  00E9     MOVWF 0x169
0D33  3F42     MOVIW 2[FSR1]
0D34  00EA     MOVWF 0x16A
0D35  3F43     MOVIW 3[FSR1]
0D36  00EB     MOVWF 0x16B
1566:              msd_csw.bCSWStatus = MSD_CSW_COMMAND_FAILED;    //Gets changed later to phase error for errors that user phase error
0D37  3001     MOVLW 0x1
0D38  00EC     MOVWF 0x16C
1567:              MSD_State = MSD_SEND_CSW;
0D39  3003     MOVLW 0x3
0D3A  00CD     MOVWF MSD_State
1568:          
1569:              //Now do other error related handling tasks, which depend on the specific 
1570:              //error	type that was detected.
1571:              switch(ErrorCase)
0D3B  0875     MOVF 0x175, W
0D3C  3A01     XORLW 0x1
0D3D  1903     BTFSC STATUS, 0x2
0D3E  2D4F     GOTO 0x54F
0D3F  3A03     XORLW 0x3
0D40  1903     BTFSC STATUS, 0x2
0D41  2D52     GOTO 0x552
0D42  3A01     XORLW 0x1
0D43  1903     BTFSC STATUS, 0x2
0D44  2D57     GOTO 0x557
0D45  3A07     XORLW 0x7
0D46  1903     BTFSC STATUS, 0x2
0D47  2D5A     GOTO 0x55A
0D48  3A01     XORLW 0x1
0D49  1903     BTFSC STATUS, 0x2
0D4A  2D5E     GOTO 0x55E
0D4B  3A7A     XORLW 0x7A
0D4C  1903     BTFSC STATUS, 0x2
0D4D  2D64     GOTO 0x564
0D4E  2D7D     GOTO 0x57D
1572:              {
1573:                  case MSD_ERROR_CASE_2://Also CASE_3
1574:                      msd_csw.bCSWStatus = MSD_CSW_PHASE_ERROR;
0D4F  3002     MOVLW 0x2
0D50  00EC     MOVWF 0x16C
1575:                      break;
0D51  0008     RETURN
1576:          
1577:                  case MSD_ERROR_CASE_4://Also CASE_5
1578:                      USBStallEndpoint(MSD_DATA_IN_EP, IN_TO_HOST);	//STALL the bulk IN MSD endpoint
0D52  3001     MOVLW 0x1
0D53  01F0     CLRF 0x170
0D54  0AF0     INCF 0x170, F
0D55  3182     MOVLP 0x2
0D56  2A6B     GOTO 0x26B
1579:                      break;
1580:          
1581:                  case MSD_ERROR_CASE_7://Also CASE_8
1582:                      msd_csw.bCSWStatus = MSD_CSW_PHASE_ERROR;
0D57  27B2     CALL 0x7B2
1583:                      USBStallEndpoint(MSD_DATA_IN_EP, IN_TO_HOST);	//STALL the bulk IN MSD endpoint
0D58  3182     MOVLP 0x2
0D59  2A6B     GOTO 0x26B
1584:                      break;
1585:          
1586:                  case MSD_ERROR_CASE_9://Also CASE_11
1587:                      USBStallEndpoint(MSD_DATA_OUT_EP, OUT_FROM_HOST); //Stall the bulk OUT endpoint
0D5A  3001     MOVLW 0x1
0D5B  01F0     CLRF 0x170
0D5C  3182     MOVLP 0x2
0D5D  2A6B     GOTO 0x26B
1588:                      break;
1589:          
1590:                  case MSD_ERROR_CASE_10://Also CASE_13
1591:                      msd_csw.bCSWStatus = MSD_CSW_PHASE_ERROR;
0D5E  3002     MOVLW 0x2
0D5F  00EC     MOVWF 0x16C
1592:                      USBStallEndpoint(MSD_DATA_OUT_EP, OUT_FROM_HOST);
0D60  3001     MOVLW 0x1
0D61  01F0     CLRF 0x170
0D62  3182     MOVLP 0x2
0D63  2A6B     GOTO 0x26B
1593:                      break;
1594:          
1595:                  case MSD_ERROR_UNSUPPORTED_COMMAND:
1596:                      ResetSenseData();
0D64  3185     MOVLP 0x5
0D65  253D     CALL 0x53D
0D66  318B     MOVLP 0xB
0D67  27AB     CALL 0x7AB
0D68  318B     MOVLP 0xB
1597:                      gblSenseData[LUN_INDEX].SenseKey=S_ILLEGAL_REQUEST;
1598:                      gblSenseData[LUN_INDEX].ASC=ASC_INVALID_COMMAND_OPCODE;
1599:                      gblSenseData[LUN_INDEX].ASCQ=ASCQ_INVALID_COMMAND_OPCODE;
0D6A  01CC     CLRF MSDReadState
1600:                      
1601:                      if((OldMSD_State == MSD_DATA_OUT) && (gblCBW.dCBWDataTransferLength != 0))
0D69  3002     MOVLW 0x2
0D6B  0676     XORWF 0x176, W
0D6C  1D03     BTFSS STATUS, 0x2
0D6D  2D78     GOTO 0x578
0D6E  082B     MOVF 0x12B, W
0D6F  042A     IORWF 0x12A, W
0D70  0429     IORWF 0x129, W
0D71  0428     IORWF 0x128, W
0D73  1903     BTFSC STATUS, 0x2
0D74  2D79     GOTO 0x579
1602:                      {
1603:                          USBStallEndpoint(MSD_DATA_OUT_EP, OUT_FROM_HOST);
0D72  3001     MOVLW 0x1
0D75  01F0     CLRF 0x170
0D76  3182     MOVLP 0x2
0D77  2A6B     GOTO 0x26B
1604:                      }
1605:                      else
1606:                      {
1607:                          USBStallEndpoint(MSD_DATA_IN_EP, IN_TO_HOST);
0D78  3001     MOVLW 0x1
0D79  01F0     CLRF 0x170
0D7A  0AF0     INCF 0x170, F
0D7B  3182     MOVLP 0x2
0D7C  2A6B     GOTO 0x26B
1608:                      }
1609:                      break;
1610:                  default:	//Shouldn't get hit, don't call MSDErrorHandler() if there is no error
1611:                      break;
1612:              }//switch(ErrorCase)
1613:          }	
0D7D  0008     RETURN
1614:          
1615:          
1616:          
1617:          //-----------------------------------------------------------------------------------------
1618:          #endif //end of #ifdef USB_USE_MSD
1619:          //End of file usb_device_msd.c
---  /home/phil/Projects/XPRESS-Loader/framework/usb/src/usb_device.c  ----------------------------------
1:             // DOM-IGNORE-BEGIN
2:             /*******************************************************************************
3:             Copyright 2015 Microchip Technology Inc. (www.microchip.com)
4:             
5:             Licensed under the Apache License, Version 2.0 (the "License");
6:             you may not use this file except in compliance with the License.
7:             You may obtain a copy of the License at
8:             
9:                 http://www.apache.org/licenses/LICENSE-2.0
10:            
11:            Unless required by applicable law or agreed to in writing, software
12:            distributed under the License is distributed on an "AS IS" BASIS,
13:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
14:            See the License for the specific language governing permissions and
15:            limitations under the License.
16:            
17:            To request to license the code under the MLA license (www.microchip.com/mla_license), 
18:            please contact mla_licensing@microchip.com
19:            *******************************************************************************/
20:            //DOM-IGNORE-END
21:            
22:            /*******************************************************************************
23:              USB Device Layer
24:            
25:              Company:
26:                Microchip Technology Inc.
27:            
28:              File Name:
29:                usb_device.c
30:            
31:              Summary:
32:               Provides basic USB device functionality, including enumeration and USB
33:               chapter 9 required behavior.
34:            
35:              Description:
36:               Provides basic USB device functionality, including enumeration and USB
37:               chapter 9 required behavior.
38:            *******************************************************************************/
39:            
40:            // *****************************************************************************
41:            // *****************************************************************************
42:            // Section: Included Files
43:            // *****************************************************************************
44:            // *****************************************************************************
45:            #include <stdint.h>
46:            #include <stddef.h>
47:            
48:            #include "system.h"
49:            #include "system_config.h"
50:            
51:            #include "usb.h"
52:            #include "usb_ch9.h"
53:            #include "usb_device.h"
54:            #include "usb_device_local.h"
55:            
56:            #if defined(USB_USE_MSD)
57:                #include "usb_device_msd.h"
58:            #endif
59:            
60:            // *****************************************************************************
61:            // *****************************************************************************
62:            // Section: File Scope or Global Constants
63:            // *****************************************************************************
64:            // *****************************************************************************
65:            #if !defined(USE_USB_BUS_SENSE_IO)
66:                //Assume the +5V VBUS is always present (like it would be in a bus powered
67:                //only application), unless USE_USB_BUS_SENSE_IO and USB_BUS_SENSE have
68:                //been properly defined elsewhere in the project.
69:                #undef USB_BUS_SENSE
70:                #define USB_BUS_SENSE 1
71:            #endif
72:            
73:            #if defined(USB_DEVICE_DISABLE_DTS_CHECKING)
74:                #define _DTS_CHECKING_ENABLED 0
75:            #else
76:                #define _DTS_CHECKING_ENABLED _DTSEN
77:            #endif
78:            
79:            #if !defined(self_power)
80:                //Assume the application is always bus powered, unless self_power has been
81:                //defined elsewhere in the project
82:                #define self_power 0    //0 = bus powered
83:            #endif
84:            
85:            #if !defined(USB_MAX_NUM_CONFIG_DSC)
86:                //Assume the application only implements one configuration descriptor,
87:                //unless otherwise specified elsewhere in the project
88:                #define USB_MAX_NUM_CONFIG_DSC      1
89:            #endif
90:            
91:            #if defined(__XC8)
92:                //Suppress expected/harmless compiler warning message about unused RAM variables
93:                //and certain function pointer usage.
94:                //Certain variables and function pointers are not used if you don't use all
95:                //of the USB stack APIs.  However, these variables should not be
96:                //removed (since they are still used/needed in some applications, and this
97:                //is a common file shared by many projects, some of which rely on the "unused"
98:                //variables/function pointers).
99:                #pragma warning disable 1090
100:               #if __XC8_VERSION > 1300
101:                   #pragma warning disable 1471
102:               #endif
103:           #endif
104:           
105:           // *****************************************************************************
106:           // *****************************************************************************
107:           // Section: File Scope Data Types
108:           // *****************************************************************************
109:           // *****************************************************************************
110:           typedef union
111:           {
112:               uint8_t Val;
113:               struct __PACKED
114:               {
115:                   unsigned b0:1;
116:                   unsigned b1:1;
117:                   unsigned b2:1;
118:                   unsigned b3:1;
119:                   unsigned b4:1;
120:                   unsigned b5:1;
121:                   unsigned b6:1;
122:                   unsigned b7:1;
123:               } bits;
124:           } uint8_t_VAL, uint8_t_BITS;
125:           
126:           // *****************************************************************************
127:           // *****************************************************************************
128:           // Section: Variables
129:           // *****************************************************************************
130:           // *****************************************************************************
131:           USB_VOLATILE USB_DEVICE_STATE USBDeviceState;
132:           USB_VOLATILE uint8_t USBActiveConfiguration;
133:           USB_VOLATILE uint8_t USBAlternateInterface[USB_MAX_NUM_INT];
134:           volatile BDT_ENTRY *pBDTEntryEP0OutCurrent;
135:           volatile BDT_ENTRY *pBDTEntryEP0OutNext;
136:           volatile BDT_ENTRY *pBDTEntryOut[USB_MAX_EP_NUMBER+1];
137:           volatile BDT_ENTRY *pBDTEntryIn[USB_MAX_EP_NUMBER+1];
138:           USB_VOLATILE uint8_t shortPacketStatus;
139:           USB_VOLATILE uint8_t controlTransferState;
140:           USB_VOLATILE IN_PIPE inPipes[1];
141:           USB_VOLATILE OUT_PIPE outPipes[1];
142:           USB_VOLATILE uint8_t *pDst;
143:           USB_VOLATILE bool RemoteWakeup;
144:           USB_VOLATILE bool USBBusIsSuspended;
145:           USB_VOLATILE USTAT_FIELDS USTATcopy;
146:           USB_VOLATILE uint8_t endpoint_number;
147:           USB_VOLATILE bool BothEP0OutUOWNsSet;
148:           USB_VOLATILE EP_STATUS ep_data_in[USB_MAX_EP_NUMBER+1];
149:           USB_VOLATILE EP_STATUS ep_data_out[USB_MAX_EP_NUMBER+1];
150:           USB_VOLATILE uint8_t USBStatusStageTimeoutCounter;
151:           volatile bool USBDeferStatusStagePacket;
152:           volatile bool USBStatusStageEnabledFlag1;
153:           volatile bool USBStatusStageEnabledFlag2;
154:           volatile bool USBDeferINDataStagePackets;
155:           volatile bool USBDeferOUTDataStagePackets;
156:           USB_VOLATILE uint32_t USB1msTickCount;
157:           USB_VOLATILE uint8_t USBTicksSinceSuspendEnd;
158:           
159:           /** USB FIXED LOCATION VARIABLES ***********************************/
160:           #if defined(COMPILER_MPLAB_C18)
161:               #pragma udata USB_BDT=USB_BDT_ADDRESS
162:           #endif
163:           
164:           volatile BDT_ENTRY BDT[BDT_NUM_ENTRIES] BDT_BASE_ADDR_TAG;
165:           
166:           /********************************************************************
167:            * EP0 Buffer Space
168:            *******************************************************************/
169:           volatile CTRL_TRF_SETUP SetupPkt CTRL_TRF_SETUP_ADDR_TAG;
170:           volatile uint8_t CtrlTrfData[USB_EP0_BUFF_SIZE] CTRL_TRF_DATA_ADDR_TAG;
171:           
172:           
173:           //Depricated in v2.2 - will be removed in a future revision
174:           #if !defined(USB_USER_DEVICE_DESCRIPTOR)
175:               //Device descriptor
176:               extern const USB_DEVICE_DESCRIPTOR device_dsc;
177:           #else
178:               USB_USER_DEVICE_DESCRIPTOR_INCLUDE;
179:           #endif
180:           
181:           #if !defined(USB_USER_CONFIG_DESCRIPTOR)
182:               //Array of configuration descriptors
183:               extern const uint8_t *const USB_CD_Ptr[];
184:           #else
185:               USB_USER_CONFIG_DESCRIPTOR_INCLUDE;
186:           #endif
187:           
188:           extern const uint8_t *const USB_SD_Ptr[];
189:           
190:           
191:           // *****************************************************************************
192:           // *****************************************************************************
193:           // Section: Private and External Prototypes
194:           // *****************************************************************************
195:           // *****************************************************************************
196:           extern bool USER_USB_CALLBACK_EVENT_HANDLER(USB_EVENT event, void *pdata, uint16_t size);
197:           
198:           static void USBCtrlEPService(void);
199:           static void USBCtrlTrfSetupHandler(void);
200:           static void USBCtrlTrfInHandler(void);
201:           static void USBCheckStdRequest(void);
202:           static void USBStdGetDscHandler(void);
203:           static void USBCtrlEPServiceComplete(void);
204:           static void USBCtrlTrfTxService(void);
205:           static void USBCtrlTrfRxService(void);
206:           static void USBStdSetCfgHandler(void);
207:           static void USBStdGetStatusHandler(void);
208:           static void USBStdFeatureReqHandler(void);
209:           static void USBCtrlTrfOutHandler(void);
210:           static void USBConfigureEndpoint(uint8_t EPNum, uint8_t direction);
211:           static void USBWakeFromSuspend(void);
212:           static void USBSuspend(void);
213:           static void USBStallHandler(void);
214:           
215:           // *****************************************************************************
216:           // *****************************************************************************
217:           // Section: Macros or Functions
218:           // *****************************************************************************
219:           // *****************************************************************************
220:           
221:           /****************************************************************************
222:             Function:
223:               void USBAdvancePingPongBuffer(BDT_ENTRY** buffer)
224:           
225:             Description:
226:               This function will advance the passed pointer to the next buffer based on
227:               the ping pong option setting.  This function should be used for EP1-EP15
228:               only.  This function is not valid for EP0.
229:           
230:             Precondition:
231:               None
232:           
233:             Parameters:
234:               BDT_ENTRY** - pointer to the BDT_ENTRY pointer that you want to be advanced
235:               to the next buffer state
236:           
237:             Return Values:
238:               None
239:           
240:             Remarks:
241:               None
242:           
243:             ***************************************************************************/
244:           #define USBAdvancePingPongBuffer(buffer) {((uint8_t_VAL*)buffer)->Val ^= USB_NEXT_PING_PONG;}
245:           #define USBHALPingPongSetToOdd(buffer)   {((uint8_t_VAL*)buffer)->Val |= USB_NEXT_PING_PONG;}
246:           #define USBHALPingPongSetToEven(buffer)  {((uint8_t_VAL*)buffer)->Val &= ~USB_NEXT_PING_PONG;}
247:           
248:           
249:           /**************************************************************************
250:               Function:
251:                   void USBDeviceInit(void)
252:               
253:               Description:
254:                   This function initializes the device stack it in the default state. The
255:                   USB module will be completely reset including all of the internal
256:                   variables, registers, and interrupt flags.
257:                           
258:               Precondition:
259:                   This function must be called before any of the other USB Device
260:                   functions can be called, including USBDeviceTasks().
261:                   
262:               Parameters:
263:                   None
264:                
265:               Return Values:
266:                   None
267:                   
268:               Remarks:
269:                   None
270:                                                                     
271:             ***************************************************************************/
272:           void USBDeviceInit(void)
273:           {
274:               uint8_t i;
275:           
276:               USBDisableInterrupts();
00E5  0021     MOVLB 0x1
00E6  1112     BCF PIE2, 0x2
277:           
278:               //Make sure that if a GPIO output driver exists on VBUS, that it is 
279:               //tri-stated to avoid potential contention with the host
280:               USB_HAL_VBUSTristate();
281:               
282:               // Clear all USB error flags
283:               USBClearInterruptRegister(U1EIR);  
00E7  003D     MOVLB 0x1D
00E8  0193     CLRF UEIR
284:                  
285:               // Clears all USB interrupts          
286:               USBClearInterruptRegister(U1IR); 
00E9  0190     CLRF UIR
287:           
288:               //Clear all of the endpoint control registers
289:               U1EP0 = 0;
00EA  0198     CLRF UEP0
290:               
291:               DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
00EB  300E     MOVLW 0xE
00EC  00F1     MOVWF 0xEF1
00ED  3099     MOVLW 0x99
00EE  00F0     MOVWF 0xEF0
00EF  01F2     CLRF 0xEF2
00F0  0870     MOVF 0xEF0, W
00F1  0086     MOVWF FSR1L
00F2  0871     MOVF 0xEF1, W
00F3  0087     MOVWF FSR1H
00F4  0181     CLRF INDF1
00F5  0AF0     INCF 0xEF0, F
00F6  1903     BTFSC STATUS, 0x2
00F7  0AF1     INCF 0xEF1, F
00F8  3003     MOVLW 0x3
00F9  0AF2     INCF 0xEF2, F
00FA  0272     SUBWF 0xEF2, W
00FB  1C03     BTFSS STATUS, 0x0
00FC  28F0     GOTO 0xF0
292:           
293:               SetConfigurationOptions();
00FD  3016     MOVLW 0x16
00FE  003D     MOVLB 0x1D
00FF  25B7     CALL 0x5B7
0100  3180     MOVLP 0x0
294:           
295:               //power up the module (if not already powered)
296:               USBPowerModule();
297:           
298:               //set the address of the BDT (if applicable)
299:               USBSetBDTAddress(BDT);
300:           
301:               //Clear all of the BDT entries
302:               for(i = 0; i < (sizeof(BDT)/sizeof(BDT_ENTRY)); i++)
0101  01F3     CLRF 0xEF3
010D  3010     MOVLW 0x10
010E  0AF3     INCF 0xEF3, F
010F  0273     SUBWF 0xEF3, W
0110  1C03     BTFSS STATUS, 0x0
0111  2902     GOTO 0x102
303:               {
304:                   BDT[i].Val = 0x00;
0102  0873     MOVF 0xEF3, W
0103  0709     ADDWF WREG, W
0104  0709     ADDWF WREG, W
0105  3E20     ADDLW 0x20
0106  0086     MOVWF FSR1L
0107  3000     MOVLW 0x0
0108  0187     CLRF FSR1H
0109  3FC0     MOVWI 0[FSR1]
010A  3FC1     MOVWI 1[FSR1]
010B  3FC2     MOVWI 2[FSR1]
010C  3FC3     MOVWI 3[FSR1]
305:               }
306:           
307:               // Assert reset request to all of the Ping Pong buffer pointers
308:               USBPingPongBufferReset = 1;                    
0112  003D     MOVLB 0x1D
0113  170E     BSF UCON, 0x6
309:           
310:               // Reset to default address
311:               U1ADDR = 0x00;                   
0114  0196     CLRF UADDR
312:           
313:               // Make sure packet processing is enabled
314:               USBPacketDisable = 0;           
0115  120E     BCF UCON, 0x4
315:           
316:               //Stop trying to reset ping pong buffer pointers
317:               USBPingPongBufferReset = 0;
0116  130E     BCF UCON, 0x6
318:           
319:               // Flush any pending transactions
320:               do
321:               {
322:                   USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
0117  1190     BCF UIR, 0x3
323:                   //Initialize USB stack software state variables
324:                   inPipes[0].info.Val = 0;
0118  0022     MOVLB 0x2
0119  01A9     CLRF 0x129
325:                   outPipes[0].info.Val = 0;
011A  01A2     CLRF 0x122
326:                   outPipes[0].wCount.Val = 0;
011B  01A3     CLRF 0x123
011C  01A4     CLRF 0x124
327:               }while(USBTransactionCompleteIF == 1);
011D  003D     MOVLB 0x1D
011E  1990     BTFSC UIR, 0x3
011F  2917     GOTO 0x117
328:           
329:               //Set flags to true, so the USBCtrlEPAllowStatusStage() function knows not to
330:               //try and arm a status stage, even before the first control transfer starts.
331:               USBStatusStageEnabledFlag1 = true;
0120  3001     MOVLW 0x1
0121  0022     MOVLB 0x2
0122  00D2     MOVWF USBStatusStageEnabledFlag1
332:               USBStatusStageEnabledFlag2 = true;
0123  00D1     MOVWF USBStatusStageEnabledFlag2
333:               //Initialize other flags
334:               USBDeferINDataStagePackets = false;
0124  01D0     CLRF USBDeferINDataStagePackets
335:               USBDeferOUTDataStagePackets = false;
0125  01CF     CLRF USBDeferOUTDataStagePackets
336:               USBBusIsSuspended = false;
0126  01D6     CLRF USBBusIsSuspended
337:           
338:               //Initialize all pBDTEntryIn[] and pBDTEntryOut[]
339:               //pointers to NULL, so they don't get used inadvertently.
340:               for(i = 0; i < (uint8_t)(USB_MAX_EP_NUMBER+1u); i++)
0127  01F3     CLRF 0x173
0139  3004     MOVLW 0x4
013B  0AF3     INCF 0x173, F
013C  0273     SUBWF 0x173, W
013D  1C03     BTFSS STATUS, 0x0
013E  2928     GOTO 0x128
341:               {
342:                   pBDTEntryIn[i] = 0u;
0128  0873     MOVF 0x173, W
0129  3E38     ADDLW 0x38
012A  0086     MOVWF FSR1L
012B  3001     MOVLW 0x1
012C  0087     MOVWF FSR1H
012D  0181     CLRF INDF1
343:                   pBDTEntryOut[i] = 0u;
012E  0873     MOVF 0x173, W
012F  3E3C     ADDLW 0x3C
0130  0086     MOVWF FSR1L
0131  0181     CLRF INDF1
344:                   ep_data_in[i].Val = 0u;
0132  0873     MOVF 0x173, W
0133  3ED5     ADDLW 0xD5
0134  0086     MOVWF FSR1L
0135  0181     CLRF INDF1
345:                   ep_data_out[i].Val = 0u;
0136  0873     MOVF 0x173, W
0137  3ED1     ADDLW 0xD1
0138  0086     MOVWF FSR1L
013A  0181     CLRF INDF1
346:               }
347:           
348:               //Get ready for the first packet
349:               pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
013F  3028     MOVLW 0x28
0140  0022     MOVLB 0x2
0141  00B8     MOVWF pBDTEntryIn
350:               // Initialize EP0 as a Ctrl EP
351:               U1EP0 = EP_CTRL|USB_HANDSHAKE_ENABLED;        
0142  3016     MOVLW 0x16
0143  003D     MOVLB 0x1D
0144  0098     MOVWF UEP0
352:           	//Prepare for the first SETUP on EP0 OUT
353:               BDT[EP0_OUT_EVEN].ADR = ConvertToPhysicalAddress(&SetupPkt);
0145  0020     MOVLB 0x0
0146  01A3     CLRF 0x23
0147  3060     MOVLW 0x60
0148  00A2     MOVWF 0x22
354:               BDT[EP0_OUT_EVEN].CNT = USB_EP0_BUFF_SIZE;
0149  3008     MOVLW 0x8
014A  00A1     MOVWF 0x21
355:               BDT[EP0_OUT_EVEN].STAT.Val = _DAT0|_BSTALL;
014B  3004     MOVLW 0x4
014C  00A0     MOVWF BDT
356:               BDT[EP0_OUT_EVEN].STAT.Val |= _USIE;
014D  17A0     BSF BDT, 0x7
357:           
358:               // Clear active configuration
359:               USBActiveConfiguration = 0;     
014E  0022     MOVLB 0x2
014F  01ED     CLRF USBActiveConfiguration
360:           
361:               USB1msTickCount = 0;            //Keeps track of total number of milliseconds since calling USBDeviceInit() when first initializing the USB module/stack code.
362:               USBTicksSinceSuspendEnd = 0;    //Keeps track of the number of milliseconds since a suspend condition has ended.
0150  01CE     CLRF USBTicksSinceSuspendEnd
363:           
364:               //Indicate that we are now in the detached state
365:               USBDeviceState = DETACHED_STATE;
0151  0021     MOVLB 0x1
0152  01EE     CLRF USBDeviceState
366:           }
0153  0008     RETURN
367:           
368:           
369:           
370:           /**************************************************************************
371:             Function:
372:                   void USBDeviceTasks(void)
373:               
374:             Summary:
375:               This function is the main state machine/transaction handler of the USB 
376:               device side stack.  When the USB stack is operated in "USB_POLLING" mode 
377:               (usb_config.h user option) the USBDeviceTasks() function should be called 
378:               periodically to receive and transmit packets through the stack. This 
379:               function also takes care of control transfers associated with the USB 
380:               enumeration process, and detecting various USB events (such as suspend).  
381:               This function should be called at least once every 1.8ms during the USB 
382:               enumeration process. After the enumeration process is complete (which can 
383:               be determined when USBGetDeviceState() returns CONFIGURED_STATE), the 
384:               USBDeviceTasks() handler may be called the faster of: either once 
385:               every 9.8ms, or as often as needed to make sure that the hardware USTAT 
386:               FIFO never gets full.  A good rule of thumb is to call USBDeviceTasks() at
387:               a minimum rate of either the frequency that USBTransferOnePacket() gets 
388:               called, or, once/1.8ms, whichever is faster.  See the inline code comments 
389:               near the top of usb_device.c for more details about minimum timing 
390:               requirements when calling USBDeviceTasks().
391:               
392:               When the USB stack is operated in "USB_INTERRUPT" mode, it is not necessary
393:               to call USBDeviceTasks() from the main loop context.  In the USB_INTERRUPT
394:               mode, the USBDeviceTasks() handler only needs to execute when a USB 
395:               interrupt occurs, and therefore only needs to be called from the interrupt 
396:               context.
397:           
398:             Description:
399:               This function is the main state machine/transaction handler of the USB 
400:               device side stack.  When the USB stack is operated in "USB_POLLING" mode 
401:               (usb_config.h user option) the USBDeviceTasks() function should be called 
402:               periodically to receive and transmit packets through the stack. This 
403:               function also takes care of control transfers associated with the USB 
404:               enumeration process, and detecting various USB events (such as suspend).  
405:               This function should be called at least once every 1.8ms during the USB 
406:               enumeration process. After the enumeration process is complete (which can 
407:               be determined when USBGetDeviceState() returns CONFIGURED_STATE), the 
408:               USBDeviceTasks() handler may be called the faster of: either once 
409:               every 9.8ms, or as often as needed to make sure that the hardware USTAT 
410:               FIFO never gets full.  A good rule of thumb is to call USBDeviceTasks() at
411:               a minimum rate of either the frequency that USBTransferOnePacket() gets 
412:               called, or, once/1.8ms, whichever is faster.  See the inline code comments 
413:               near the top of usb_device.c for more details about minimum timing 
414:               requirements when calling USBDeviceTasks().
415:               
416:               When the USB stack is operated in "USB_INTERRUPT" mode, it is not necessary
417:               to call USBDeviceTasks() from the main loop context.  In the USB_INTERRUPT
418:               mode, the USBDeviceTasks() handler only needs to execute when a USB 
419:               interrupt occurs, and therefore only needs to be called from the interrupt 
420:               context.
421:           
422:               Typical usage:
423:               <code>
424:               void main(void)
425:               {
426:                   USBDeviceInit();
427:                   while(1)
428:                   {
429:                       USBDeviceTasks(); //Takes care of enumeration and other USB events
430:                       if((USBGetDeviceState() \< CONFIGURED_STATE) ||
431:                          (USBIsDeviceSuspended() == true))
432:                       {
433:                           //Either the device is not configured or we are suspended,
434:                           // so we don't want to execute any USB related application code
435:                           continue;   //go back to the top of the while loop
436:                       }
437:                       else
438:                       {
439:                           //Otherwise we are free to run USB and non-USB related user 
440:                           //application code.
441:                           UserApplication();
442:                       }
443:                   }
444:               }
445:               </code>
446:           
447:             Precondition:
448:               Make sure the USBDeviceInit() function has been called prior to calling
449:               USBDeviceTasks() for the first time.
450:             Remarks:
451:               USBDeviceTasks() does not need to be called while in the USB suspend mode, 
452:               if the user application firmware in the USBCBSuspend() callback function
453:               enables the ACTVIF USB interrupt source and put the microcontroller into 
454:               sleep mode.  If the application firmware decides not to sleep the 
455:               microcontroller core during USB suspend (ex: continues running at full 
456:               frequency, or clock switches to a lower frequency), then the USBDeviceTasks()
457:               function must still be called periodically, at a rate frequent enough to 
458:               ensure the 10ms resume recovery interval USB specification is met.  Assuming
459:               a worst case primary oscillator and PLL start up time of less than 5ms, then
460:               USBDeviceTasks() should be called once every 5ms in this scenario.
461:              
462:               When the USB cable is detached, or the USB host is not actively powering 
463:               the VBUS line to +5V nominal, the application firmware does not always have 
464:               to call USBDeviceTasks() frequently, as no USB activity will be taking 
465:               place.  However, if USBDeviceTasks() is not called regularly, some 
466:               alternative means of promptly detecting when VBUS is powered (indicating 
467:               host attachment), or not powered (host powered down or USB cable unplugged)
468:               is still needed.  For self or dual self/bus powered USB applications, see 
469:               the USBDeviceAttach() and USBDeviceDetach() API documentation for additional 
470:               considerations.
471:               ***************************************************************************/
472:           void USBDeviceTasks(void)
473:           {
474:               uint8_t i;
475:           
476:               #ifdef USB_SUPPORT_OTG
477:                   //SRP Time Out Check
478:                   if (USBOTGSRPIsReady())
479:                   {
480:                       if (USBT1MSECIF && USBT1MSECIE)
481:                       {
482:                           if (USBOTGGetSRPTimeOutFlag())
483:                           {
484:                               if (USBOTGIsSRPTimeOutExpired())
485:                               {
486:                                   USB_OTGEventHandler(0,OTG_EVENT_SRP_FAILED,0,0);
487:                               }
488:                           }
489:           
490:                           //Clear Interrupt Flag
491:                           USBClearInterruptFlag(USBT1MSECIFReg,USBT1MSECIFBitNum);
492:                       }
493:                   }
494:               #endif
495:           
496:               #if defined(USB_POLLING)
497:               //If the interrupt option is selected then the customer is required
498:               //  to notify the stack when the device is attached or removed from the
499:               //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
500:               if (USB_BUS_SENSE != 1)
501:               {
502:                    // Disable module & detach from bus
503:                    U1CON = 0;             
504:           
505:                    // Mask all USB interrupts              
506:                    U1IE = 0;          
507:           
508:                    //Move to the detached state                  
509:                    USBDeviceState = DETACHED_STATE;
510:           
511:                    #ifdef  USB_SUPPORT_OTG    
512:                        //Disable D+ Pullup
513:                        U1OTGCONbits.DPPULUP = 0;
514:           
515:                        //Disable HNP
516:                        USBOTGDisableHnp();
517:           
518:                        //Deactivate HNP
519:                        USBOTGDeactivateHnp();
520:                        
521:                        //If ID Pin Changed State
522:                        if (USBIDIF && USBIDIE)
523:                        {  
524:                            //Re-detect & Initialize
525:                             USBOTGInitialize();
526:           
527:                             //Clear ID Interrupt Flag
528:                             USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
529:                        }
530:                    #endif
531:           
532:                    #if defined __C30__ || defined __XC16__
533:                        //USBClearInterruptFlag(U1OTGIR, 3); 
534:                    #endif
535:                       //return so that we don't go through the rest of 
536:                       //the state machine
537:                    USBClearUSBInterrupt();
538:                    return;
539:               }
540:           
541:           	#ifdef USB_SUPPORT_OTG
542:               //If Session Is Started Then
543:               else
544:           	{
545:                   //If SRP Is Ready
546:                   if (USBOTGSRPIsReady())
547:                   {   
548:                       //Clear SRPReady
549:                       USBOTGClearSRPReady();
550:           
551:                       //Clear SRP Timeout Flag
552:                       USBOTGClearSRPTimeOutFlag();
553:           
554:                       //Indicate Session Started
555:                       UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
556:                   }
557:               }
558:           	#endif	//#ifdef USB_SUPPORT_OTG
559:           
560:               //if we are in the detached state
561:               if(USBDeviceState == DETACHED_STATE)
0176  0021     MOVLB 0x1
0177  086E     MOVF USBDeviceState, W
0178  1D03     BTFSS STATUS, 0x2
0179  2987     GOTO 0x187
562:               {
563:           	    //Initialize register to known value
564:                   U1CON = 0;                          
017A  003D     MOVLB 0x1D
017B  018E     CLRF UCON
565:           
566:                   // Mask all USB interrupts
567:                   U1IE = 0;                                
017C  0192     CLRF UIE
568:           
569:                   //Enable/set things like: pull ups, full/low-speed mode, 
570:                   //set the ping pong mode, and set internal transceiver
571:                   SetConfigurationOptions();
017D  3016     MOVLW 0x16
017E  25B7     CALL 0x5B7
017F  3180     MOVLP 0x0
572:           
573:                   // Enable module & attach to bus
574:                   while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
0180  198E     BTFSC UCON, 0x3
0181  2984     GOTO 0x184
0182  158E     BSF UCON, 0x3
0183  2980     GOTO 0x180
575:           
576:                   //moved to the attached state
577:                   USBDeviceState = ATTACHED_STATE;
0184  0021     MOVLB 0x1
0185  01EE     CLRF USBDeviceState
0186  0AEE     INCF USBDeviceState, F
578:           
579:                   #ifdef  USB_SUPPORT_OTG
580:                       U1OTGCON |= USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;  
581:                   #endif
582:               }
583:           	#endif  //#if defined(USB_POLLING)
584:           
585:               if(USBDeviceState == ATTACHED_STATE)
0187  036E     DECF USBDeviceState, W
0188  1D03     BTFSS STATUS, 0x2
0189  2994     GOTO 0x194
586:               {
587:                   /*
588:                    * After enabling the USB module, it takes some time for the
589:                    * voltage on the D+ or D- line to rise high enough to get out
590:                    * of the SE0 condition. The USB Reset interrupt should not be
591:                    * unmasked until the SE0 condition is cleared. This helps
592:                    * prevent the firmware from misinterpreting this unique event
593:                    * as a USB bus reset from the USB host.
594:                    */
595:           
596:                   if(!USBSE0Event)
018A  003D     MOVLB 0x1D
018B  1A8E     BTFSC UCON, 0x5
018C  2994     GOTO 0x194
597:                   {
598:                       //We recently attached, make sure we are in a clean state
599:                       #if defined(__dsPIC33E__) || defined(_PIC24E__)
600:                           U1IR = 0xFFEF;  //Preserve IDLEIF info, so we can detect suspend
601:                                           //during attach de-bounce interval
602:                       #else
603:                           USBClearInterruptRegister(U1IR);
018D  0190     CLRF UIR
604:                       #endif
605:           
606:                       #if defined(USB_POLLING)
607:                           U1IE=0;                        // Mask all USB interrupts
018E  0192     CLRF UIE
608:                       #endif
609:                       USBResetIE = 1;             // Unmask RESET interrupt
018F  1412     BSF UIE, 0x0
610:                       USBIdleIE = 1;             // Unmask IDLE interrupt
0190  1612     BSF UIE, 0x4
611:                       USBDeviceState = POWERED_STATE;
0191  3002     MOVLW 0x2
0192  0021     MOVLB 0x1
0193  00EE     MOVWF USBDeviceState
612:                   }
613:               }
614:           
615:               #ifdef  USB_SUPPORT_OTG
616:                   //If ID Pin Changed State
617:                   if (USBIDIF && USBIDIE)
618:                   {  
619:                       //Re-detect & Initialize
620:                       USBOTGInitialize();
621:           
622:                       USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
623:                   }
624:               #endif
625:           
626:               /*
627:                * Task A: Service USB Activity Interrupt
628:                */
629:               if(USBActivityIF && USBActivityIE)
0194  003D     MOVLB 0x1D
0195  1910     BTFSC UIR, 0x2
0196  1D12     BTFSS UIE, 0x2
0197  299B     GOTO 0x19B
630:               {
631:                   USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
0198  1110     BCF UIR, 0x2
632:                   #if defined(USB_SUPPORT_OTG)
633:                       U1OTGIR = 0x10;        
634:                   #else
635:                       USBWakeFromSuspend();
0199  250F     CALL 0x50F
019A  3180     MOVLP 0x0
636:                   #endif
637:               }
638:           
639:               /*
640:                * Pointless to continue servicing if the device is in suspend mode.
641:                */
642:               if(USBSuspendControl==1)
019B  003D     MOVLB 0x1D
019C  1C8E     BTFSS UCON, 0x1
019D  29A1     GOTO 0x1A1
643:               {
644:                   USBClearUSBInterrupt();
019E  0020     MOVLB 0x0
019F  1112     BCF PIR2, 0x2
645:                   return;
01A0  0008     RETURN
646:               }
647:           
648:               /*
649:                * Task B: Service USB Bus Reset Interrupt.
650:                * When bus reset is received during suspend, ACTVIF will be set first,
651:                * once the UCONbits.SUSPND is clear, then the URSTIF bit will be asserted.
652:                * This is why URSTIF is checked after ACTVIF.
653:                *
654:                * The USB reset flag is masked when the USB state is in
655:                * DETACHED_STATE or ATTACHED_STATE, and therefore cannot
656:                * cause a USB reset event during these two states.
657:                */
658:               if(USBResetIF && USBResetIE)
01A1  1810     BTFSC 0x10, 0x0
01A2  1C12     BTFSS PIR2, 0x0
01A3  29AA     GOTO 0x1AA
659:               {
660:                   USBDeviceInit();
01A4  20E5     CALL 0xE5
01A5  3180     MOVLP 0x0
661:           
662:                   //Re-enable the interrupts since the USBDeviceInit() function will
663:                   //  disable them.  This will do nothing in a polling setup
664:                   USBUnmaskInterrupts();
665:           
666:                   USBDeviceState = DEFAULT_STATE;
01A6  3004     MOVLW 0x4
01A7  00EE     MOVWF 0x6E
667:           
668:                   #ifdef USB_SUPPORT_OTG
669:                        //Disable HNP
670:                        USBOTGDisableHnp();
671:           
672:                        //Deactivate HNP
673:                        USBOTGDeactivateHnp();
674:                   #endif
675:           
676:                   USBClearInterruptFlag(USBResetIFReg,USBResetIFBitNum);
01A8  003D     MOVLB 0x1D
01A9  1010     BCF UIR, 0x0
677:               }
678:           
679:               /*
680:                * Task C: Service other USB interrupts
681:                */
682:               if(USBIdleIF && USBIdleIE)
01AA  1A10     BTFSC UIR, 0x4
01AB  1E12     BTFSS UIE, 0x4
01AC  29AF     GOTO 0x1AF
683:               { 
684:                   #ifdef  USB_SUPPORT_OTG 
685:                       //If Suspended, Try to switch to Host
686:                       USBOTGSelectRole(ROLE_HOST);
687:                       USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
688:                   #else
689:                       USBSuspend();
01AD  2503     CALL 0x503
01AE  3180     MOVLP 0x0
690:                   #endif
691:               }
692:           
693:               #if defined(__XC16__) || defined(__C30__) || defined(__XC32__)
694:                   //Check if a 1ms interval has elapsed.	
695:                   if(USBT1MSECIF)
696:                   {
697:                       USBClearInterruptFlag(USBT1MSECIFReg, USBT1MSECIFBitNum);
698:                       USBIncrement1msInternalTimers();
699:                   }
700:               #endif
701:           
702:               //Start-of-Frame Interrupt
703:               if(USBSOFIF)
01AF  003D     MOVLB 0x1D
01B0  1F10     BTFSS UIR, 0x6
01B1  29C8     GOTO 0x1C8
704:               {
705:                   //Call the user SOF event callback if enabled.
706:                   if(USBSOFIE)
01B2  1F12     BTFSS UIE, 0x6
01B3  29BC     GOTO 0x1BC
707:                   {
708:                       USB_SOF_HANDLER(EVENT_SOF,0,1);
01B4  3073     MOVLW 0x73
01B5  0021     MOVLB 0x1
01B6  00A0     MOVWF __pcstackBANK1
01B7  01A1     CLRF sector_addr
01B8  25BD     CALL 0x5BD
01B9  3180     MOVLP 0x0
01BA  2222     CALL 0x222
01BB  3180     MOVLP 0x0
709:                   }    
710:                   USBClearInterruptFlag(USBSOFIFReg,USBSOFIFBitNum);
01BC  003D     MOVLB 0x1D
01BD  1310     BCF UIR, 0x6
711:           
712:                   #if defined(__XC8__) || defined(__C18__)
713:                       USBIncrement1msInternalTimers();
01BE  2297     CALL 0x297
01BF  3180     MOVLP 0x0
714:                   #endif
715:           
716:                   #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
717:                       //Supporting this feature requires a 1ms time base for keeping track of the timeout interval.
718:                       #if(USB_SPEED_OPTION == USB_LOW_SPEED)
719:                           #warning "Double click this message.  See inline code comments."
720:                           //The "USB_ENABLE_STATUS_STAGE_TIMEOUTS" feature is optional and is
721:                           //not strictly needed in all applications (ex: those that never call 
722:                           //USBDeferStatusStage() and don't use host to device (OUT) control
723:                           //transfers with data stage).  
724:                           //However, if this feature is enabled and used in a low speed application,
725:                           //it is required for the application code to periodically call the
726:                           //USBIncrement1msInternalTimers() function at a nominally 1ms rate.
727:                       #endif
728:                       
729:                       //Decrement our status stage counter.
730:                       if(USBStatusStageTimeoutCounter != 0u)
01C0  0853     MOVF 0xED3, W
01C1  1D03     BTFSS STATUS, 0x2
731:                       {
732:                           USBStatusStageTimeoutCounter--;
01C2  03D3     DECF 0xED3, F
733:                       }
734:                       //Check if too much time has elapsed since progress was made in 
735:                       //processing the control transfer, without arming the status stage.  
736:                       //If so, auto-arm the status stage to ensure that the control 
737:                       //transfer can [eventually] complete, within the timing limits
738:                       //dictated by section 9.2.6 of the official USB 2.0 specifications.
739:                       if(USBStatusStageTimeoutCounter == 0)
01C3  0853     MOVF 0xED3, W
01C4  1D03     BTFSS STATUS, 0x2
01C5  29C8     GOTO 0x1C8
740:                       {
741:                           USBCtrlEPAllowStatusStage();    //Does nothing if the status stage was already armed.
01C6  2487     CALL 0x487
01C7  3180     MOVLP 0x0
742:                       } 
743:                   #endif
744:               }
745:           
746:               if(USBStallIF && USBStallIE)
01C8  003D     MOVLB 0x1D
01C9  1A90     BTFSC UIR, 0x5
01CA  1E92     BTFSS UIE, 0x5
01CB  29CE     GOTO 0x1CE
747:               {
748:                   USBStallHandler();
01CC  22A2     CALL 0x2A2
01CD  3180     MOVLP 0x0
749:               }
750:           
751:               if(USBErrorIF && USBErrorIE)
01CE  1890     BTFSC UIR, 0x1
01CF  1C92     BTFSS UIE, 0x1
01D0  29DC     GOTO 0x1DC
752:               {
753:                   USB_ERROR_HANDLER(EVENT_BUS_ERROR,0,1);
01D1  30FF     MOVLW 0xFF
01D2  0021     MOVLB 0x1
01D3  00A0     MOVWF __pcstackBANK1
01D4  307F     MOVLW 0x7F
01D5  00A1     MOVWF sector_addr
01D6  25BD     CALL 0x5BD
01D7  3180     MOVLP 0x0
01D8  2222     CALL 0x222
01D9  3180     MOVLP 0x0
754:                   USBClearInterruptRegister(U1EIR);               // This clears UERRIF
01DA  003D     MOVLB 0x1D
01DB  0193     CLRF UEIR
755:           
756:                   //On PIC18, clearing the source of the error will automatically clear
757:                   //  the interrupt flag.  On other devices the interrupt flag must be 
758:                   //  manually cleared. 
759:                   #if defined(__C32__) || defined(__C30__) || defined __XC16__
760:                       USBClearInterruptFlag( USBErrorIFReg, USBErrorIFBitNum );
761:                   #endif
762:               }
763:           
764:               /*
765:                * Pointless to continue servicing if the host has not sent a bus reset.
766:                * Once bus reset is received, the device transitions into the DEFAULT
767:                * state and is ready for communication.
768:                */
769:               if(USBDeviceState < DEFAULT_STATE)
01DC  3004     MOVLW 0x4
01DD  0021     MOVLB 0x1
01DE  026E     SUBWF USBDeviceState, W
01DF  1803     BTFSC STATUS, 0x0
01E0  29E4     GOTO 0x1E4
770:               {
771:                   USBClearUSBInterrupt();
01E1  0020     MOVLB 0x0
01E2  1112     BCF PIR2, 0x2
772:                   return;
01E3  0008     RETURN
773:               }  
774:           
775:               /*
776:                * Task D: Servicing USB Transaction Complete Interrupt
777:                */
778:               if(USBTransactionCompleteIE)
01E4  003D     MOVLB 0x1D
01E5  1D92     BTFSS UIE, 0x3
01E6  2A1F     GOTO 0x21F
779:               {
780:                   for(i = 0; i < 4u; i++)	//Drain or deplete the USAT FIFO entries.  If the USB FIFO ever gets full, USB bandwidth
01E7  0021     MOVLB 0x1
01E8  01AD     CLRF i
0216  0021     MOVLB 0x1
0217  3004     MOVLW 0x4
0218  0AAD     INCF i, F
0219  022D     SUBWF i, W
021A  1803     BTFSC STATUS, 0x0
021B  2A1F     GOTO 0x21F
781:                   {						//utilization can be compromised, and the device won't be able to receive SETUP packets.
782:                       if(USBTransactionCompleteIF)
01E9  2A1C     GOTO 0x21C
021C  003D     MOVLB 0x1D
021D  1990     BTFSC UIR, 0x3
021E  29EA     GOTO 0x1EA
783:                       {
784:                           //Save and extract USTAT register info.  Will use this info later.
785:                           USTATcopy.Val = U1STAT;
01EA  080F     MOVF USTAT, W
01EB  0021     MOVLB 0x1
01EC  00EF     MOVWF USTATcopy
786:                           endpoint_number = USBHALGetLastEndpoint(USTATcopy);
01ED  0C6F     RRF USTATcopy, W
01EE  00FD     MOVWF 0xFD
01EF  0CFD     RRF 0xFD, F
01F0  0C7D     RRF 0xFD, W
01F1  390F     ANDLW 0xF
01F2  0022     MOVLB 0x2
01F3  00D5     MOVWF endpoint_number
787:           
788:                           USBClearInterruptFlag(USBTransactionCompleteIFReg,USBTransactionCompleteIFBitNum);
01F4  003D     MOVLB 0x1D
01F5  1190     BCF UIR, 0x3
789:           
790:                           //Keep track of the hardware ping pong state for endpoints other
791:                           //than EP0, if ping pong buffering is enabled.
792:                           #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
793:                           if(USBHALGetLastDirection(USTATcopy) == OUT_FROM_HOST)
01F6  0021     MOVLB 0x1
01F7  196F     BTFSC USTATcopy, 0x2
01F8  29FD     GOTO 0x1FD
794:                           {
795:                               ep_data_out[endpoint_number].bits.ping_pong_state ^= 1;
01F9  0022     MOVLB 0x2
01FA  0855     MOVF endpoint_number, W
01FB  3ED1     ADDLW 0xD1
01FC  2A00     GOTO 0x200
796:                           }
797:                           else
798:                           {
799:                               ep_data_in[endpoint_number].bits.ping_pong_state ^= 1;
01FD  0022     MOVLB 0x2
01FE  0855     MOVF endpoint_number, W
01FF  3ED5     ADDLW 0xD5
0200  0086     MOVWF FSR1L
0201  3001     MOVLW 0x1
0202  0087     MOVWF FSR1H
0203  0681     XORWF INDF1, F
800:                           }
801:                           #endif
802:           
803:                           //USBCtrlEPService only services transactions over EP0.
804:                           //It ignores all other EP transactions.
805:                           if(endpoint_number == 0)
0204  0855     MOVF endpoint_number, W
0205  1D03     BTFSS STATUS, 0x2
0206  2A0A     GOTO 0x20A
806:                           {
807:                               USBCtrlEPService();
0207  24C7     CALL 0x4C7
0208  3180     MOVLP 0x0
808:                           }
0209  2A16     GOTO 0x216
809:                           else
810:                           {
811:                               USB_TRANSFER_COMPLETE_HANDLER(EVENT_TRANSFER, (uint8_t*)&USTATcopy.Val, 0);
020A  3072     MOVLW 0x72
020B  0021     MOVLB 0x1
020C  00A0     MOVWF __pcstackBANK1
020D  30EF     MOVLW 0xEF
020E  01A1     CLRF sector_addr
020F  00A2     MOVWF chk
0210  3000     MOVLW 0x0
0211  00A3     MOVWF 0xA3
0212  01A4     CLRF i
0213  01A5     CLRF address
0214  2222     CALL 0x222
0215  3180     MOVLP 0x0
812:                           }
813:                       }//end if(USBTransactionCompleteIF)
814:                       else
815:                       {
816:                           break;	//USTAT FIFO must be empty.
817:                       }
818:                   }//end for()
819:               }//end if(USBTransactionCompleteIE)
820:           
821:               USBClearUSBInterrupt();
021F  0020     MOVLB 0x0
0220  1112     BCF PIR2, 0x2
822:           }//end of USBDeviceTasks()
0221  0008     RETURN
823:           
824:           /*******************************************************************************
825:             Function:
826:                   void USBEnableEndpoint(uint8_t ep, uint8_t options)
827:               
828:             Summary:
829:               This function will enable the specified endpoint with the specified
830:               options
831:             Description:
832:               This function will enable the specified endpoint with the specified
833:               options.
834:               
835:               Typical Usage:
836:               <code>
837:               void USBCBInitEP(void)
838:               {
839:                   USBEnableEndpoint(MSD_DATA_IN_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
840:                   USBMSDInit();
841:               }
842:               </code>
843:               
844:               In the above example endpoint number MSD_DATA_IN_EP is being configured
845:               for both IN and OUT traffic with handshaking enabled. Also since
846:               MSD_DATA_IN_EP is not endpoint 0 (MSD does not allow this), then we can
847:               explicitly disable SETUP packets on this endpoint.
848:             Conditions:
849:               None
850:             Input:
851:               uint8_t ep -       the endpoint to be configured
852:               uint8_t options -  optional settings for the endpoint. The options should
853:                               be ORed together to form a single options string. The
854:                               available optional settings for the endpoint. The
855:                               options should be ORed together to form a single options
856:                               string. The available options are the following\:
857:                               * USB_HANDSHAKE_ENABLED enables USB handshaking (ACK,
858:                                 NAK)
859:                               * USB_HANDSHAKE_DISABLED disables USB handshaking (ACK,
860:                                 NAK)
861:                               * USB_OUT_ENABLED enables the out direction
862:                               * USB_OUT_DISABLED disables the out direction
863:                               * USB_IN_ENABLED enables the in direction
864:                               * USB_IN_DISABLED disables the in direction
865:                               * USB_ALLOW_SETUP enables control transfers
866:                               * USB_DISALLOW_SETUP disables control transfers
867:                               * USB_STALL_ENDPOINT STALLs this endpoint
868:             Return:
869:               None
870:             Remarks:
871:               None                                                                                                          
872:             *****************************************************************************/
873:           void USBEnableEndpoint(uint8_t ep, uint8_t options)
057B  00F9     MOVWF buffer
874:           {
875:               unsigned char* p;
876:                   
877:               //Use USBConfigureEndpoint() to set up the pBDTEntryIn/Out[ep] pointer and 
878:               //starting DTS state in the BDT entry.
879:               if(options & USB_OUT_ENABLED)
057C  1D74     BTFSS options, 0x2
057D  2D81     GOTO 0x581
880:               {
881:                   USBConfigureEndpoint(ep, OUT_FROM_HOST);
057E  01F0     CLRF __pcstackCOMMON
057F  25C3     CALL 0x5C3
0580  3180     MOVLP 0x0
882:               }
883:               if(options & USB_IN_ENABLED)
0581  1CF4     BTFSS options, 0x1
0582  2D87     GOTO 0x587
884:               {
885:                   USBConfigureEndpoint(ep, IN_TO_HOST);
0583  01F0     CLRF __pcstackCOMMON
0584  0AF0     INCF __pcstackCOMMON, F
0585  0879     MOVF buffer, W
0586  25C3     CALL 0x5C3
886:               }
887:           
888:               //Update the relevant UEPx register to actually enable the endpoint with
889:               //the specified options (ex: handshaking enabled, control transfers allowed,
890:               //etc.)
891:               #if defined(__C32__)
892:                   p = (unsigned char*)(&U1EP0+(4*ep));
893:               #else
894:                   p = (unsigned char*)(&U1EP0+ep);
0587  0879     MOVF buffer, W
0588  3E98     ADDLW 0x98
0589  00F5     MOVWF byteToRead
058A  300E     MOVLW 0xE
058B  01F6     CLRF ep
058C  3DF6     ADDWFC ep, F
058D  0875     MOVF byteToRead, W
058E  00F7     MOVWF p
058F  0876     MOVF ep, W
0590  00F8     MOVWF seg
895:               #endif
896:               *p = options;
0591  0877     MOVF p, W
0592  0086     MOVWF FSR1
0593  0878     MOVF seg, W
0594  0087     MOVWF FSR1H
0595  0874     MOVF options, W
0596  0081     MOVWF INDF1
897:           }
0597  0008     RETURN
898:           
899:           
900:           /*************************************************************************
901:             Function:
902:               USB_HANDLE USBTransferOnePacket(uint8_t ep, uint8_t dir, uint8_t* data, uint8_t len)
903:               
904:             Summary:
905:               Transfers a single packet (one transaction) of data on the USB bus.
906:           
907:             Description:
908:               The USBTransferOnePacket() function prepares a USB endpoint
909:               so that it may send data to the host (an IN transaction), or 
910:               receive data from the host (an OUT transaction).  The 
911:               USBTransferOnePacket() function can be used both to receive	and 
912:               send data to the host.  This function is the primary API function 
913:               provided by the USB stack firmware for sending or receiving application 
914:               data over the USB port.  
915:           
916:               The USBTransferOnePacket() is intended for use with all application 
917:               endpoints.  It is not used for sending or receiving application data 
918:               through endpoint 0 by using control transfers.  Separate API 
919:               functions, such as USBEP0Receive(), USBEP0SendRAMPtr(), and
920:               USBEP0SendROMPtr() are provided for this purpose.
921:           
922:               The	USBTransferOnePacket() writes to the Buffer Descriptor Table (BDT)
923:               entry associated with an endpoint buffer, and sets the UOWN bit, which 
924:               prepares the USB hardware to allow the transaction to complete.  The 
925:               application firmware can use the USBHandleBusy() macro to check the 
926:               status of the transaction, to see if the data has been successfully 
927:               transmitted yet.
928:           
929:           
930:               Typical Usage
931:               <code>
932:               //make sure that the we are in the configured state
933:               if(USBGetDeviceState() == CONFIGURED_STATE)
934:               {
935:                   //make sure that the last transaction isn't busy by checking the handle
936:                   if(!USBHandleBusy(USBInHandle))
937:                   {
938:           	        //Write the new data that we wish to send to the host to the INPacket[] array
939:           	        INPacket[0] = USEFUL_APPLICATION_VALUE1;
940:           	        INPacket[1] = USEFUL_APPLICATION_VALUE2;
941:           	        //INPacket[2] = ... (fill in the rest of the packet data)
942:           	      
943:                       //Send the data contained in the INPacket[] array through endpoint "EP_NUM"
944:                       USBInHandle = USBTransferOnePacket(EP_NUM,IN_TO_HOST,(uint8_t*)&INPacket[0],sizeof(INPacket));
945:                   }
946:               }
947:               </code>
948:           
949:             Conditions:
950:               Before calling USBTransferOnePacket(), the following should be true.
951:               1.  The USB stack has already been initialized (USBDeviceInit() was called).
952:               2.  A transaction is not already pending on the specified endpoint.  This
953:                   is done by checking the previous request using the USBHandleBusy() 
954:                   macro (see the typical usage example).
955:               3.  The host has already sent a set configuration request and the 
956:                   enumeration process is complete.
957:                   This can be checked by verifying that the USBGetDeviceState() 
958:                   macro returns "CONFIGURED_STATE", prior to calling 
959:                   USBTransferOnePacket().
960:            					
961:             Input:
962:               uint8_t ep - The endpoint number that the data will be transmitted or
963:           	          received on
964:               uint8_t dir - The direction of the transfer
965:                          This value is either OUT_FROM_HOST or IN_TO_HOST
966:               uint8_t* data - For IN transactions: pointer to the RAM buffer containing
967:                            the data to be sent to the host.  For OUT transactions: pointer
968:                            to the RAM buffer that the received data should get written to.
969:              uint8_t len - Length of the data needing to be sent (for IN transactions).
970:                         For OUT transactions, the len parameter should normally be set
971:                         to the endpoint size specified in the endpoint descriptor.    
972:           
973:             Return Values:
974:               USB_HANDLE - handle to the transfer.  The handle is a pointer to 
975:                            the BDT entry associated with this transaction.  The
976:                            status of the transaction (ex: if it is complete or still
977:                            pending) can be checked using the USBHandleBusy() macro
978:                            and supplying the USB_HANDLE provided by
979:                            USBTransferOnePacket().
980:           
981:             Remarks:
982:               If calling the USBTransferOnePacket() function from within the USBCBInitEP()
983:               callback function, the set configuration is still being processed and the
984:               USBDeviceState may not be == CONFIGURED_STATE yet.  In this	special case, 
985:               the USBTransferOnePacket() may still be called, but make sure that the 
986:               endpoint has been enabled and initialized by the USBEnableEndpoint() 
987:               function first.  
988:               
989:             *************************************************************************/
990:           USB_HANDLE USBTransferOnePacket(uint8_t ep,uint8_t dir,uint8_t* data,uint8_t len)
0427  00F6     MOVWF ep
991:           {
992:               volatile BDT_ENTRY* handle;
993:           
994:               //If the direction is IN
995:               if(dir != 0)
0428  0870     MOVF __pcstackCOMMON, W
0429  1903     BTFSC STATUS, 0x2
042A  2C2E     GOTO 0x42E
996:               {
997:                   //point to the IN BDT of the specified endpoint
998:                   handle = pBDTEntryIn[ep];
042B  0876     MOVF ep, W
042C  3E38     ADDLW 0x38
042D  2C30     GOTO 0x430
999:               }
1000:              else
1001:              {
1002:                  //else point to the OUT BDT of the specified endpoint
1003:                  handle = pBDTEntryOut[ep];
042E  0876     MOVF ep, W
042F  3E3C     ADDLW 0x3C
0430  0086     MOVWF FSR1
0431  3001     MOVLW 0x1
0432  0087     MOVWF FSR1H
0433  0801     MOVF INDF1, W
0434  00F7     MOVWF p
1004:              }
1005:              
1006:              //Error checking code.  Make sure the handle (pBDTEntryIn[ep] or
1007:              //pBDTEntryOut[ep]) is initialized before using it.
1008:              if(handle == 0)
0435  0877     MOVF p, W
0436  1903     BTFSC STATUS, 0x2
1009:              {
1010:                  return 0;
0437  3400     RETLW 0x0
1011:              }
1012:          
1013:              //Toggle the DTS bit if required
1014:              #if (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
1015:                  handle->STAT.Val ^= _DTSMASK;
1016:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
1017:                  if(ep != 0)
1018:                  {
1019:                      handle->STAT.Val ^= _DTSMASK;
1020:                  }
1021:              #endif
1022:          
1023:              //Set the data pointer, data length, and enable the endpoint
1024:              handle->ADR = ConvertToPhysicalAddress(data);
0438  0871     MOVF data, W
0439  00F4     MOVWF options
043A  307F     MOVLW 0x7F
043B  0572     ANDWF EPNum, W
043C  00F5     MOVWF byteToRead
043D  0877     MOVF p, W
043E  3E02     ADDLW 0x2
043F  0086     MOVWF FSR1
0440  0187     CLRF FSR1H
0441  0874     MOVF options, W
0442  3FC0     MOVWI 0[FSR1]
0443  0875     MOVF byteToRead, W
0444  3FC1     MOVWI 1[FSR1]
1025:              handle->CNT = len;
0445  0A77     INCF p, W
0446  0086     MOVWF FSR1
0447  0873     MOVF handle, W
0448  0081     MOVWF INDF1
1026:              handle->STAT.Val &= _DTSMASK;
0449  0877     MOVF p, W
044A  0086     MOVWF FSR1
044B  3040     MOVLW 0x40
044C  0581     ANDWF INDF1, F
1027:              handle->STAT.Val |= (_DTSEN & _DTS_CHECKING_ENABLED);
044D  0877     MOVF p, W
044E  0086     MOVWF FSR1
044F  1581     BSF INDF1, 0x3
1028:              handle->STAT.Val |= _USIE;
0450  0877     MOVF p, W
0451  0086     MOVWF FSR1
0452  1781     BSF INDF1, 0x7
1029:          
1030:              //Point to the next buffer for ping pong purposes.
1031:              if(dir != OUT_FROM_HOST)
0453  0870     MOVF __pcstackCOMMON, W
0454  1903     BTFSC STATUS, 0x2
0455  2C59     GOTO 0x459
1032:              {
1033:                  //toggle over the to the next buffer for an IN endpoint
1034:                  USBAdvancePingPongBuffer(&pBDTEntryIn[ep]);      
0456  0876     MOVF ep, W
0457  3E38     ADDLW 0x38
0458  2C5B     GOTO 0x45B
1035:              }
1036:              else
1037:              {
1038:                  //toggle over the to the next buffer for an OUT endpoint
1039:                  USBAdvancePingPongBuffer(&pBDTEntryOut[ep]);     
0459  0876     MOVF ep, W
045A  3E3C     ADDLW 0x3C
045B  0086     MOVWF FSR1
045C  3001     MOVLW 0x1
045D  0087     MOVWF FSR1H
045E  3004     MOVLW 0x4
045F  0681     XORWF INDF1, F
1040:              }
1041:              return (USB_HANDLE)handle;
0460  0877     MOVF p, W
1042:          }
0461  0008     RETURN
1043:          
1044:          
1045:          /********************************************************************
1046:              Function:
1047:                  void USBStallEndpoint(uint8_t ep, uint8_t dir)
1048:                  
1049:              Summary:
1050:                   Configures the specified endpoint to send STALL to the host, the next
1051:                   time the host tries to access the endpoint.
1052:              
1053:              PreCondition:
1054:                  None
1055:                  
1056:              Parameters:
1057:                  uint8_t ep - The endpoint number that should be configured to send STALL.
1058:                  uint8_t dir - The direction of the endpoint to STALL, either
1059:                             IN_TO_HOST or OUT_FROM_HOST.
1060:                  
1061:              Return Values:
1062:                  None
1063:                  
1064:              Remarks:
1065:                  None
1066:          
1067:           *******************************************************************/
1068:          void USBStallEndpoint(uint8_t ep, uint8_t dir)
026B  00F3     MOVWF handle
1069:          {
1070:              BDT_ENTRY *p;
1071:          
1072:              if(ep == 0)
026C  0873     MOVF handle, W
026D  1D03     BTFSS STATUS, 0x2
026E  2A82     GOTO 0x282
1073:              {
1074:                  //For control endpoints (ex: EP0), we need to STALL both IN and OUT
1075:                  //endpoints.  EP0 OUT must also be prepared to receive the next SETUP 
1076:                  //packet that will arrive.
1077:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
026F  3195     MOVLP 0x15
0270  2567     CALL 0x567
0271  3180     MOVLP 0x0
1078:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
0272  00F1     MOVWF data
0273  01F2     CLRF EPNum
0274  0868     MOVF CtrlTrfData, W
0275  3E02     ADDLW 0x2
0276  0086     MOVWF FSR1
0277  0871     MOVF data, W
0278  3FC0     MOVWI 0[FSR1]
0279  0872     MOVF EPNum, W
027A  3195     MOVLP 0x15
027B  257D     CALL 0x57D
027C  3180     MOVLP 0x0
1079:                  pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
1080:                  pBDTEntryEP0OutNext->STAT.Val |= _USIE;
1081:                  pBDTEntryIn[0]->STAT.Val = _BSTALL; 
027D  3195     MOVLP 0x15
027E  2594     CALL 0x594
027F  3180     MOVLP 0x0
0280  3195     MOVLP 0x15
0281  2D86     GOTO 0x586
1082:                  pBDTEntryIn[0]->STAT.Val |= _USIE;
1083:                         
1084:              }
1085:              else
1086:              {
1087:                  p = (BDT_ENTRY*)(&BDT[EP(ep,dir,0)]);
0282  25A8     CALL 0x5A8
0283  3180     MOVLP 0x0
0284  3E20     ADDLW 0x20
0285  0771     ADDWF data, W
0286  00F4     MOVWF options
1088:                  p->STAT.Val |= _BSTALL;
0287  0086     MOVWF FSR1
0288  0187     CLRF FSR1H
0289  1501     BSF INDF1, 0x2
1089:                  p->STAT.Val |= _USIE;
028A  0874     MOVF options, W
028B  0086     MOVWF FSR1
028C  1781     BSF INDF1, 0x7
028D  25A8     CALL 0x5A8
1090:              
1091:                  //If the device is in FULL or ALL_BUT_EP0 ping pong modes
1092:                  //then stall that entry as well
1093:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
1094:                  p = (BDT_ENTRY*)(&BDT[EP(ep,dir,1)]);
028E  3E24     ADDLW 0x24
028F  0771     ADDWF data, W
0290  00F4     MOVWF options
1095:                  p->STAT.Val |= _BSTALL;
0291  0086     MOVWF FSR1
0292  1501     BSF INDF1, 0x2
1096:                  p->STAT.Val |= _USIE;
0293  0874     MOVF options, W
0294  0086     MOVWF FSR1
0295  1781     BSF INDF1, 0x7
1097:                  #endif
1098:              }
1099:          }
0296  0008     RETURN
1100:          
1101:          /**************************************************************************
1102:              Function:
1103:                  void USBCancelIO(uint8_t endpoint)
1104:              
1105:              Description:
1106:                  This function cancels the transfers pending on the specified endpoint.
1107:                  This function can only be used after a SETUP packet is received and 
1108:                  before that setup packet is handled.  This is the time period in which
1109:                  the EVENT_EP0_REQUEST is thrown, before the event handler function
1110:                  returns to the stack.
1111:          
1112:              Precondition:
1113:            
1114:              Parameters:
1115:                  uint8_t endpoint - the endpoint number you wish to cancel the transfers for
1116:               
1117:              Return Values:
1118:                  None
1119:                  
1120:              Remarks:
1121:                  None
1122:                                                                    
1123:            **************************************************************************/
1124:          void USBCancelIO(uint8_t endpoint)
1125:          {
1126:              if(USBPacketDisable == 1)
1127:              {
1128:              	//The PKTDIS bit is currently set right now.  It is therefore "safe"
1129:              	//to mess with the BDT right now.
1130:              	pBDTEntryIn[endpoint]->Val &= _DTSMASK;	//Makes UOWN = 0 (_UCPU mode).  Deactivates endpoint.  Only sends NAKs.
1131:              	pBDTEntryIn[endpoint]->Val ^= _DTSMASK;	//Toggle the DTS bit.  This packet didn't get sent yet, and the next call to USBTransferOnePacket() will re-toggle the DTS bit back to the original (correct) value.
1132:              	
1133:              	//Need to do additional handling if ping-pong buffering is being used
1134:                  #if ((USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0))
1135:                  //Point to the next buffer for ping pong purposes.  UOWN getting cleared
1136:                  //(either due to SIE clearing it after a transaction, or the firmware
1137:                  //clearing it) makes hardware ping pong pointer advance.
1138:                  USBAdvancePingPongBuffer(&pBDTEntryIn[endpoint]);       
1139:              
1140:              	pBDTEntryIn[endpoint]->STAT.Val &= _DTSMASK;
1141:              	pBDTEntryIn[endpoint]->STAT.Val ^= _DTSMASK;
1142:                  #endif
1143:              }
1144:          }
1145:          
1146:          /**************************************************************************
1147:              Function:
1148:                  void USBDeviceDetach(void)
1149:             
1150:              Summary:
1151:                  This function configures the USB module to "soft detach" itself from
1152:                  the USB host.
1153:                  
1154:              Description:
1155:                  This function configures the USB module to perform a "soft detach"
1156:                  operation, by disabling the D+ (or D-) ~1.5k pull up resistor, which
1157:                  lets the host know the device is present and attached.  This will make
1158:                  the host think that the device has been unplugged.  This is potentially
1159:                  useful, as it allows the USB device to force the host to re-enumerate
1160:                  the device (on the firmware has re-enabled the USB module/pull up, by
1161:                  calling USBDeviceAttach(), to "soft re-attach" to the host).
1162:                  
1163:              Precondition:
1164:                  Should only be called when USB_INTERRUPT is defined.  See remarks
1165:                  section if USB_POLLING mode option is being used (usb_config.h option).
1166:          
1167:                  Additionally, this function should only be called from the main() loop 
1168:                  context.  Do not call this function from within an interrupt handler, as 
1169:                  this function may modify global interrupt enable bits and settings.
1170:                  
1171:              Parameters:
1172:                  None
1173:               
1174:              Return Values:
1175:                  None
1176:                  
1177:              Remarks:
1178:                  If the application firmware calls USBDeviceDetach(), it is strongly
1179:                  recommended that the firmware wait at least >= 80ms before calling
1180:                  USBDeviceAttach().  If the firmware performs a soft detach, and then
1181:                  re-attaches too soon (ex: after a few micro seconds for instance), some
1182:                  hosts may interpret this as an unexpected "glitch" rather than as a
1183:                  physical removal/re-attachment of the USB device.  In this case the host
1184:                  may simply ignore the event without re-enumerating the device.  To 
1185:                  ensure that the host properly detects and processes the device soft
1186:                  detach/re-attach, it is recommended to make sure the device remains 
1187:                  detached long enough to mimic a real human controlled USB 
1188:                  unplug/re-attach event (ex: after calling USBDeviceDetach(), do not
1189:                  call USBDeviceAttach() for at least 80+ms, preferably longer.
1190:                  
1191:                  Neither the USBDeviceDetach() or USBDeviceAttach() functions are blocking
1192:                  or take long to execute.  It is the application firmwares 
1193:                  responsibility for adding the 80+ms delay, when using these API 
1194:                  functions.
1195:                  
1196:                  Note: The Windows plug and play event handler processing is fairly 
1197:                  slow, especially in certain versions of Windows, and for certain USB
1198:                  device classes.  It has been observed that some device classes need to
1199:                  provide even more USB detach dwell interval (before calling 
1200:                  USBDeviceAttach()), in order to work correctly after re-enumeration.
1201:                  If the USB device is a CDC class device, it is recommended to wait
1202:                  at least 1.5 seconds or longer, before soft re-attaching to the host,
1203:                  to provide the plug and play event handler enough time to finish 
1204:                  processing the removal event, before the re-attach occurs.
1205:                  
1206:                  If the application is using the USB_POLLING mode option, then the 
1207:                  USBDeviceDetach() and USBDeviceAttach() functions are not available.  
1208:                  In this mode, the USB stack relies on the "#define USE_USB_BUS_SENSE_IO" 
1209:                  and "#define USB_BUS_SENSE" options in the 
1210:                  HardwareProfile  [platform name].h file. 
1211:          
1212:                  When using the USB_POLLING mode option, and the 
1213:                  "#define USE_USB_BUS_SENSE_IO" definition has been commented out, then 
1214:                  the USB stack assumes that it should always enable the USB module at 
1215:                  pretty much all times.  Basically, anytime the application firmware 
1216:                  calls USBDeviceTasks(), the firmware will automatically enable the USB 
1217:                  module.  This mode would typically be selected if the application was 
1218:                  designed to be a purely bus powered device.  In this case, the 
1219:                  application is powered from the +5V VBUS supply from the USB port, so 
1220:                  it is correct and sensible in this type of application to power up and 
1221:                  turn on the USB module, at anytime that the microcontroller is 
1222:                  powered (which implies the USB cable is attached and the host is also 
1223:                  powered).
1224:          
1225:                  In a self powered application, the USB stack is designed with the 
1226:                  intention that the user will enable the "#define USE_USB_BUS_SENSE_IO" 
1227:                  option in the HardwareProfile  [platform name].h file.  When this 
1228:                  option is defined, then the USBDeviceTasks() function will automatically 
1229:                  check the I/O pin port value of the designated pin (based on the 
1230:                  #define USB_BUS_SENSE option in the HardwareProfile  [platform name].h 
1231:                  file), every time the application calls USBDeviceTasks().  If the 
1232:                  USBDeviceTasks() function is executed and finds that the pin defined by 
1233:                  the #define USB_BUS_SENSE is in a logic low state, then it will 
1234:                  automatically disable the USB module and tri-state the D+ and D- pins.  
1235:                  If however the USBDeviceTasks() function is executed and finds the pin 
1236:                  defined by the #define USB_BUS_SENSE is in a logic high state, then it 
1237:                  will automatically enable the USB module, if it has not already been 
1238:                  enabled.        
1239:                                                                    
1240:            **************************************************************************/
1241:          #if defined(USB_INTERRUPT)
1242:          void USBDeviceDetach(void)
1243:          {
1244:              //If the interrupt option is selected then the customer is required
1245:              //  to notify the stack when the device is attached or removed from the
1246:              //  bus by calling the USBDeviceAttach() and USBDeviceDetach() functions.
1247:          #ifdef USB_SUPPORT_OTG
1248:              if (USB_BUS_SENSE != 1)
1249:          #endif
1250:              {
1251:                   // Disable module & detach from bus
1252:                   U1CON = 0;             
1253:          
1254:                   // Mask all USB interrupts              
1255:                   U1IE = 0;          
1256:          
1257:                   //Move to the detached state                  
1258:                   USBDeviceState = DETACHED_STATE;
1259:          
1260:                   #ifdef  USB_SUPPORT_OTG    
1261:                       //Disable D+ Pull-up
1262:                       U1OTGCONbits.DPPULUP = 0;
1263:          
1264:                       //Disable HNP
1265:                       USBOTGDisableHnp();
1266:          
1267:                       //Deactivate HNP
1268:                       USBOTGDeactivateHnp();
1269:                       
1270:                       //If ID Pin Changed State
1271:                       if (USBIDIF && USBIDIE)
1272:                       {  
1273:                           //Re-detect & Initialize
1274:                            USBOTGInitialize();
1275:          
1276:                            //Clear ID Interrupt Flag
1277:                            USBClearInterruptFlag(USBIDIFReg,USBIDIFBitNum);
1278:                       }
1279:                   #endif
1280:          
1281:                   #if defined __C30__ || defined __XC16__
1282:                       //USBClearInterruptFlag(U1OTGIR, 3); 
1283:                   #endif
1284:                      //return so that we don't go through the rest of 
1285:                      //the state machine
1286:                    return;
1287:              }
1288:          
1289:          #ifdef USB_SUPPORT_OTG
1290:              //If Session Is Started Then
1291:             else
1292:             {
1293:                  //If SRP Is Ready
1294:                  if (USBOTGSRPIsReady())
1295:                  {   
1296:                      //Clear SRPReady
1297:                      USBOTGClearSRPReady();
1298:          
1299:                      //Clear SRP Timeout Flag
1300:                      USBOTGClearSRPTimeOutFlag();
1301:          
1302:                      //Indicate Session Started
1303:                      UART2PrintString( "\r\n***** USB OTG B Event - Session Started  *****\r\n" );
1304:                  }
1305:              }
1306:          #endif
1307:          }
1308:          #endif  //#if defined(USB_INTERRUPT)
1309:          /**************************************************************************
1310:              Function:
1311:                  void USBDeviceAttach(void)
1312:              
1313:              Summary:
1314:                  Checks if VBUS is present, and that the USB module is not already 
1315:                  initialized, and if so, enables the USB module so as to signal device 
1316:                  attachment to the USB host.   
1317:          
1318:              Description:
1319:                  This function indicates to the USB host that the USB device has been
1320:                  attached to the bus.  This function needs to be called in order for the
1321:                  device to start to enumerate on the bus.
1322:                          
1323:              Precondition:
1324:                  Should only be called when USB_INTERRUPT is defined.  Also, should only 
1325:                  be called from the main() loop context.  Do not call USBDeviceAttach()
1326:                  from within an interrupt handler, as the USBDeviceAttach() function
1327:                  may modify global interrupt enable bits and settings.
1328:          
1329:                  For normal USB devices:
1330:                  Make sure that if the module was previously on, that it has been turned off 
1331:                  for a long time (ex: 100ms+) before calling this function to re-enable the module.
1332:                  If the device turns off the D+ (for full speed) or D- (for low speed) ~1.5k ohm
1333:                  pull up resistor, and then turns it back on very quickly, common hosts will sometimes 
1334:                  reject this event, since no human could ever unplug and re-attach a USB device in a 
1335:                  microseconds (or nanoseconds) timescale.  The host could simply treat this as some kind 
1336:                  of glitch and ignore the event altogether.  
1337:              Parameters:
1338:                  None
1339:               
1340:              Return Values:
1341:                  None       
1342:              
1343:              Remarks: 
1344:          		See also the USBDeviceDetach() API function documentation.                                                 
1345:          ****************************************************************************/
1346:          #if defined(USB_INTERRUPT)
1347:          void USBDeviceAttach(void)
1348:          {
1349:              //if we are in the detached state
1350:              if(USBDeviceState == DETACHED_STATE)
1351:              {
1352:                  if(USB_BUS_SENSE == 1)
1353:                  {
1354:              	    //Initialize registers to known states.
1355:                      U1CON = 0;          
1356:              
1357:                      // Mask all USB interrupts
1358:                      U1IE = 0;                                
1359:              
1360:                      //Configure things like: pull ups, full/low-speed mode, 
1361:                      //set the ping pong mode, and set internal transceiver
1362:                      SetConfigurationOptions();
1363:              
1364:                      USBEnableInterrupts();  //Modifies global interrupt settings
1365:              
1366:                      // Enable module & attach to bus
1367:                      while(!U1CONbits.USBEN){U1CONbits.USBEN = 1;}
1368:              
1369:                      //moved to the attached state
1370:                      USBDeviceState = ATTACHED_STATE;
1371:              
1372:                      #ifdef  USB_SUPPORT_OTG
1373:                          U1OTGCON = USB_OTG_DPLUS_ENABLE | USB_OTG_ENABLE;  
1374:                      #endif
1375:                  }
1376:              }
1377:          }
1378:          #endif  //#if defined(USB_INTERRUPT)
1379:          
1380:          
1381:          /*******************************************************************************
1382:            Function: void USBCtrlEPAllowStatusStage(void);
1383:          
1384:            Summary: This function prepares the proper endpoint 0 IN or endpoint 0 OUT
1385:                      (based on the controlTransferState) to allow the status stage packet
1386:                      of a control transfer to complete.  This function gets used
1387:                      internally by the USB stack itself, but it may also be called from
1388:                      the application firmware, IF the application firmware called
1389:                      the USBDeferStatusStage() function during the initial processing
1390:                      of the control transfer request.  In this case, the application
1391:                      must call the USBCtrlEPAllowStatusStage() once, after it has fully
1392:                      completed processing and handling the data stage portion of the
1393:                      request.
1394:          
1395:                      If the application firmware has no need for delaying control
1396:                      transfers, and therefore never calls USBDeferStatusStage(), then the
1397:                      application firmware should not call USBCtrlEPAllowStatusStage().
1398:          
1399:            Description:
1400:          
1401:            Conditions:
1402:              None
1403:          
1404:            Input:
1405:          
1406:            Return:
1407:          
1408:            Remarks:
1409:              None
1410:            *****************************************************************************/
1411:          void USBCtrlEPAllowStatusStage(void)
1412:          {
1413:              //Check and set two flags, prior to actually modifying any BDT entries.
1414:              //This double checking is necessary to make certain that 
1415:              //USBCtrlEPAllowStatusStage() can be called twice simultaneously (ex: once 
1416:              //in main loop context, while simultaneously getting an interrupt which 
1417:              //tries to call USBCtrlEPAllowStatusStage() again, at the same time).
1418:              if(USBStatusStageEnabledFlag1 == false)
0487  0022     MOVLB 0x2
0488  0852     MOVF USBStatusStageEnabledFlag1, W
0489  1D03     BTFSS STATUS, 0x2
048A  0008     RETURN
1419:              {
1420:                  USBStatusStageEnabledFlag1 = true;
048B  3001     MOVLW 0x1
048C  00D2     MOVWF USBStatusStageEnabledFlag1
1421:                  if(USBStatusStageEnabledFlag2 == false)
048D  0851     MOVF USBStatusStageEnabledFlag2, W
048E  1D03     BTFSS STATUS, 0x2
048F  0008     RETURN
1422:                  {
1423:                      USBStatusStageEnabledFlag2 = true;
0490  3001     MOVLW 0x1
0491  00D1     MOVWF USBStatusStageEnabledFlag2
1424:                  
1425:                      //Determine which endpoints (EP0 IN or OUT needs arming for the status
1426:                      //stage), based on the type of control transfer currently pending.
1427:                      if(controlTransferState == CTRL_TRF_RX)
0492  3002     MOVLW 0x2
0493  0659     XORWF controlTransferState, W
0494  1D03     BTFSS STATUS, 0x2
0495  2C9F     GOTO 0x49F
1428:                      {
1429:                          pBDTEntryIn[0]->CNT = 0;
0496  0A38     INCF pBDTEntryIn, W
0497  0086     MOVWF FSR1L
0498  0187     CLRF FSR1H
0499  0181     CLRF INDF1
1430:                          pBDTEntryIn[0]->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);        
049A  0838     MOVF pBDTEntryIn, W
049B  0086     MOVWF FSR1L
049C  3048     MOVLW 0x48
049D  3195     MOVLP 0x15
049E  2D86     GOTO 0x586
1431:                          pBDTEntryIn[0]->STAT.Val |= _USIE;
1432:                      }
1433:                      else if(controlTransferState == CTRL_TRF_TX)
049F  0B59     DECFSZ controlTransferState, W
04A0  0008     RETURN
1434:                      {
1435:                          BothEP0OutUOWNsSet = false;	//Indicator flag used in USBCtrlTrfOutHandler()
04A1  01D4     CLRF BothEP0OutUOWNsSet
1436:          
1437:                          //This buffer (when ping pong buffering is enabled on EP0 OUT) receives the
1438:                          //next SETUP packet.
1439:                          #if((USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG))
1440:                              pBDTEntryEP0OutCurrent->CNT = USB_EP0_BUFF_SIZE;
04A2  0021     MOVLB 0x1
04A3  0A69     INCF pBDTEntryEP0OutCurrent, W
04A4  0086     MOVWF FSR1L
04A5  3008     MOVLW 0x8
04A6  0187     CLRF FSR1H
04A7  0081     MOVWF INDF1
1441:                              pBDTEntryEP0OutCurrent->ADR = ConvertToPhysicalAddress(&SetupPkt);
04A8  3060     MOVLW 0x60
04A9  00F0     MOVWF 0xF0
04AA  01F1     CLRF 0xF1
04AB  0869     MOVF pBDTEntryEP0OutCurrent, W
04AC  25B0     CALL 0x5B0
04AD  3180     MOVLP 0x0
1442:                              pBDTEntryEP0OutCurrent->STAT.Val = _BSTALL; //Prepare endpoint to accept a SETUP transaction
04AE  0869     MOVF pBDTEntryEP0OutCurrent, W
04AF  0086     MOVWF FSR1L
04B0  3004     MOVLW 0x4
04B1  0081     MOVWF INDF1
1443:                              pBDTEntryEP0OutCurrent->STAT.Val |= _USIE;
04B2  0869     MOVF pBDTEntryEP0OutCurrent, W
04B3  0086     MOVWF FSR1L
04B4  1781     BSF INDF1, 0x7
1444:                              BothEP0OutUOWNsSet = true;	//Indicator flag used in USBCtrlTrfOutHandler()
04B5  0022     MOVLB 0x2
04B6  01D4     CLRF BothEP0OutUOWNsSet
04B7  0AD4     INCF BothEP0OutUOWNsSet, F
1445:                          #endif
1446:          
1447:                          //This EP0 OUT buffer receives the 0-byte OUT status stage packet.
1448:                          pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
04B8  0021     MOVLB 0x1
04B9  0A68     INCF pBDTEntryEP0OutNext, W
04BA  0086     MOVWF FSR1L
04BB  3008     MOVLW 0x8
04BC  0081     MOVWF INDF1
1449:                          pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
04BD  3060     MOVLW 0x60
04BE  00F0     MOVWF 0xF0
04BF  01F1     CLRF 0xF1
04C0  0868     MOVF pBDTEntryEP0OutNext, W
04C1  25B0     CALL 0x5B0
1450:                          pBDTEntryEP0OutNext->STAT.Val = _USIE;           // Note: DTSEN is 0
04C2  0868     MOVF pBDTEntryEP0OutNext, W
04C3  0086     MOVWF FSR1L
04C4  3080     MOVLW 0x80
04C5  0081     MOVWF INDF1
04C6  0008     RETURN
1451:                      }
1452:                  }    
1453:              }
1454:          }   
1455:          
1456:          
1457:          /*******************************************************************************
1458:            Function: void USBCtrlEPAllowDataStage(void);
1459:              
1460:            Summary: This function allows the data stage of either a host-to-device or
1461:                      device-to-host control transfer (with data stage) to complete.
1462:                      This function is meant to be used in conjunction with either the
1463:                      USBDeferOUTDataStage() or USBDeferINDataStage().  If the firmware
1464:                      does not call either USBDeferOUTDataStage() or USBDeferINDataStage(),
1465:                      then the firmware does not need to manually call 
1466:                      USBCtrlEPAllowDataStage(), as the USB stack will call this function
1467:                      instead.
1468:               
1469:            Description:
1470:              
1471:            Conditions: A control transfer (with data stage) should already be pending, 
1472:                          if the firmware calls this function.  Additionally, the firmware
1473:                          should have called either USBDeferOUTDataStage() or 
1474:                          USBDeferINDataStage() at the start of the control transfer, if
1475:                          the firmware will be calling this function manually.
1476:          
1477:            Input:
1478:          
1479:            Return:
1480:          
1481:            Remarks: 
1482:            *****************************************************************************/
1483:          void USBCtrlEPAllowDataStage(void)
1484:          {
1485:              USBDeferINDataStagePackets = false;
14B8  01D0     CLRF 0xD0
1486:              USBDeferOUTDataStagePackets = false;
14B9  01CF     CLRF 0xCF
1487:          
1488:              if(controlTransferState == CTRL_TRF_RX) //(<setup><out><out>...<out><in>)
14BA  3002     MOVLW 0x2
14BB  0659     XORWF 0xD9, W
14BC  1D03     BTFSS STATUS, 0x2
14BD  2CCE     GOTO 0x4CE
1489:              {
1490:                  //Prepare EP0 OUT to receive the first OUT data packet in the data stage sequence.
1491:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
14BE  0021     MOVLB 0x1
14BF  25E3     CALL 0x5E3
14C0  3194     MOVLP 0x14
1492:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
14C1  00F1     MOVWF 0xF1
14C2  01F2     CLRF 0xF2
14C3  0868     MOVF pBDTEntryEP0OutNext, W
14C4  3E02     ADDLW 0x2
14C5  0086     MOVWF FSR1L
14C6  0871     MOVF 0xF1, W
14C7  3FC0     MOVWI 0[FSR1]
14C8  0872     MOVF 0xF2, W
14C9  3FC1     MOVWI 1[FSR1]
1493:                  pBDTEntryEP0OutNext->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
14CA  0868     MOVF pBDTEntryEP0OutNext, W
14CB  0086     MOVWF FSR1L
14CC  3048     MOVLW 0x48
14CD  2DF3     GOTO 0x5F3
1494:                  pBDTEntryEP0OutNext->STAT.Val |= _USIE;
1495:              }   
1496:              else    //else must be controlTransferState == CTRL_TRF_TX (<setup><in><in>...<in><out>)
1497:              {
1498:                  //Error check the data stage byte count.  Make sure the user specified
1499:                  //value was no greater than the number of bytes the host requested.
1500:          		if(SetupPkt.wLength < inPipes[0].wCount.Val)
14CE  082B     MOVF 0xAB, W
14CF  0020     MOVLB 0x0
14D0  0267     SUBWF 0x67, W
14D1  1D03     BTFSS STATUS, 0x2
14D2  2CD7     GOTO 0x4D7
14D3  0022     MOVLB 0x2
14D4  082A     MOVF 0x12A, W
14D5  0020     MOVLB 0x0
14D6  0266     SUBWF 0x66, W
14D7  1803     BTFSC STATUS, 0x0
14D8  2CE0     GOTO 0x4E0
1501:          		{
1502:          			inPipes[0].wCount.Val = SetupPkt.wLength;
14D9  0867     MOVF 0x67, W
14DA  0022     MOVLB 0x2
14DB  00AB     MOVWF 0x12B
14DC  0020     MOVLB 0x0
14DD  0866     MOVF 0x66, W
14DE  0022     MOVLB 0x2
14DF  00AA     MOVWF 0x12A
1503:          		}
1504:          		USBCtrlTrfTxService();  //Copies one IN data packet worth of data from application buffer
14E0  2537     CALL 0x537
14E1  3194     MOVLP 0x14
1505:          		                        //to CtrlTrfData buffer.  Also keeps track of how many bytes remaining.
1506:          
1507:          	    //Cnt should have been initialized by responsible request owner (ex: by
1508:          	    //using the USBEP0SendRAMPtr() or USBEP0SendROMPtr() API function).
1509:          		pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
14E2  3068     MOVLW 0x68
14E3  00F1     MOVWF 0x171
14E4  01F2     CLRF 0x172
14E5  0838     MOVF pBDTEntryIn, W
14E6  3E02     ADDLW 0x2
14E7  0086     MOVWF FSR1L
14E8  0187     CLRF FSR1H
14E9  0871     MOVF 0x171, W
14EA  3FC0     MOVWI 0[FSR1]
14EB  0872     MOVF 0x172, W
14EC  3FC1     MOVWI 1[FSR1]
1510:          		pBDTEntryIn[0]->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
14ED  0838     MOVF pBDTEntryIn, W
14EE  0086     MOVWF FSR1L
14EF  3048     MOVLW 0x48
14F0  2D86     GOTO 0x586
1511:                  pBDTEntryIn[0]->STAT.Val |= _USIE;
1512:              }     
1513:          }    
1514:          
1515:          
1516:          /******************************************************************************/
1517:          /** Internal Functions *********************************************************/
1518:          /******************************************************************************/
1519:          
1520:          /********************************************************************
1521:           * Function:        void USBConfigureEndpoint(uint8_t EPNum, uint8_t direction)
1522:           *
1523:           * PreCondition:    None
1524:           *
1525:           * Input:           uint8_t EPNum - the endpoint to be configured
1526:           *                  uint8_t direction - the direction to be configured
1527:           *                                   (either OUT_FROM_HOST or IN_TO_HOST)
1528:           *
1529:           * Output:          None
1530:           *
1531:           * Side Effects:    None
1532:           *
1533:           * Overview:        This function will configure the specified 
1534:           *                  endpoint
1535:           *
1536:           * Note:            None
1537:           *******************************************************************/
1538:          static void USBConfigureEndpoint(uint8_t EPNum, uint8_t direction)
05C3  00F2     MOVWF 0x172
1539:          {
1540:              volatile BDT_ENTRY* handle;
1541:          
1542:              //Compute a pointer to the even BDT entry corresponding to the
1543:              //EPNum and direction values passed to this function.
1544:              handle = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN]; //Get address of start of BDT
05C4  3020     MOVLW 0x20
05C5  00F3     MOVWF 0x173
1545:              handle += EP(EPNum,direction,0u);     //Add in offset to the BDT of interest
05C6  0870     MOVF 0x170, W
05C7  00F1     MOVWF 0x171
05C8  35F1     LSLF 0x171, F
05C9  0872     MOVF 0x172, W
05CA  0709     ADDWF WREG, W
05CB  0709     ADDWF WREG, W
05CC  0771     ADDWF 0x171, W
05CD  0709     ADDWF WREG, W
05CE  0709     ADDWF WREG, W
05CF  07F3     ADDWF 0x173, F
1546:              
1547:              handle->STAT.UOWN = 0;  //mostly redundant, since USBStdSetCfgHandler() 
05D0  0873     MOVF 0x173, W
05D1  0086     MOVWF FSR1L
05D2  0187     CLRF FSR1H
05D3  1381     BCF INDF1, 0x7
1548:              //already cleared the entire BDT table
1549:          
1550:              //Make sure our pBDTEntryIn/Out[] pointer is initialized.  Needed later
1551:              //for USBTransferOnePacket() API calls.
1552:              if(direction == OUT_FROM_HOST)
05D4  0870     MOVF 0x170, W
05D5  1D03     BTFSS STATUS, 0x2
05D6  2DDA     GOTO 0x5DA
1553:              {
1554:                  pBDTEntryOut[EPNum] = handle;
05D7  0872     MOVF 0x172, W
05D8  3E3C     ADDLW 0x3C
05D9  2DDC     GOTO 0x5DC
1555:              }
1556:              else
1557:              {
1558:                  pBDTEntryIn[EPNum] = handle;
05DA  0872     MOVF 0x172, W
05DB  3E38     ADDLW 0x38
05DC  0086     MOVWF FSR1L
05DD  3001     MOVLW 0x1
05DE  0087     MOVWF FSR1H
05DF  0873     MOVF 0x173, W
05E0  0081     MOVWF INDF1
1559:              }
1560:          
1561:              #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
1562:                  handle->STAT.DTS = 0;
05E1  0873     MOVF 0x173, W
05E2  0086     MOVWF FSR1L
05E3  0187     CLRF FSR1H
05E4  1301     BCF INDF1, 0x6
1563:                  (handle+1)->STAT.DTS = 1;
05E5  0873     MOVF 0x173, W
05E6  3E04     ADDLW 0x4
05E7  0086     MOVWF FSR1L
05E8  1701     BSF INDF1, 0x6
1564:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG)
1565:                  //Set DTS to one because the first thing we will do
1566:                  //when transmitting is toggle the bit
1567:                  handle->STAT.DTS = 1;
1568:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
1569:                  if(EPNum != 0)
1570:                  {
1571:                      handle->STAT.DTS = 1;
1572:                  }
1573:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)    
1574:                  if(EPNum != 0)
1575:                  {
1576:                      handle->STAT.DTS = 0;
1577:                      (handle+1)->STAT.DTS = 1;
1578:                  }
1579:              #endif
1580:          }
05E9  0008     RETURN
1581:          
1582:          
1583:          /******************************************************************************
1584:           * Function:        void USBCtrlEPServiceComplete(void)
1585:           *
1586:           * PreCondition:    None
1587:           *
1588:           * Input:           None
1589:           *
1590:           * Output:          None
1591:           *
1592:           * Side Effects:    None
1593:           *
1594:           * Overview:        This routine wrap up the remaining tasks in servicing
1595:           *                  a Setup Request. Its main task is to set the endpoint
1596:           *                  controls appropriately for a given situation. See code
1597:           *                  below.
1598:           *                  There are three main scenarios:
1599:           *                  a) There was no handler for the Request, in this case
1600:           *                     a STALL should be sent out.
1601:           *                  b) The host has requested a read control transfer,
1602:           *                     endpoints are required to be setup in a specific way.
1603:           *                  c) The host has requested a write control transfer, or
1604:           *                     a control data stage is not required, endpoints are
1605:           *                     required to be setup in a specific way.
1606:           *
1607:           *                  Packet processing is resumed by clearing PKTDIS bit.
1608:           *
1609:           * Note:            None
1610:           *****************************************************************************/
1611:          static void USBCtrlEPServiceComplete(void)
1612:          {
1613:              /*
1614:               * PKTDIS bit is set when a Setup Transaction is received.
1615:               * Clear to resume packet processing.
1616:               */
1617:              USBPacketDisable = 0;
147F  003D     MOVLB 0x1D
1480  120E     BCF UCON, 0x4
1618:          
1619:          	//Check the busy bits and the SetupPtk.DataDir variables to determine what type of
1620:          	//control transfer is currently in progress.  We need to know the type of control
1621:          	//transfer that is currently pending, in order to know how to properly arm the 
1622:          	//EP0 IN and EP0 OUT endpoints.
1623:              if(inPipes[0].info.bits.busy == 0)
1481  0022     MOVLB 0x2
1482  1BA9     BTFSC 0x129, 0x7
1483  2C99     GOTO 0x499
1624:              {
1625:                  if(outPipes[0].info.bits.busy == 1)
1484  1FA2     BTFSS 0x122, 0x7
1485  2C90     GOTO 0x490
1626:                  {
1627:                      controlTransferState = CTRL_TRF_RX;
1486  3002     MOVLW 0x2
1487  00D9     MOVWF controlTransferState
1628:                      /*
1629:                       * Control Write:
1630:                       * <SETUP[0]><OUT[1]><OUT[0]>...<IN[1]> | <SETUP[0]>
1631:                       */
1632:          
1633:                      //1. Prepare OUT EP to receive data, unless a USB class request handler
1634:                      //   function decided to defer the data stage (ex: because the intended
1635:                      //   RAM buffer wasn't available yet) by calling USBDeferDataStage().
1636:                      //   If it did so, it is then responsible for calling USBCtrlEPAllowDataStage(),
1637:                      //   once it is ready to begin receiving the data.
1638:                      if(USBDeferOUTDataStagePackets == false)
1488  084F     MOVF USBDeferOUTDataStagePackets, W
1489  1D03     BTFSS STATUS, 0x2
148A  2C8C     GOTO 0x48C
1639:                      {
1640:                          USBCtrlEPAllowDataStage();
148B  24B8     CALL 0x4B8
1641:                      }
1642:                      
1643:                      //2.  IN endpoint 0 status stage will be armed by USBCtrlEPAllowStatusStage() 
1644:                      //after all of the OUT data has been received and consumed, or if a timeout occurs.
1645:                      USBStatusStageEnabledFlag2 = false;
148C  0022     MOVLB 0x2
148D  01D1     CLRF USBStatusStageEnabledFlag2
1646:                      USBStatusStageEnabledFlag1 = false;
148E  01D2     CLRF USBStatusStageEnabledFlag1
1647:                  }
148F  0008     RETURN
1648:                  else
1649:                  {
1650:                      /*
1651:                       * If no one knows how to service this request then stall.
1652:                       * Must also prepare EP0 to receive the next SETUP transaction.
1653:                       */
1654:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
1490  2567     CALL 0x567
1491  3194     MOVLP 0x14
1655:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
1492  258B     CALL 0x58B
1493  3194     MOVLP 0x14
1494  257D     CALL 0x57D
1495  3194     MOVLP 0x14
1496  2594     CALL 0x594
1497  3194     MOVLP 0x14
1498  2D86     GOTO 0x586
1656:                      pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
1657:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
1658:                      pBDTEntryIn[0]->STAT.Val = _BSTALL;
1659:                      pBDTEntryIn[0]->STAT.Val |= _USIE;
1660:                  }
1661:              }
1662:              else    // A module has claimed ownership of the control transfer session.
1663:              {
1664:          		if(SetupPkt.DataDir == USB_SETUP_DEVICE_TO_HOST_BITFIELD)
1499  0020     MOVLB 0x0
149A  1FE0     BTFSS SetupPkt, 0x7
149B  2CAD     GOTO 0x4AD
1665:          		{
1666:          			controlTransferState = CTRL_TRF_TX;
149C  0022     MOVLB 0x2
149D  01D9     CLRF controlTransferState
149E  0AD9     INCF controlTransferState, F
1667:          			/*
1668:          			 * Control Read:
1669:          			 * <SETUP[0]><IN[1]><IN[0]>...<OUT[1]> | <SETUP[0]>
1670:          			 *
1671:          			 * 1. Prepare IN EP to transfer data to the host.  If however the data
1672:          			 *    wasn't ready yet (ex: because the firmware needs to go and read it from
1673:          			 *    some slow/currently unavailable resource, such as an external I2C EEPconst),
1674:          			 *    Then the class request handler responsible should call the USBDeferDataStage()
1675:          			 *    macro.  In this case, the firmware may wait up to 500ms, before it is required
1676:          			 *    to transmit the first IN data packet.  Once the data is ready, and the firmware
1677:          			 *    is ready to begin sending the data, it should then call the 
1678:          			 *    USBCtrlEPAllowDataStage() function to start the data stage.
1679:          			 */
1680:          			if(USBDeferINDataStagePackets == false)
149F  0850     MOVF USBDeferINDataStagePackets, W
14A0  1D03     BTFSS STATUS, 0x2
14A1  2CA4     GOTO 0x4A4
1681:                      {
1682:                          USBCtrlEPAllowDataStage();
14A2  24B8     CALL 0x4B8
14A3  3194     MOVLP 0x14
1683:          			}
1684:          
1685:                      // 2. (Optionally) allow the status stage now, to prepare for early termination.
1686:                      //    Note: If a class request handler decided to set USBDeferStatusStagePacket == true,
1687:                      //    then it is responsible for eventually calling USBCtrlEPAllowStatusStage() once it
1688:                      //    is ready.  If the class request handler does this, it needs to be careful to
1689:                      //    be written so that it can handle the early termination scenario.
1690:                      //    Ex: It should call USBCtrlEPAllowStatusStage() when any of the following occurs:
1691:                      //    1.  The desired total number of bytes were sent to the host.
1692:                      //    2.  The number of bytes that the host originally requested (in the SETUP packet that 
1693:                      //        started the control transfer) has been reached.
1694:                      //    3.  Or, if a timeout occurs (ex: <50ms since the last successful EP0 IN transaction), regardless 
1695:                      //        of how many bytes have actually been sent.  This is necessary to prevent a deadlock situation
1696:                      //        (where the control transfer can't complete, due to continuous NAK on status stage) if the
1697:                      //        host performs early termination.  If enabled, the USB_ENABLE_STATUS_STAGE_TIMEOUTS usb_config.h
1698:                      //        option can take care of this for you.
1699:                      //    Note: For this type of control transfer, there is normally no harm in simply arming the
1700:                      //    status stage packet right now, even if the IN data is not ready yet.  This allows for
1701:                      //    immediate early termination, without adding unnecessary delay.  Therefore, it is generally not
1702:                      //    recommended for the USB class handler firmware to call USBDeferStatusStage(), for this 
1703:                      //    type of control transfer.  If the USB class handler firmware needs more time to fetch the IN
1704:                      //    data that needs to be sent to the host, it should instead use the USBDeferDataStage() function.
1705:                      USBStatusStageEnabledFlag2 = false;
14A4  0022     MOVLB 0x2
14A5  01D1     CLRF USBStatusStageEnabledFlag2
1706:                      USBStatusStageEnabledFlag1 = false;
14A6  01D2     CLRF USBStatusStageEnabledFlag1
1707:                      if(USBDeferStatusStagePacket == false)
14A7  0021     MOVLB 0x1
14A8  0867     MOVF USBDeferStatusStagePacket, W
14A9  1D03     BTFSS STATUS, 0x2
14AA  0008     RETURN
1708:                      {
1709:                          USBCtrlEPAllowStatusStage();
14AB  3184     MOVLP 0x4
14AC  2C87     GOTO 0x487
1710:                      } 
1711:          		}
1712:          		else   // (SetupPkt.DataDir == USB_SETUP_DIRECTION_HOST_TO_DEVICE)
1713:          		{
1714:          			//This situation occurs for special types of control transfers,
1715:          			//such as that which occurs when the host sends a SET_ADDRESS
1716:          			//control transfer.  Ex:
1717:          			//
1718:          			//<SETUP[0]><IN[1]> | <SETUP[0]>
1719:          				
1720:          			//Although the data direction is HOST_TO_DEVICE, there is no data stage
1721:          			//(hence: outPipes[0].info.bits.busy == 0).  There is however still
1722:          			//an IN status stage.
1723:          
1724:          			controlTransferState = CTRL_TRF_RX;     //Since this is a HOST_TO_DEVICE control transfer
14AD  3002     MOVLW 0x2
14AE  0022     MOVLB 0x2
14AF  00D9     MOVWF controlTransferState
14B0  2567     CALL 0x567
14B1  3194     MOVLP 0x14
14B2  258B     CALL 0x58B
14B3  3194     MOVLP 0x14
1725:          			
1726:          			//1. Prepare OUT EP to receive the next SETUP packet.
1727:          			pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
1728:          			pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
14B4  3FC1     MOVWI 1[FSR1]
1729:          			pBDTEntryEP0OutNext->STAT.Val = _BSTALL;
14B5  25F8     CALL 0x5F8
14B6  3194     MOVLP 0x14
1730:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
14B7  2CA4     GOTO 0x4A4
1731:          				
1732:          			//2. Prepare for IN status stage of the control transfer
1733:                      USBStatusStageEnabledFlag2 = false;
1734:                      USBStatusStageEnabledFlag1 = false;
1735:          			if(USBDeferStatusStagePacket == false)
1736:                      {
1737:                          USBCtrlEPAllowStatusStage();
1738:                      } 
1739:          		}
1740:          
1741:              }//end if(ctrl_trf_session_owner == MUID_NULL)
1742:          
1743:          }//end USBCtrlEPServiceComplete
1744:          
1745:          
1746:          /******************************************************************************
1747:           * Function:        void USBCtrlTrfTxService(void)
1748:           *
1749:           * PreCondition:    pSrc, wCount, and usb_stat.ctrl_trf_mem are setup properly.
1750:           *
1751:           * Input:           None
1752:           *
1753:           * Output:          None
1754:           *
1755:           * Side Effects:    None
1756:           *
1757:           * Overview:        This routine is used for device to host control transfers 
1758:           *					(IN transactions).  This function takes care of managing a
1759:           *                  transfer over multiple USB transactions.
1760:           *					This routine should be called from only two places.
1761:           *                  One from USBCtrlEPServiceComplete() and one from
1762:           *                  USBCtrlTrfInHandler().
1763:           *
1764:           * Note:            
1765:           *****************************************************************************/
1766:          static void USBCtrlTrfTxService(void)
1767:          {
1768:              uint8_t byteToSend;
1769:          
1770:              //Figure out how many bytes of data to send in the next IN transaction.
1771:              //Assume a full size packet, unless otherwise determined below.
1772:              byteToSend = USB_EP0_BUFF_SIZE;         
1537  3008     MOVLW 0x8
1538  00F0     MOVWF 0x170
1773:              if(inPipes[0].wCount.Val < (uint8_t)USB_EP0_BUFF_SIZE)
1539  3000     MOVLW 0x0
153A  0022     MOVLB 0x2
153B  022B     SUBWF 0x12B, W
153C  3008     MOVLW 0x8
153D  1903     BTFSC STATUS, 0x2
153E  022A     SUBWF 0x12A, W
153F  1803     BTFSC STATUS, 0x0
1540  2D4D     GOTO 0x54D
1774:              {
1775:                  byteToSend = inPipes[0].wCount.Val;
1541  082A     MOVF 0x12A, W
1542  00F0     MOVWF 0x170
1776:          
1777:                  //Keep track of whether or not we have sent a "short packet" yet.
1778:                  //This is useful so that later on, we can configure EP0 IN to STALL,
1779:                  //after we have sent all of the intended data.  This makes sure the
1780:                  //hardware STALLs if the host erroneously tries to send more IN token 
1781:                  //packets, requesting more data than intended in the control transfer.
1782:                  if(shortPacketStatus == SHORT_PKT_NOT_USED)
1543  085A     MOVF shortPacketStatus, W
1544  1D03     BTFSS STATUS, 0x2
1545  2D49     GOTO 0x549
1783:                  {
1784:                      shortPacketStatus = SHORT_PKT_PENDING;
1546  01DA     CLRF shortPacketStatus
1547  0ADA     INCF shortPacketStatus, F
1785:                  }
1548  2D4D     GOTO 0x54D
1786:                  else if(shortPacketStatus == SHORT_PKT_PENDING)
1549  0B5A     DECFSZ shortPacketStatus, W
154A  2D4D     GOTO 0x54D
1787:                  {
1788:                      shortPacketStatus = SHORT_PKT_SENT;
154B  3002     MOVLW 0x2
154C  00DA     MOVWF shortPacketStatus
1789:                  }
1790:              }
1791:          
1792:              //Keep track of how many bytes remain to be sent in the transfer, by
1793:              //subtracting the number of bytes about to be sent from the total.
1794:              inPipes[0].wCount.Val -= byteToSend;
154D  0870     MOVF 0x170, W
154E  02AA     SUBWF 0x12A, F
154F  1C03     BTFSS STATUS, 0x0
1550  03AB     DECF 0x12B, F
1795:              
1796:              //Next, load the number of bytes to send to BC7..0 in buffer descriptor.
1797:              //Note: Control endpoints may never have a max packet size of > 64 bytes.
1798:              //Therefore, the BC8 and BC9 bits should always be maintained clear.
1799:              pBDTEntryIn[0]->CNT = byteToSend;
1551  0A38     INCF pBDTEntryIn, W
1552  0086     MOVWF FSR1L
1553  0187     CLRF FSR1H
1554  0870     MOVF 0x170, W
1555  0081     MOVWF INDF1
1800:          
1801:              //Now copy the data from the source location, to the CtrlTrfData[] buffer,
1802:              //which we will send to the host.
1803:              pDst = (USB_VOLATILE uint8_t*)CtrlTrfData;                // Set destination pointer
1556  3068     MOVLW 0x68
1557  00D8     MOVWF pDst
1804:              if(inPipes[0].info.bits.ctrl_trf_mem == USB_EP0_ROM)   // Determine type of memory source
1558  1C29     BTFSS 0x129, 0x0
1559  2D5D     GOTO 0x55D
155A  2D63     GOTO 0x563
1805:              {
1806:                  while(byteToSend)
155D  0870     MOVF 0x170, W
155E  1903     BTFSC STATUS, 0x2
155F  0008     RETURN
1560  2D5B     GOTO 0x55B
1807:                  {
1808:                      *pDst++ = *inPipes[0].pSrc.bRom++;
155B  256E     CALL 0x56E
155C  3194     MOVLP 0x14
1809:                      byteToSend--;
1810:                  }//end while(byte_to_send.Val)
1811:              }
1812:              else  // RAM
1813:              {
1814:                  while(byteToSend)
1563  0870     MOVF 0x170, W
1815:                  {
1816:                      *pDst++ = *inPipes[0].pSrc.bRam++;
1561  256E     CALL 0x56E
1562  3194     MOVLP 0x14
1563  0870     MOVF 0x170, W
1564  1903     BTFSC STATUS, 0x2
1565  0008     RETURN
1566  2D61     GOTO 0x561
1817:                      byteToSend--;
1818:                  }//end while(byte_to_send.Val)
1819:              }//end if(usb_stat.ctrl_trf_mem == _const)
1820:          }//end USBCtrlTrfTxService
1821:          
1822:          /******************************************************************************
1823:           * Function:        void USBCtrlTrfRxService(void)
1824:           *
1825:           * PreCondition:    pDst and wCount are setup properly.
1826:           *                  pSrc is always &CtrlTrfData
1827:           *                  usb_stat.ctrl_trf_mem is always USB_EP0_RAM.
1828:           *                  wCount should be set to 0 at the start of each control
1829:           *                  transfer.
1830:           *
1831:           * Input:           None
1832:           *
1833:           * Output:          None
1834:           *
1835:           * Side Effects:    None
1836:           *
1837:           * Overview:        This routine is used for host to device control transfers
1838:           *					(uses OUT transactions).  This function receives the data that arrives
1839:           *					on EP0 OUT, and copies it into the appropriate outPipes[0].pDst.bRam
1840:           *					buffer.  Once the host has sent all the data it was intending
1841:           *					to send, this function will call the appropriate outPipes[0].pFunc()
1842:           *					handler (unless it is NULL), so that it can be used by the
1843:           *					intended target firmware.
1844:           *
1845:           * Note:            None
1846:           *****************************************************************************/
1847:          static void USBCtrlTrfRxService(void)
1848:          {
1849:              uint8_t byteToRead;
1850:              uint8_t i;
1851:          
1852:              //Load byteToRead with the number of bytes the host just sent us in the 
1853:              //last OUT transaction.
1854:              byteToRead = pBDTEntryEP0OutCurrent->CNT;   
1598  0021     MOVLB 0x1
1599  0869     MOVF pBDTEntryEP0OutCurrent, W
159A  0086     MOVWF FSR1L
159B  0187     CLRF FSR1H
159C  3F41     MOVIW 1[FSR1]
159D  00F5     MOVWF 0xF5
1855:          
1856:              //Update the "outPipes[0].wCount.Val", which keeps track of the total number
1857:              //of remaining bytes expected to be received from the host, in the control
1858:              //transfer.  First check to see if the host sent us more bytes than the
1859:              //application firmware was expecting to receive.
1860:              if(byteToRead > outPipes[0].wCount.Val)
159E  00F2     MOVWF 0xF2
159F  01F3     CLRF 0xF3
15A0  0873     MOVF 0xF3, W
15A1  0022     MOVLB 0x2
15A2  0224     SUBWF 0x124, W
15A3  1D03     BTFSS STATUS, 0x2
15A4  2DA7     GOTO 0x5A7
15A5  0872     MOVF 0x172, W
15A6  0223     SUBWF 0x123, W
15A7  1803     BTFSC STATUS, 0x0
15A8  2DAB     GOTO 0x5AB
1861:              {
1862:                  byteToRead = outPipes[0].wCount.Val;
15A9  0823     MOVF 0x123, W
15AA  00F5     MOVWF 0x175
1863:              }	
1864:              //Reduce the number of remaining bytes by the number we just received.
1865:              outPipes[0].wCount.Val -= byteToRead;
15AB  0875     MOVF 0x175, W
15AC  02A3     SUBWF 0x123, F
15AD  1C03     BTFSS STATUS, 0x0
15AE  03A4     DECF 0x124, F
1866:          
1867:              //Copy the OUT DATAx packet bytes that we just received from the host,
1868:              //into the user application buffer space.
1869:              for(i=0;i<byteToRead;i++)
15AF  01F4     CLRF 0x174
15B0  0875     MOVF 0x175, W
15B1  0274     SUBWF 0x174, W
15B2  1803     BTFSC STATUS, 0x0
15B3  2DC0     GOTO 0x5C0
15BE  0AF4     INCF 0x174, F
15BF  2DB0     GOTO 0x5B0
1870:              {
1871:                  *outPipes[0].pDst.bRam++ = CtrlTrfData[i];
15B4  0820     MOVF outPipes, W
15B5  0086     MOVWF FSR1L
15B6  0187     CLRF FSR1H
15B7  0874     MOVF 0x174, W
15B8  3E68     ADDLW 0x68
15B9  0084     MOVWF FSR0L
15BA  0185     CLRF FSR0H
15BB  0800     MOVF INDF0, W
15BC  0081     MOVWF INDF1
15BD  0AA0     INCF outPipes, F
1872:              }//end while(byteToRead.Val)
1873:          
1874:              //If there is more data to receive, prepare EP0 OUT so that it can receive 
1875:          	//the next packet in the sequence.
1876:              if(outPipes[0].wCount.Val > 0)
15C0  0823     MOVF 0x123, W
15C1  0424     IORWF 0x124, W
15C2  1903     BTFSC STATUS, 0x2
15C3  2DD5     GOTO 0x5D5
1877:              {
1878:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
15C4  0021     MOVLB 0x1
15C5  25E3     CALL 0x5E3
15C6  3194     MOVLP 0x14
1879:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&CtrlTrfData);
15C7  25E9     CALL 0x5E9
15C8  3194     MOVLP 0x14
1880:                  if(pBDTEntryEP0OutCurrent->STAT.DTS == 0)
15C9  0869     MOVF pBDTEntryEP0OutCurrent, W
15CA  0086     MOVWF FSR1L
15CC  1B01     BTFSC INDF1, 0x6
15CD  2DD1     GOTO 0x5D1
1881:                  {
1882:                      pBDTEntryEP0OutNext->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
15CB  0868     MOVF pBDTEntryEP0OutNext, W
15CE  0086     MOVWF FSR1L
15CF  3048     MOVLW 0x48
15D0  2DF3     GOTO 0x5F3
1883:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
1884:                  }
1885:                  else
1886:                  {
1887:                      pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED);
15D1  0086     MOVWF FSR1L
15D2  3008     MOVLW 0x8
15D3  0187     CLRF FSR1H
15D4  2DF3     GOTO 0x5F3
1888:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
1889:                  }
1890:              }
1891:              else
1892:              {
1893:          	    //We have received all OUT packets that we were expecting to
1894:          	    //receive for the control transfer.  Prepare EP0 OUT to receive
1895:          		//the next SETUP transaction that may arrive.
1896:                  pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
15D5  2567     CALL 0x567
15D6  3194     MOVLP 0x14
15D7  25E9     CALL 0x5E9
15D8  3194     MOVLP 0x14
15D9  25F8     CALL 0x5F8
15DA  3194     MOVLP 0x14
1897:                  pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
1898:                  //Configure EP0 OUT to receive the next SETUP transaction for any future
1899:                  //control transfers.  However, set BSTALL in case the host tries to send
1900:                  //more data than it claims it was going to send.
1901:                  pBDTEntryEP0OutNext->STAT.Val = _BSTALL;
1902:                  pBDTEntryEP0OutNext->STAT.Val |= _USIE;
1903:          
1904:          		//All data bytes for the host to device control write (OUT) have now been
1905:          		//received successfully.
1906:          		//Go ahead and call the user specified callback function, to use/consume
1907:          		//the control transfer data (ex: if the "void (*function)" parameter 
1908:          		//was non-NULL when USBEP0Receive() was called).
1909:                  if(outPipes[0].pFunc != NULL)
1910:                  {
1911:                      #if defined(__XC8)
1912:                          //Special pragmas to suppress an expected/harmless warning
1913:                          //message when building with the XC8 compiler
1914:                          #pragma warning push
1915:                          #pragma warning disable 1088
1916:                          outPipes[0].pFunc();    //Call the user's callback function
1917:                          #pragma warning pop
1918:                      #else
1919:                          outPipes[0].pFunc();    //Call the user's callback function
1920:                      #endif
1921:                  }
1922:                  outPipes[0].info.bits.busy = 0;    
15DB  0022     MOVLB 0x2
15DC  13A2     BCF 0x122, 0x7
1923:          
1924:                  //Ready to arm status stage IN transaction now, if the application
1925:                  //firmware has completed processing the request.  If it is still busy
1926:                  //and needs more time to finish handling the request, then the user
1927:                  //callback (the one called by the outPipes[0].pFunc();) should set the
1928:                  //USBDeferStatusStagePacket to true (by calling USBDeferStatusStage()).  In
1929:                  //this case, it is the application's firmware responsibility to call 
1930:                  //the USBCtrlEPAllowStatusStage() function, once it is fully done handling the request.
1931:                  //Note: The application firmware must process the request and call
1932:                  //USBCtrlEPAllowStatusStage() in a semi-timely fashion.  "Semi-timely"
1933:                  //means either 50ms, 500ms, or 5 seconds, depending on the type of
1934:                  //control transfer.  See the USB 2.0 specification section 9.2.6 for
1935:                  //more details.
1936:                  if(USBDeferStatusStagePacket == false)
15DD  0021     MOVLB 0x1
15DE  0867     MOVF USBDeferStatusStagePacket, W
15DF  1D03     BTFSS STATUS, 0x2
15E0  0008     RETURN
1937:                  {
1938:                      USBCtrlEPAllowStatusStage();
15E1  3184     MOVLP 0x4
15E2  2C87     GOTO 0x487
1939:                  }            
1940:              }    
1941:          
1942:          }//end USBCtrlTrfRxService
1943:          
1944:          
1945:          /********************************************************************
1946:           * Function:        void USBStdSetCfgHandler(void)
1947:           *
1948:           * PreCondition:    None
1949:           *
1950:           * Input:           None
1951:           *
1952:           * Output:          None
1953:           *
1954:           * Side Effects:    None
1955:           *
1956:           * Overview:        This routine first disables all endpoints by
1957:           *                  clearing UEP registers. It then configures
1958:           *                  (initializes) endpoints by calling the callback
1959:           *                  function USBCBInitEP().
1960:           *
1961:           * Note:            None
1962:           *******************************************************************/
1963:          static void USBStdSetCfgHandler(void)
1964:          {
1965:              uint8_t i;
1966:          
1967:              // This will generate a zero length packet
1968:              inPipes[0].info.bits.busy = 1;            
0AC1  0022     MOVLB 0x2
0AC3  17A9     BSF 0x129, 0x7
1969:          
1970:              //Clear all of the endpoint control registers
1971:              DisableNonZeroEndpoints(USB_MAX_EP_NUMBER);
0AC2  300E     MOVLW 0xE
0AC4  0021     MOVLB 0x1
0AC5  00A7     MOVWF 0xA7
0AC6  3099     MOVLW 0x99
0AC7  00A6     MOVWF p
0AC8  01A8     CLRF i
0AC9  0826     MOVF p, W
0ACA  0086     MOVWF FSR1L
0ACB  0827     MOVF 0xA7, W
0ACC  0087     MOVWF FSR1H
0ACD  0181     CLRF INDF1
0ACE  0AA6     INCF p, F
0ACF  1903     BTFSC STATUS, 0x2
0AD0  0AA7     INCF 0xA7, F
0AD1  3003     MOVLW 0x3
0AD2  0AA8     INCF i, F
0AD3  0228     SUBWF i, W
0AD4  1C03     BTFSS STATUS, 0x0
0AD5  2AC9     GOTO 0x2C9
1972:          
1973:              //Clear all of the BDT entries
1974:              memset((void*)&BDT[0], 0x00, sizeof(BDT));
0AD6  3020     MOVLW 0x20
0AD7  00F0     MOVWF 0xF0
0AD8  3040     MOVLW 0x40
0AD9  01F1     CLRF 0xF1
0ADA  2345     CALL 0x345
0ADB  3185     MOVLP 0x5
0ADC  2526     CALL 0x526
0ADD  3189     MOVLP 0x9
1975:          
1976:              // Assert reset request to all of the Ping Pong buffer pointers
1977:              USBPingPongBufferReset = 1;                                   
0ADE  003D     MOVLB 0x1D
0ADF  170E     BSF UCON, 0x6
1978:          
1979:          	//Re-Initialize all ping pong software state bits to 0 (which corresponds to
1980:          	//the EVEN buffer being the next one that will be used), since we are also 
1981:          	//doing a hardware ping pong pointer reset above.
1982:          	for(i = 0; i < (uint8_t)(USB_MAX_EP_NUMBER+1u); i++)
0AE0  0021     MOVLB 0x1
0AE1  01A9     CLRF i
0AEB  3004     MOVLW 0x4
0AED  0AA9     INCF i, F
0AEE  0229     SUBWF i, W
0AEF  1C03     BTFSS STATUS, 0x0
0AF0  2AE2     GOTO 0x2E2
1983:          	{
1984:          		ep_data_in[i].Val = 0u;
0AE2  0829     MOVF i, W
0AE3  3ED5     ADDLW 0xD5
0AE4  0086     MOVWF FSR1L
0AE5  3001     MOVLW 0x1
0AE6  0087     MOVWF FSR1H
0AE7  0181     CLRF INDF1
1985:                  ep_data_out[i].Val = 0u;
0AE8  0829     MOVF i, W
0AE9  3ED1     ADDLW 0xD1
0AEA  0086     MOVWF FSR1L
0AEC  0181     CLRF INDF1
1986:          	}
1987:          
1988:              //clear the alternate interface settings
1989:              memset((void*)&USBAlternateInterface,0x00,USB_MAX_NUM_INT);
0AF1  30D9     MOVLW 0xD9
0AF2  00F0     MOVWF 0xF0
0AF3  3001     MOVLW 0x1
0AF4  00F1     MOVWF 0xF1
0AF5  3003     MOVLW 0x3
0AF6  2345     CALL 0x345
0AF7  3185     MOVLP 0x5
0AF8  2526     CALL 0x526
0AF9  3189     MOVLP 0x9
1990:          
1991:              //Stop trying to reset ping pong buffer pointers
1992:              USBPingPongBufferReset = 0;
0AFA  003D     MOVLB 0x1D
0AFB  130E     BCF UCON, 0x6
1993:          
1994:              pBDTEntryIn[0] = (volatile BDT_ENTRY*)&BDT[EP0_IN_EVEN];
0AFC  3028     MOVLW 0x28
0AFD  0022     MOVLB 0x2
0AFE  00B8     MOVWF pBDTEntryIn
1995:          
1996:          	//Set the next out to the current out packet
1997:              pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[EP0_OUT_EVEN];
0AFF  3020     MOVLW 0x20
0B00  0021     MOVLB 0x1
0B01  00E9     MOVWF pBDTEntryEP0OutCurrent
1998:              pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
0B02  00E8     MOVWF pBDTEntryEP0OutNext
1999:          
2000:              //set the current configuration
2001:              USBActiveConfiguration = SetupPkt.bConfigurationValue;
0B03  0020     MOVLB 0x0
0B04  0862     MOVF 0x62, W
0B05  0022     MOVLB 0x2
0B06  00ED     MOVWF USBActiveConfiguration
2002:          
2003:              //if the configuration value == 0
2004:              if(USBActiveConfiguration == 0)
0B07  086D     MOVF USBActiveConfiguration, W
0B08  1D03     BTFSS STATUS, 0x2
0B09  2B0E     GOTO 0x30E
2005:              {
2006:                  //Go back to the addressed state
2007:                  USBDeviceState = ADDRESS_STATE;
0B0A  3010     MOVLW 0x10
0B0B  0021     MOVLB 0x1
0B0C  00EE     MOVWF USBDeviceState
2008:              }
0B0D  0008     RETURN
2009:              else
2010:              {
2011:                  //initialize the required endpoints
2012:                  USB_SET_CONFIGURATION_HANDLER(EVENT_CONFIGURED,(void*)&USBActiveConfiguration,1);
0B0E  0021     MOVLB 0x1
0B0F  306D     MOVLW 0x6D
0B10  01A0     CLRF __pcstackBANK1
0B11  0AA0     INCF __pcstackBANK1, F
0B12  01A1     CLRF sector_addr
0B13  00A2     MOVWF chk
0B14  3001     MOVLW 0x1
0B15  00A3     MOVWF 0xA3
0B16  01A4     CLRF i
0B17  0AA4     INCF i, F
0B18  01A5     CLRF address
0B19  3182     MOVLP 0x2
0B1A  2222     CALL 0x222
2013:          
2014:                  //Otherwise go to the configured state.  Update the state variable last,
2015:                  //after performing all of the set configuration related initialization
2016:                  //tasks.
2017:                  USBDeviceState = CONFIGURED_STATE;		
0B1B  3020     MOVLW 0x20
0B1C  0021     MOVLB 0x1
0B1D  00EE     MOVWF USBDeviceState
2018:              }//end if(SetupPkt.bConfigurationValue == 0)
2019:          }//end USBStdSetCfgHandler
0B1E  0008     RETURN
2020:          
2021:          
2022:          /********************************************************************
2023:           * Function:        void USBStdGetDscHandler(void)
2024:           *
2025:           * PreCondition:    None
2026:           *
2027:           * Input:           None
2028:           *
2029:           * Output:          None
2030:           *
2031:           * Side Effects:    None
2032:           *
2033:           * Overview:        This routine handles the standard GET_DESCRIPTOR
2034:           *                  request.
2035:           *
2036:           * Note:            None
2037:           *******************************************************************/
2038:          static void USBStdGetDscHandler(void)
2039:          {
2040:              if(SetupPkt.bmRequestType == 0x80)
0A30  3080     MOVLW 0x80
0A31  0020     MOVLB 0x0
0A32  0660     XORWF SetupPkt, W
0A33  1D03     BTFSS STATUS, 0x2
0A34  0008     RETURN
2041:              {
2042:                  inPipes[0].info.Val = USB_EP0_ROM | USB_EP0_BUSY | USB_EP0_INCLUDE_ZERO;
0A35  30C0     MOVLW 0xC0
0A36  0022     MOVLB 0x2
0A37  00A9     MOVWF 0x129
2043:          
2044:                  switch(SetupPkt.bDescriptorType)
0A38  2A72     GOTO 0x272
0A72  0020     MOVLB 0x0
0A73  0863     MOVF 0x63, W
0A74  3A01     XORLW 0x1
0A75  1903     BTFSC STATUS, 0x2
0A76  2A39     GOTO 0x239
0A77  3A03     XORLW 0x3
0A78  1903     BTFSC STATUS, 0x2
0A79  2A42     GOTO 0x242
0A7A  3A01     XORLW 0x1
0A7B  1903     BTFSC STATUS, 0x2
0A7C  2A5F     GOTO 0x25F
0A7D  2A5C     GOTO 0x25C
2045:                  {
2046:                      case USB_DESCRIPTOR_DEVICE:
2047:                          #if !defined(USB_USER_DEVICE_DESCRIPTOR)
2048:                              inPipes[0].pSrc.bRom = (const uint8_t*)&device_dsc;
2049:                          #else
2050:                              inPipes[0].pSrc.bRom = (const uint8_t*)USB_USER_DEVICE_DESCRIPTOR;
0A39  301C     MOVLW 0x1C
0A3A  0022     MOVLB 0x2
0A3B  00A7     MOVWF inPipes
0A3C  3091     MOVLW 0x91
0A3D  00A8     MOVWF 0x128
2051:                          #endif
2052:                          inPipes[0].wCount.Val = sizeof(device_dsc);
0A3E  3012     MOVLW 0x12
0A3F  00AA     MOVWF 0x12A
0A40  01AB     CLRF 0x12B
2053:                          break;
0A41  0008     RETURN
2054:                      case USB_DESCRIPTOR_CONFIGURATION:
2055:                          //First perform error case check, to make sure the host is requesting a 
2056:                          //legal descriptor index.  If the request index is illegal, don't do 
2057:                          //anything (so that the default STALL response will be sent).
2058:                          if(SetupPkt.bDscIndex < USB_MAX_NUM_CONFIG_DSC)
0A42  0862     MOVF 0x162, W
0A43  1D03     BTFSS STATUS, 0x2
0A44  2A5C     GOTO 0x25C
2059:                          {
2060:                              #if !defined(USB_USER_CONFIG_DESCRIPTOR)
2061:                                  inPipes[0].pSrc.bRom = *(USB_CD_Ptr+SetupPkt.bDscIndex);
2062:                              #else
2063:                                  inPipes[0].pSrc.bRom = *(USB_USER_CONFIG_DESCRIPTOR+SetupPkt.bDscIndex);
0A45  0862     MOVF 0x162, W
0A46  00F0     MOVWF 0x170
0A47  3054     MOVLW 0x54
0A48  2357     CALL 0x357
0A49  3189     MOVLP 0x9
0A4A  3091     MOVLW 0x91
0A4B  233D     CALL 0x33D
0A4C  3189     MOVLP 0x9
2064:                              #endif
2065:          
2066:                              //This must be loaded using byte addressing.  The source pointer
2067:                              //  may not be word aligned for the 16 or 32 bit machines resulting
2068:                              //  in an address error on the dereference.
2069:                              inPipes[0].wCount.byte.LB = *(inPipes[0].pSrc.bRom+2);
0A4D  00F1     MOVWF 0x171
0A4E  0827     MOVF inPipes, W
0A4F  00F0     MOVWF 0x170
0A50  3E02     ADDLW 0x2
0A51  234A     CALL 0x34A
0A52  3189     MOVLP 0x9
0A53  00AA     MOVWF 0x12A
2070:                              inPipes[0].wCount.byte.HB = *(inPipes[0].pSrc.bRom+3);
0A54  0828     MOVF 0x128, W
0A55  00F1     MOVWF 0x171
0A56  0827     MOVF inPipes, W
0A57  00F0     MOVWF 0x170
0A58  3E03     ADDLW 0x3
0A59  234A     CALL 0x34A
0A5A  00AB     MOVWF 0x12B
2071:                          }
0A5B  0008     RETURN
2072:          				else
2073:          				{
2074:          					inPipes[0].info.Val = 0;
0A5C  0022     MOVLB 0x2
0A5D  01A9     CLRF 0x129
0A5E  0008     RETURN
2075:          				}
2076:                          break;
2077:                      case USB_DESCRIPTOR_STRING:
2078:                          //USB_NUM_STRING_DESCRIPTORS was introduced as optional in release v2.3.  In v2.4 and
2079:                          //  later it is now mandatory.  This should be defined in usb_config.h and should
2080:                          //  indicate the number of string descriptors.
2081:                          if(SetupPkt.bDscIndex<USB_NUM_STRING_DESCRIPTORS)
0A5F  3004     MOVLW 0x4
0A60  0262     SUBWF 0x162, W
0A61  1803     BTFSC STATUS, 0x0
0A62  2A5C     GOTO 0x25C
2082:                          {
2083:                              //Get a pointer to the String descriptor requested
2084:                              inPipes[0].pSrc.bRom = *(USB_SD_Ptr+SetupPkt.bDscIndex);
0A63  0862     MOVF 0x162, W
0A64  00F0     MOVWF 0x170
0A65  3048     MOVLW 0x48
0A66  2357     CALL 0x357
0A67  3189     MOVLP 0x9
0A68  3091     MOVLW 0x91
0A69  233D     CALL 0x33D
2085:                              // Set data count
2086:                              inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;                    
0A6A  0827     MOVF inPipes, W
0A6B  0084     MOVWF FSR0L
0A6C  0828     MOVF 0x128, W
0A6D  0085     MOVWF FSR0H
0A6E  0800     MOVF INDF0, W
0A6F  00AA     MOVWF 0x12A
0A70  01AB     CLRF 0x12B
2087:                          }
0A71  0008     RETURN
2088:                          #if defined(IMPLEMENT_MICROSOFT_OS_DESCRIPTOR)
2089:                          else if(SetupPkt.bDscIndex == MICROSOFT_OS_DESCRIPTOR_INDEX)
2090:                          {
2091:                              //Get a pointer to the special MS OS string descriptor requested
2092:                              inPipes[0].pSrc.bRom = (const uint8_t*)&MSOSDescriptor;
2093:                              // Set data count
2094:                              inPipes[0].wCount.Val = *inPipes[0].pSrc.bRom;                    
2095:                          }    
2096:                          #endif
2097:                          else
2098:                          {
2099:                              inPipes[0].info.Val = 0;
2100:                          }
2101:                          break;
2102:                      default:
2103:                          inPipes[0].info.Val = 0;
2104:                          break;
2105:                  }//end switch
2106:              }//end if
2107:          }//end USBStdGetDscHandler
0A7E  0008     RETURN
2108:          
2109:          /********************************************************************
2110:           * Function:        void USBStdGetStatusHandler(void)
2111:           *
2112:           * PreCondition:    None
2113:           *
2114:           * Input:           None
2115:           *
2116:           * Output:          None
2117:           *
2118:           * Side Effects:    None
2119:           *
2120:           * Overview:        This routine handles the standard GET_STATUS request
2121:           *
2122:           * Note:            None
2123:           *******************************************************************/
2124:          static void USBStdGetStatusHandler(void)
2125:          {
2126:              CtrlTrfData[0] = 0;                 // Initialize content
0A7F  0020     MOVLB 0x0
0A80  01E8     CLRF CtrlTrfData
2127:              CtrlTrfData[1] = 0;
0A81  01E9     CLRF 0x69
2128:          
2129:              switch(SetupPkt.Recipient)
0A82  2AAC     GOTO 0x2AC
0AAC  0860     MOVF SetupPkt, W
0AAD  391F     ANDLW 0x1F
0AAE  1903     BTFSC STATUS, 0x2
0AAF  2A83     GOTO 0x283
0AB0  3A01     XORLW 0x1
0AB1  1903     BTFSC STATUS, 0x2
0AB2  2A8D     GOTO 0x28D
0AB3  3A03     XORLW 0x3
0AB4  1903     BTFSC STATUS, 0x2
0AB5  2A90     GOTO 0x290
0AB6  2AB7     GOTO 0x2B7
2130:              {
2131:                  case USB_SETUP_RECIPIENT_DEVICE_BITFIELD:
2132:                      inPipes[0].info.bits.busy = 1;
0A83  0022     MOVLB 0x2
0A84  17A9     BSF 0x129, 0x7
2133:                      /*
2134:                       * [0]: bit0: Self-Powered Status [0] Bus-Powered [1] Self-Powered
2135:                       *      bit1: RemoteWakeup        [0] Disabled    [1] Enabled
2136:                       */
2137:                      if(self_power == 1) // self_power is defined in HardwareProfile.h
2138:                      {
2139:                          CtrlTrfData[0]|=0x01;
0A85  0020     MOVLB 0x0
0A86  1468     BSF CtrlTrfData, 0x0
2140:                      }
2141:          
2142:                      if(RemoteWakeup == true)
0A87  0022     MOVLB 0x2
0A88  0B57     DECFSZ RemoteWakeup, W
0A89  2AB7     GOTO 0x2B7
2143:                      {
2144:                          CtrlTrfData[0]|=0x02;
0A8A  0020     MOVLB 0x0
0A8B  14E8     BSF CtrlTrfData, 0x1
0A8C  2AB7     GOTO 0x2B7
2145:                      }
2146:                      break;
2147:                  case USB_SETUP_RECIPIENT_INTERFACE_BITFIELD:
2148:                      inPipes[0].info.bits.busy = 1;     // No data to update
0A8D  0022     MOVLB 0x2
0A8E  17A9     BSF 0x129, 0x7
2149:                      break;
0A8F  2AB7     GOTO 0x2B7
2150:                  case USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD:
2151:                      inPipes[0].info.bits.busy = 1;
0A90  0022     MOVLB 0x2
0A91  17A9     BSF 0x129, 0x7
2152:                      /*
2153:                       * [0]: bit0: Halt Status [0] Not Halted [1] Halted
2154:                       */
2155:                      {
2156:                          BDT_ENTRY *p;
2157:          
2158:                          if(SetupPkt.EPDir == 0)
0A92  0020     MOVLB 0x0
0A93  1BE4     BTFSC 0x64, 0x7
0A94  2A99     GOTO 0x299
2159:                          {
2160:                              p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
0A95  0864     MOVF 0x64, W
0A96  390F     ANDLW 0xF
0A97  3E3C     ADDLW 0x3C
0A98  2A9C     GOTO 0x29C
2161:                          }
2162:                          else
2163:                          {
2164:                              p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
0A99  0864     MOVF 0x64, W
0A9A  390F     ANDLW 0xF
0A9B  3E38     ADDLW 0x38
0A9C  0086     MOVWF FSR1
0A9D  3001     MOVLW 0x1
0A9E  0087     MOVWF FSR1H
0A9F  0801     MOVF INDF1, W
0AA0  00F0     MOVWF __pcstackCOMMON
2165:                          }
2166:          
2167:                          if((p->STAT.UOWN == 1) && (p->STAT.BSTALL == 1))
0AA1  0086     MOVWF FSR1
0AA2  0187     CLRF FSR1H
0AA3  1F81     BTFSS INDF1, 0x7
0AA4  2AB7     GOTO 0x2B7
0AA5  0870     MOVF __pcstackCOMMON, W
0AA6  0086     MOVWF FSR1
0AA7  1D01     BTFSS INDF1, 0x2
0AA8  2AB7     GOTO 0x2B7
2168:                              CtrlTrfData[0]=0x01;    // Set bit0
0AA9  3001     MOVLW 0x1
0AAA  00E8     MOVWF CtrlTrfData
0AAB  2AB7     GOTO 0x2B7
2169:                          break;
2170:                      }
2171:              }//end switch
2172:          
2173:              if(inPipes[0].info.bits.busy == 1)
0AB7  0022     MOVLB 0x2
0AB8  1FA9     BTFSS 0x129, 0x7
0AB9  0008     RETURN
2174:              {
2175:                  inPipes[0].pSrc.bRam = (uint8_t*)&CtrlTrfData;        // Set Source
0ABA  3068     MOVLW 0x68
0ABB  00A7     MOVWF inPipes
0ABD  01A8     CLRF 0x128
2176:                  inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;      // Set memory type
0ABE  1429     BSF 0x129, 0x0
2177:                  inPipes[0].wCount.v[0] = 2;                           // Set data count
0ABC  3002     MOVLW 0x2
0ABF  00AA     MOVWF 0x12A
2178:              }//end if(...)
2179:          }//end USBStdGetStatusHandler
0AC0  0008     RETURN
2180:          
2181:          /********************************************************************
2182:           * Function:        void USBStallHandler(void)
2183:           *
2184:           * PreCondition:    None
2185:           *
2186:           * Input:           None
2187:           *
2188:           * Output:          None
2189:           *
2190:           * Side Effects:    
2191:           *
2192:           * Overview:        This function handles the event of a STALL 
2193:           *                  occurring on the bus
2194:           *
2195:           * Note:            None
2196:           *******************************************************************/
2197:          static void USBStallHandler(void)
2198:          {
2199:              /*
2200:               * Does not really have to do anything here,
2201:               * even for the control endpoint.
2202:               * All BDs of Endpoint 0 are owned by SIE right now,
2203:               * but once a Setup Transaction is received, the ownership
2204:               * for EP0_OUT will be returned to CPU.
2205:               * When the Setup Transaction is serviced, the ownership
2206:               * for EP0_IN will then be forced back to CPU by firmware.
2207:               */
2208:          
2209:              if(U1EP0bits.EPSTALL == 1)
02A2  1C18     BTFSS DACCON0, 0x0
02A3  2ABD     GOTO 0x2BD
2210:              {
2211:                  // UOWN - if 0, owned by CPU, if 1, owned by SIE
2212:                  if((pBDTEntryEP0OutCurrent->STAT.Val == _USIE) && (pBDTEntryIn[0]->STAT.Val == (_USIE|_BSTALL)))
02A4  0021     MOVLB 0x1
02A5  0869     MOVF pBDTEntryEP0OutCurrent, W
02A6  0086     MOVWF FSR1L
02A7  3080     MOVLW 0x80
02A8  0187     CLRF FSR1H
02A9  0601     XORWF INDF1, W
02AA  1D03     BTFSS STATUS, 0x2
02AB  2ABB     GOTO 0x2BB
02AC  0022     MOVLB 0x2
02AD  0838     MOVF pBDTEntryIn, W
02AE  0086     MOVWF FSR1L
02AF  3084     MOVLW 0x84
02B0  0601     XORWF INDF1, W
02B1  1D03     BTFSS STATUS, 0x2
02B2  2ABB     GOTO 0x2BB
2213:                  {
2214:                      // Set ep0Bo to stall also
2215:                      pBDTEntryEP0OutCurrent->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
02B3  0021     MOVLB 0x1
02B4  0869     MOVF pBDTEntryEP0OutCurrent, W
02B5  0086     MOVWF FSR1L
02B6  300C     MOVLW 0xC
02B7  0081     MOVWF INDF1
2216:                      pBDTEntryEP0OutCurrent->STAT.Val |= _USIE;
02B8  0869     MOVF pBDTEntryEP0OutCurrent, W
02B9  0086     MOVWF FSR1L
02BA  1781     BSF INDF1, 0x7
2217:                  }//end if
2218:                  U1EP0bits.EPSTALL = 0;               // Clear stall status
02BB  003D     MOVLB 0x1D
02BC  1018     BCF UEP0, 0x0
2219:              }//end if
2220:          
2221:              USBClearInterruptFlag(USBStallIFReg,USBStallIFBitNum);
02BD  1290     BCF UIR, 0x5
2222:          }
02BE  0008     RETURN
2223:          
2224:          /********************************************************************
2225:           * Function:        void USBSuspend(void)
2226:           *
2227:           * PreCondition:    None
2228:           *
2229:           * Input:           None
2230:           *
2231:           * Output:          None
2232:           *
2233:           * Side Effects:    
2234:           *
2235:           * Overview:        This function handles if the host tries to 
2236:           *                  suspend the device
2237:           *
2238:           * Note:            None
2239:           *******************************************************************/
2240:          static void USBSuspend(void)
2241:          {
2242:              /*
2243:               * NOTE: Do not clear UIRbits.ACTVIF here!
2244:               * Reason:
2245:               * ACTVIF is only generated once an IDLEIF has been generated.
2246:               * This is a 1:1 ratio interrupt generation.
2247:               * For every IDLEIF, there will be only one ACTVIF regardless of
2248:               * the number of subsequent bus transitions.
2249:               *
2250:               * If the ACTIF is cleared here, a problem could occur when:
2251:               * [       IDLE       ][bus activity ->
2252:               * <--- 3 ms ----->     ^
2253:               *                ^     ACTVIF=1
2254:               *                IDLEIF=1
2255:               *  #           #           #           #   (#=Program polling flags)
2256:               *                          ^
2257:               *                          This polling loop will see both
2258:               *                          IDLEIF=1 and ACTVIF=1.
2259:               *                          However, the program services IDLEIF first
2260:               *                          because ACTIVIE=0.
2261:               *                          If this routine clears the only ACTIVIF,
2262:               *                          then it can never get out of the suspend
2263:               *                          mode.
2264:               */
2265:              USBActivityIE = 1;                     // Enable bus activity interrupt
0503  1512     BSF UIE, 0x2
2266:              USBClearInterruptFlag(USBIdleIFReg,USBIdleIFBitNum);
0504  1210     BCF UIR, 0x4
2267:          
2268:              #if defined(__18CXX) || defined(_PIC14E) || defined(__XC8)
2269:                  U1CONbits.SUSPND = 1;                   // Put USB module in power conserve
0505  148E     BSF UCON, 0x1
2270:                                                          // mode, SIE clock inactive
2271:              #endif
2272:              USBBusIsSuspended = true;
0506  0022     MOVLB 0x2
0508  01D6     CLRF USBBusIsSuspended
0509  0AD6     INCF USBBusIsSuspended, F
2273:              USBTicksSinceSuspendEnd = 0;
050A  01CE     CLRF USBTicksSinceSuspendEnd
2274:           
2275:              /*
2276:               * At this point the PIC can go into sleep,idle, or
2277:               * switch to a slower clock, etc.  This should be done in the
2278:               * USBCBSuspend() if necessary.
2279:               */
2280:              USB_SUSPEND_HANDLER(EVENT_SUSPEND,0,0);
0507  3075     MOVLW 0x75
050B  318B     MOVLP 0xB
050C  232B     CALL 0x32B
050D  3180     MOVLP 0x0
050E  2A22     GOTO 0x222
2281:          }
2282:          
2283:          /********************************************************************
2284:           * Function:        void USBWakeFromSuspend(void)
2285:           *
2286:           * PreCondition:    None
2287:           *
2288:           * Input:           None
2289:           *
2290:           * Output:          None
2291:           *
2292:           * Side Effects:    None
2293:           *
2294:           * Overview:
2295:           *
2296:           * Note:            None
2297:           *******************************************************************/
2298:          static void USBWakeFromSuspend(void)
2299:          {
2300:              USBBusIsSuspended = false;
050F  0022     MOVLB 0x2
0511  01D6     CLRF USBBusIsSuspended
2301:          
2302:              /*
2303:               * If using clock switching, the place to restore the original
2304:               * microcontroller core clock frequency is in the USBCBWakeFromSuspend() callback
2305:               */
2306:              USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0);
0510  3074     MOVLW 0x74
0512  0021     MOVLB 0x1
0513  00A0     MOVWF __pcstackBANK1
0514  3000     MOVLW 0x0
0515  01A1     CLRF sector_addr
0516  01A2     CLRF chk
0517  01A3     CLRF 0xA3
0518  01A4     CLRF i
0519  01A5     CLRF address
051A  2222     CALL 0x222
051B  3180     MOVLP 0x0
2307:          
2308:              #if defined(__18CXX) || defined(_PIC14E) || defined(__XC8)
2309:                  //To avoid improperly clocking the USB module, make sure the oscillator
2310:                  //settings are consistent with USB operation before clearing the SUSPND bit.
2311:                  //Make sure the correct oscillator settings are selected in the 
2312:                  //"USB_WAKEUP_FROM_SUSPEND_HANDLER(EVENT_RESUME,0,0)" handler.
2313:                  U1CONbits.SUSPND = 0;   // Bring USB module out of power conserve
051C  003D     MOVLB 0x1D
051D  108E     BCF UCON, 0x1
2314:                                          // mode.
2315:              #endif
2316:          
2317:          
2318:              USBActivityIE = 0;
051E  1112     BCF UIE, 0x2
2319:          
2320:              /********************************************************************
2321:              Bug Fix: Feb 26, 2007 v2.1
2322:              *********************************************************************
2323:              The ACTVIF bit cannot be cleared immediately after the USB module wakes
2324:              up from Suspend or while the USB module is suspended. A few clock cycles
2325:              are required to synchronize the internal hardware state machine before
2326:              the ACTIVIF bit can be cleared by firmware. Clearing the ACTVIF bit
2327:              before the internal hardware is synchronized may not have an effect on
2328:              the value of ACTVIF. Additionally, if the USB module uses the clock from
2329:              the 96 MHz PLL source, then after clearing the SUSPND bit, the USB
2330:              module may not be immediately operational while waiting for the 96 MHz
2331:              PLL to lock.
2332:              ********************************************************************/
2333:          
2334:              // UIRbits.ACTVIF = 0;                      // Removed
2335:              #if defined(__18CXX) || defined(__XC8)
2336:              while(USBActivityIF)
0522  2D1F     GOTO 0x51F
2337:              #endif
2338:              {
2339:                  USBClearInterruptFlag(USBActivityIFReg,USBActivityIFBitNum);
0521  1110     BCF UIR, 0x2
2340:              }  // Added
051F  1D10     BTFSS UIR, 0x2
0520  2D23     GOTO 0x523
2341:          
2342:              USBTicksSinceSuspendEnd = 0;
0523  0022     MOVLB 0x2
0524  01CE     CLRF USBTicksSinceSuspendEnd
2343:          
2344:          }//end USBWakeFromSuspend
0525  0008     RETURN
2345:          
2346:          /********************************************************************
2347:           * Function:        void USBCtrlEPService(void)
2348:           *
2349:           * PreCondition:    USTAT is loaded with a valid endpoint address.
2350:           *
2351:           * Input:           None
2352:           *
2353:           * Output:          None
2354:           *
2355:           * Side Effects:    None
2356:           *
2357:           * Overview:        USBCtrlEPService checks for three transaction
2358:           *                  types that it knows how to service and services
2359:           *                  them:
2360:           *                  1. EP0 SETUP
2361:           *                  2. EP0 OUT
2362:           *                  3. EP0 IN
2363:           *                  It ignores all other types (i.e. EP1, EP2, etc.)
2364:           *
2365:           * Note:            None
2366:           *******************************************************************/
2367:          static void USBCtrlEPService(void)
2368:          {
2369:              //If we get to here, that means a successful transaction has just occurred 
2370:              //on EP0.  This means "progress" has occurred in the currently pending 
2371:              //control transfer, so we should re-initialize our timeout counter.
2372:              #if defined(USB_ENABLE_STATUS_STAGE_TIMEOUTS)
2373:                  USBStatusStageTimeoutCounter = USB_STATUS_STAGE_TIMEOUT;
04C7  302D     MOVLW 0x2D
04C8  00D3     MOVWF USBStatusStageTimeoutCounter
2374:              #endif
2375:          	
2376:          	//Check if the last transaction was on EP0 OUT endpoint (of any kind, to either the even or odd buffer if ping pong buffers used)
2377:              if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_OUT_EVEN)
04C9  0021     MOVLB 0x1
04CA  086F     MOVF USTATcopy, W
04CB  39FD     ANDLW 0xFD
04CC  1D03     BTFSS STATUS, 0x2
04CD  2CFB     GOTO 0x4FB
2378:              {
2379:          		//Point to the EP0 OUT buffer of the buffer that arrived
2380:                  #if defined (_PIC14E) || defined(__18CXX) || defined(__XC8)
2381:                      pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>1];
04CE  366F     LSRF USTATcopy, W
04CF  393F     ANDLW 0x3F
04D0  0709     ADDWF WREG, W
04D1  0709     ADDWF WREG, W
04D2  3E20     ADDLW 0x20
04D3  00E9     MOVWF pBDTEntryEP0OutCurrent
2382:                  #elif defined(__C30__) || defined(__C32__) || defined __XC16__
2383:                      pBDTEntryEP0OutCurrent = (volatile BDT_ENTRY*)&BDT[(USTATcopy.Val & USTAT_EP_MASK)>>2];
2384:                  #else
2385:                      #error "unimplemented"
2386:                  #endif
2387:          
2388:          		//Set the next out to the current out packet
2389:                  pBDTEntryEP0OutNext = pBDTEntryEP0OutCurrent;
04D4  00E8     MOVWF pBDTEntryEP0OutNext
2390:          		//Toggle it to the next ping pong buffer (if applicable)
2391:                  ((uint8_t_VAL*)&pBDTEntryEP0OutNext)->Val ^= USB_NEXT_EP0_OUT_PING_PONG;
04D5  3004     MOVLW 0x4
04D6  06E8     XORWF pBDTEntryEP0OutNext, F
2392:          
2393:          		//If the current EP0 OUT buffer has a SETUP packet
2394:                  if(pBDTEntryEP0OutCurrent->STAT.PID == PID_SETUP)
04D7  0869     MOVF pBDTEntryEP0OutCurrent, W
04D8  0086     MOVWF FSR1L
04D9  0187     CLRF FSR1H
04DA  0C01     RRF INDF1, W
04DB  0C89     RRF WREG, F
04DC  390F     ANDLW 0xF
04DD  3A0D     XORLW 0xD
04DE  1D03     BTFSS STATUS, 0x2
04DF  2CFA     GOTO 0x4FA
2395:                  {
2396:          	        //The SETUP transaction data may have gone into the the CtrlTrfData 
2397:          	        //buffer, or elsewhere, depending upon how the BDT was prepared
2398:          	        //before the transaction.  Therefore, we should copy the data to the 
2399:          	        //SetupPkt buffer so it can be processed correctly by USBCtrlTrfSetupHandler().		    
2400:                      memcpy((uint8_t*)&SetupPkt, (uint8_t*)ConvertToVirtualAddress(pBDTEntryEP0OutCurrent->ADR), 8);
04E0  3060     MOVLW 0x60
04E1  0086     MOVWF FSR1L
04E2  0021     MOVLB 0x1
04E3  0869     MOVF pBDTEntryEP0OutCurrent, W
04E4  3E02     ADDLW 0x2
04E5  0084     MOVWF FSR0L
04E6  0185     CLRF FSR0H
04E7  3F00     MOVIW 0[FSR0]
04E8  00AA     MOVWF data_count
04E9  3F01     MOVIW 1[FSR0]
04EA  00AB     MOVWF 0xAB
04EB  082A     MOVF data_count, W
04EC  0084     MOVWF FSR0L
04ED  082B     MOVF 0xAB, W
04EE  0085     MOVWF FSR0H
04EF  3008     MOVLW 0x8
04F0  00AC     MOVWF 0xAC
04F1  082C     MOVF 0xAC, W
04F2  1903     BTFSC STATUS, 0x2
04F3  2CF8     GOTO 0x4F8
04F4  0012     MOVIW FSR0++
04F5  001E     MOVWI FSR1++
04F6  0BAC     DECFSZ 0xAC, F
04F7  2CF4     GOTO 0x4F4
2401:          
2402:          			//Handle the control transfer (parse the 8-byte SETUP command and figure out what to do)
2403:                      USBCtrlTrfSetupHandler();
04F8  3189     MOVLP 0x9
04F9  290A     GOTO 0x10A
2404:                  }
2405:                  else
2406:                  {
2407:          			//Handle the DATA transfer
2408:                      USBCtrlTrfOutHandler();
04FA  2D5A     GOTO 0x55A
2409:                  }
2410:              }
2411:              else if((USTATcopy.Val & USTAT_EP0_PP_MASK) == USTAT_EP0_IN)
04FB  30FD     MOVLW 0xFD
04FC  056F     ANDWF USTATcopy, W
04FD  00AA     MOVWF data_count
04FE  3A04     XORLW 0x4
04FF  1D03     BTFSS STATUS, 0x2
0500  0008     RETURN
2412:              {
2413:          		//Otherwise the transmission was and EP0 IN
2414:          		//  so take care of the IN transfer
2415:                  USBCtrlTrfInHandler();
0501  3194     MOVLP 0x14
0502  2CF1     GOTO 0x4F1
2416:              }
2417:          
2418:          }//end USBCtrlEPService
2419:          
2420:          /********************************************************************
2421:           * Function:        void USBCtrlTrfSetupHandler(void)
2422:           *
2423:           * PreCondition:    SetupPkt buffer is loaded with valid USB Setup Data
2424:           *
2425:           * Input:           None
2426:           *
2427:           * Output:          None
2428:           *
2429:           * Side Effects:    None
2430:           *
2431:           * Overview:        This routine is a task dispatcher and has 3 stages.
2432:           *                  1. It initializes the control transfer state machine.
2433:           *                  2. It calls on each of the module that may know how to
2434:           *                     service the Setup Request from the host.
2435:           *                     Module Example: USBD, HID, CDC, MSD, ...
2436:           *                     A callback function, USBCBCheckOtherReq(),
2437:           *                     is required to call other module handlers.
2438:           *                  3. Once each of the modules has had a chance to check if
2439:           *                     it is responsible for servicing the request, stage 3
2440:           *                     then checks direction of the transfer to determine how
2441:           *                     to prepare EP0 for the control transfer.
2442:           *                     Refer to USBCtrlEPServiceComplete() for more details.
2443:           *
2444:           * Note:            Microchip USB Firmware has three different states for
2445:           *                  the control transfer state machine:
2446:           *                  1. WAIT_SETUP
2447:           *                  2. CTRL_TRF_TX (device sends data to host through IN transactions)
2448:           *                  3. CTRL_TRF_RX (device receives data from host through OUT transactions)
2449:           *                  Refer to firmware manual to find out how one state
2450:           *                  is transitioned to another.
2451:           *
2452:           *                  A Control Transfer is composed of many USB transactions.
2453:           *                  When transferring data over multiple transactions,
2454:           *                  it is important to keep track of data source, data
2455:           *                  destination, and data count. These three parameters are
2456:           *                  stored in pSrc,pDst, and wCount. A flag is used to
2457:           *                  note if the data source is from const or RAM.
2458:           *
2459:           *******************************************************************/
2460:          static void USBCtrlTrfSetupHandler(void)
2461:          {
2462:              //--------------------------------------------------------------------------
2463:              //1. Re-initialize state tracking variables related to control transfers.
2464:              //--------------------------------------------------------------------------
2465:              shortPacketStatus = SHORT_PKT_NOT_USED;  
090A  0022     MOVLB 0x2
090B  01DA     CLRF shortPacketStatus
2466:              USBDeferStatusStagePacket = false;
090C  0021     MOVLB 0x1
090D  01E7     CLRF USBDeferStatusStagePacket
2467:              USBDeferINDataStagePackets = false;
090E  0022     MOVLB 0x2
090F  01D0     CLRF USBDeferINDataStagePackets
2468:              USBDeferOUTDataStagePackets = false;
0910  01CF     CLRF USBDeferOUTDataStagePackets
2469:              BothEP0OutUOWNsSet = false;
0911  01D4     CLRF BothEP0OutUOWNsSet
2470:              controlTransferState = WAIT_SETUP;
0912  01D9     CLRF controlTransferState
2471:          
2472:              //Abandon any previous control transfers that might have been using EP0.
2473:              //Ordinarily, nothing actually needs abandoning, since the previous control
2474:              //transfer would have completed successfully prior to the host sending the next
2475:              //SETUP packet.  However, in a timeout error case, or after an EP0 STALL event,
2476:              //one or more UOWN bits might still be set.  If so, we should clear the UOWN bits,
2477:              //so the EP0 IN/OUT endpoints are in a known inactive state, ready for re-arming
2478:              //by the class request handler that will be called next.
2479:              pBDTEntryIn[0]->STAT.Val &= ~(_USIE);     
0913  0838     MOVF pBDTEntryIn, W
0914  0086     MOVWF FSR1L
0916  0187     CLRF FSR1H
0917  1381     BCF INDF1, 0x7
2480:              ((uint8_t_VAL*)&pBDTEntryIn[0])->Val ^= USB_NEXT_EP0_IN_PING_PONG;
0915  3004     MOVLW 0x4
0918  06B8     XORWF pBDTEntryIn, F
2481:              pBDTEntryIn[0]->STAT.Val &= ~(_USIE);      
0919  0838     MOVF pBDTEntryIn, W
091A  0086     MOVWF FSR1L
091C  1381     BCF INDF1, 0x7
2482:              ((uint8_t_VAL*)&pBDTEntryIn[0])->Val ^= USB_NEXT_EP0_IN_PING_PONG;
091B  3004     MOVLW 0x4
091D  06B8     XORWF pBDTEntryIn, F
2483:              pBDTEntryEP0OutNext->STAT.Val &= ~(_USIE);         
091E  0021     MOVLB 0x1
091F  0868     MOVF pBDTEntryEP0OutNext, W
0920  0086     MOVWF FSR1L
0921  1381     BCF INDF1, 0x7
2484:          
2485:              inPipes[0].info.Val = 0;
0922  0022     MOVLB 0x2
0923  01A9     CLRF 0x129
2486:              inPipes[0].wCount.Val = 0;
0924  01AA     CLRF 0x12A
0925  01AB     CLRF 0x12B
2487:              outPipes[0].info.Val = 0;
0926  01A2     CLRF 0x122
2488:              outPipes[0].wCount.Val = 0;
0927  01A3     CLRF 0x123
0928  01A4     CLRF 0x124
2489:              
2490:          
2491:              //--------------------------------------------------------------------------
2492:              //2. Now find out what was in the SETUP packet, and begin handling the request.
2493:              //--------------------------------------------------------------------------
2494:              USBCheckStdRequest();                                               //Check for standard USB "Chapter 9" requests.
0929  2131     CALL 0x131
092A  3189     MOVLP 0x9
2495:              USB_NONSTANDARD_EP0_REQUEST_HANDLER(EVENT_EP0_REQUEST,0,0); //Check for USB device class specific requests
092B  3003     MOVLW 0x3
092C  232B     CALL 0x32B
092D  3182     MOVLP 0x2
092E  2222     CALL 0x222
2496:          
2497:          
2498:              //--------------------------------------------------------------------------
2499:              //3. Re-arm EP0 IN and EP0 OUT endpoints, based on the control transfer in 
2500:              //   progress.  If one of the above handlers (in step 2) knew how to process
2501:              //   the request, it will have set one of the inPipes[0].info.bits.busy or
2502:              //   outPipes[0].info.bits.busy flags = 1.  This lets the
2503:              //   USBCtrlEPServiceComplete() function know how and which endpoints to 
2504:              //   arm.  If both info.bits.busy flags are = 0, then no one knew how to
2505:              //   process the request.  In this case, the default behavior will be to
2506:              //   perform protocol STALL on EP0.
2507:              //-------------------------------------------------------------------------- 
2508:              USBCtrlEPServiceComplete();
092F  3194     MOVLP 0x14
0930  2C7F     GOTO 0x47F
2509:          }//end USBCtrlTrfSetupHandler
2510:          
2511:          
2512:          /******************************************************************************
2513:           * Function:        void USBCtrlTrfOutHandler(void)
2514:           *
2515:           * PreCondition:    None
2516:           *
2517:           * Input:           None
2518:           *
2519:           * Output:          None
2520:           *
2521:           * Side Effects:    None
2522:           *
2523:           * Overview:        This routine handles an OUT transaction according to
2524:           *                  which control transfer state is currently active.
2525:           *
2526:           * Note:            Note that if the the control transfer was from
2527:           *                  host to device, the session owner should be notified
2528:           *                  at the end of each OUT transaction to service the
2529:           *                  received data.
2530:           *
2531:           *****************************************************************************/
2532:          static void USBCtrlTrfOutHandler(void)
2533:          {
2534:              if(controlTransferState == CTRL_TRF_RX)
055A  3002     MOVLW 0x2
055B  0022     MOVLB 0x2
055C  0659     XORWF controlTransferState, W
055D  1D03     BTFSS STATUS, 0x2
055E  2D61     GOTO 0x561
2535:              {
2536:                  USBCtrlTrfRxService();	//Copies the newly received data into the appropriate buffer and configures EP0 OUT for next transaction.
055F  3195     MOVLP 0x15
0560  2D98     GOTO 0x598
2537:              }
2538:              else //In this case the last OUT transaction must have been a status stage of a CTRL_TRF_TX (<setup><in><in>...<OUT>  <-- this last OUT just occurred as the status stage)
2539:              {
2540:                  //If the status stage is complete, this means we are done with the 
2541:                  //control transfer.  Go back to the idle "WAIT_SETUP" state.
2542:                  controlTransferState = WAIT_SETUP;
0561  01D9     CLRF controlTransferState
2543:          
2544:                  //Prepare EP0 OUT for the next SETUP transaction, however, it may have
2545:                  //already been prepared if ping-pong buffering was enabled on EP0 OUT,
2546:                  //and the last control transfer was of direction: device to host, see
2547:                  //USBCtrlEPServiceComplete().  If it was already prepared, do not want
2548:                  //to do anything to the BDT.
2549:                  if(BothEP0OutUOWNsSet == false)
0562  0854     MOVF BothEP0OutUOWNsSet, W
0563  1D03     BTFSS STATUS, 0x2
0564  2D73     GOTO 0x573
0565  3195     MOVLP 0x15
0566  2567     CALL 0x567
0567  3180     MOVLP 0x0
2550:                  {
2551:                      pBDTEntryEP0OutNext->CNT = USB_EP0_BUFF_SIZE;
2552:                      pBDTEntryEP0OutNext->ADR = ConvertToPhysicalAddress(&SetupPkt);
0568  00F6     MOVWF 0x176
0569  01F7     CLRF 0x177
056A  0868     MOVF 0x168, W
056B  3E02     ADDLW 0x2
056C  0086     MOVWF FSR1L
056D  0876     MOVF 0x176, W
056E  3FC0     MOVWI 0[FSR1]
056F  0877     MOVF 0x177, W
0570  3195     MOVLP 0x15
0571  257D     CALL 0x57D
2553:                      pBDTEntryEP0OutNext->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED)|_BSTALL;
2554:                      pBDTEntryEP0OutNext->STAT.Val |= _USIE;
2555:                  }
0572  0008     RETURN
2556:                  else
2557:                  {
2558:                          BothEP0OutUOWNsSet = false;
0573  01D4     CLRF BothEP0OutUOWNsSet
2559:                  }
2560:              }
2561:          }
0574  0008     RETURN
2562:          
2563:          /******************************************************************************
2564:           * Function:        void USBCtrlTrfInHandler(void)
2565:           *
2566:           * PreCondition:    None
2567:           *
2568:           * Input:           None
2569:           *
2570:           * Output:          None
2571:           *
2572:           * Side Effects:    None
2573:           *
2574:           * Overview:        This routine handles an IN transaction according to
2575:           *                  which control transfer state is currently active.
2576:           *
2577:           * Note:            A Set Address Request must not change the actual address
2578:           *                  of the device until the completion of the control
2579:           *                  transfer. The end of the control transfer for Set Address
2580:           *                  Request is an IN transaction. Therefore it is necessary
2581:           *                  to service this unique situation when the condition is
2582:           *                  right. Macro mUSBCheckAdrPendingState is defined in
2583:           *                  usb9.h and its function is to specifically service this
2584:           *                  event.
2585:           *****************************************************************************/
2586:          static void USBCtrlTrfInHandler(void)
2587:          {
2588:              uint8_t lastDTS;
2589:          
2590:              lastDTS = pBDTEntryIn[0]->STAT.DTS;
14F1  0022     MOVLB 0x2
14F2  0838     MOVF pBDTEntryIn, W
14F3  0086     MOVWF FSR1L
14F4  3000     MOVLW 0x0
14F5  0187     CLRF FSR1H
14F6  1B01     BTFSC INDF1, 0x6
14F7  3001     MOVLW 0x1
14F8  00F3     MOVWF 0x173
2591:          
2592:              //switch to the next ping pong buffer
2593:              ((uint8_t_VAL*)&pBDTEntryIn[0])->Val ^= USB_NEXT_EP0_IN_PING_PONG;
14F9  3004     MOVLW 0x4
14FA  06B8     XORWF pBDTEntryIn, F
2594:          
2595:              //Must check if in ADR_PENDING_STATE.  If so, we need to update the address
2596:              //now, since the IN status stage of the (set address) control transfer has 
2597:              //evidently completed successfully.
2598:              if(USBDeviceState == ADR_PENDING_STATE)
14FB  3008     MOVLW 0x8
14FC  0021     MOVLB 0x1
14FD  066E     XORWF USBDeviceState, W
14FE  1D03     BTFSS STATUS, 0x2
14FF  2D0D     GOTO 0x50D
2599:              {
2600:                  U1ADDR = (SetupPkt.bDevADR & 0x7F);
1500  0020     MOVLB 0x0
1501  0862     MOVF 0x62, W
1502  397F     ANDLW 0x7F
1503  003D     MOVLB 0x1D
1504  0096     MOVWF UADDR
2601:                  if(U1ADDR != 0u)
1505  0816     MOVF UADDR, W
1506  1903     BTFSC STATUS, 0x2
1507  2D0A     GOTO 0x50A
2602:                  {
2603:                      USBDeviceState=ADDRESS_STATE;
1508  3010     MOVLW 0x10
1509  2D0B     GOTO 0x50B
2604:                  }
2605:                  else
2606:                  {
2607:                      USBDeviceState=DEFAULT_STATE;
150A  3004     MOVLW 0x4
150B  0021     MOVLB 0x1
150C  00EE     MOVWF USBDeviceState
2608:                  }
2609:              }//end if
2610:          
2611:          
2612:              if(controlTransferState == CTRL_TRF_TX)
150D  0022     MOVLB 0x2
150E  0B59     DECFSZ controlTransferState, W
150F  2D33     GOTO 0x533
2613:              {
2614:                  pBDTEntryIn[0]->ADR = ConvertToPhysicalAddress(CtrlTrfData);
1510  3068     MOVLW 0x68
1511  00F1     MOVWF 0x171
1512  01F2     CLRF 0x172
1513  0838     MOVF pBDTEntryIn, W
1514  3E02     ADDLW 0x2
1515  0086     MOVWF FSR1L
1516  0187     CLRF FSR1H
1517  0871     MOVF 0x171, W
1518  3FC0     MOVWI 0[FSR1]
1519  0872     MOVF 0x172, W
151A  3FC1     MOVWI 1[FSR1]
2615:                  USBCtrlTrfTxService();
151B  2537     CALL 0x537
151C  3194     MOVLP 0x14
2616:          
2617:                  //Check if we have already sent a short packet.  If so, configure
2618:                  //the endpoint to STALL in response to any further IN tokens (in the
2619:                  //case that the host erroneously tries to receive more data than it
2620:                  //should).
2621:                  if(shortPacketStatus == SHORT_PKT_SENT)
151D  3002     MOVLW 0x2
151E  065A     XORWF shortPacketStatus, W
151F  1D03     BTFSS STATUS, 0x2
1520  2D26     GOTO 0x526
2622:                  {
2623:                      // If a short packet has been sent, don't want to send any more,
2624:                      // stall next time if host is still trying to read.
2625:                      pBDTEntryIn[0]->STAT.Val = _BSTALL;
1521  0838     MOVF pBDTEntryIn, W
1522  0086     MOVWF FSR1L
1523  3004     MOVLW 0x4
1524  0187     CLRF FSR1H
1525  2D86     GOTO 0x586
2626:                      pBDTEntryIn[0]->STAT.Val |= _USIE;
2627:                  }
2628:                  else
2629:                  {
2630:                      if(lastDTS == 0)
1526  0873     MOVF 0x173, W
1527  1D03     BTFSS STATUS, 0x2
1528  2D2E     GOTO 0x52E
2631:                      {
2632:                          pBDTEntryIn[0]->STAT.Val = _DAT1|(_DTSEN & _DTS_CHECKING_ENABLED);
1529  0838     MOVF pBDTEntryIn, W
152A  0086     MOVWF FSR1L
152B  3048     MOVLW 0x48
152C  0187     CLRF FSR1H
152D  2D86     GOTO 0x586
2633:                          pBDTEntryIn[0]->STAT.Val |= _USIE;
2634:                      }
2635:                      else
2636:                      {
2637:                          pBDTEntryIn[0]->STAT.Val = _DAT0|(_DTSEN & _DTS_CHECKING_ENABLED);
152E  0838     MOVF pBDTEntryIn, W
152F  0086     MOVWF FSR1L
1530  3008     MOVLW 0x8
1531  0187     CLRF FSR1H
1532  2D86     GOTO 0x586
2638:                          pBDTEntryIn[0]->STAT.Val |= _USIE;
2639:                      }
2640:                  }//end if(...)else
2641:              }
2642:          	else // must have been a CTRL_TRF_RX status stage IN packet (<setup><out><out>...<IN>  <-- this last IN just occurred as the status stage)
2643:          	{
2644:                  //if someone is still expecting data from the control transfer
2645:                  //  then make sure to terminate that request and let them know that
2646:                  //  they are done
2647:                  if(outPipes[0].info.bits.busy == 1)
1533  1BA2     BTFSC 0x122, 0x7
2648:                  {
2649:                      if(outPipes[0].pFunc != NULL)
2650:                      {
2651:                          outPipes[0].pFunc();
2652:                      }
2653:                      outPipes[0].info.bits.busy = 0;
1534  13A2     BCF 0x122, 0x7
2654:                  }
2655:              	
2656:                  controlTransferState = WAIT_SETUP;
1535  01D9     CLRF controlTransferState
2657:                  //Don't need to arm EP0 OUT here.  It was already armed by the last <out> that
2658:                  //got processed by the USBCtrlTrfRxService() handler.
2659:          	}	
2660:          
2661:          }
1536  0008     RETURN
2662:          
2663:          
2664:          /********************************************************************
2665:           * Function:        void USBCheckStdRequest(void)
2666:           *
2667:           * PreCondition:    None
2668:           *
2669:           * Input:           None
2670:           *
2671:           * Output:          None
2672:           *
2673:           * Side Effects:    None
2674:           *
2675:           * Overview:        This routine checks the setup data packet to see
2676:           *                  if it knows how to handle it
2677:           *
2678:           * Note:            None
2679:           *******************************************************************/
2680:          static void USBCheckStdRequest(void)
2681:          {
2682:              if(SetupPkt.RequestType != USB_SETUP_TYPE_STANDARD_BITFIELD) return;
0931  0020     MOVLB 0x0
0932  0E60     SWAPF SetupPkt, W
0933  0C89     RRF WREG, F
0934  3903     ANDLW 0x3
0935  1D03     BTFSS STATUS, 0x2
0936  0008     RETURN
2683:          
2684:              switch(SetupPkt.bRequest)
07E0  3189     MOVLP 0x9
0937  0861     MOVF 0x61, W
0938  0084     MOVWF FSR0
0939  300D     MOVLW 0xD
093A  0204     SUBWF FSR0, W
093B  1803     BTFSC STATUS, 0x0
093C  0008     RETURN
093D  3187     MOVLP 0x7
093E  3504     LSLF FSR0, W
093F  3EE0     ADDLW 0xE0
0940  0082     MOVWF PCL
2685:              {
2686:                  case USB_REQUEST_SET_ADDRESS:
2687:                      inPipes[0].info.bits.busy = 1;            // This will generate a zero length packet
0942  0022     MOVLB 0x2
0944  17A9     BSF 0x129, 0x7
2688:                      USBDeviceState = ADR_PENDING_STATE;       // Update state only
0943  3008     MOVLW 0x8
0945  0021     MOVLB 0x1
0946  00EE     MOVWF USBDeviceState
2689:                      /* See USBCtrlTrfInHandler() for the next step */
2690:                      break;
0947  0008     RETURN
2691:                  case USB_REQUEST_GET_DESCRIPTOR:
2692:                      USBStdGetDscHandler();
0948  2A30     GOTO 0x230
2693:                      break;
2694:                  case USB_REQUEST_SET_CONFIGURATION:
2695:                      USBStdSetCfgHandler();
0949  2AC1     GOTO 0x2C1
2696:                      break;
2697:                  case USB_REQUEST_GET_CONFIGURATION:
2698:                      inPipes[0].pSrc.bRam = (uint8_t*)&USBActiveConfiguration;         // Set Source
094A  306D     MOVLW 0x6D
094B  0022     MOVLB 0x2
094C  00A7     MOVWF inPipes
094D  3001     MOVLW 0x1
094E  00A8     MOVWF 0x128
2699:                      inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
094F  1429     BSF 0x129, 0x0
2700:                      inPipes[0].wCount.v[0] = 1;                         // Set data count
0950  01AA     CLRF 0x12A
0951  0AAA     INCF 0x12A, F
2701:                      inPipes[0].info.bits.busy = 1;
0952  17A9     BSF 0x129, 0x7
2702:                      break;
0953  0008     RETURN
2703:                  case USB_REQUEST_GET_STATUS:
2704:                      USBStdGetStatusHandler();
0954  2A7F     GOTO 0x27F
2705:                      break;
2706:                  case USB_REQUEST_CLEAR_FEATURE:
2707:                  case USB_REQUEST_SET_FEATURE:
2708:                      USBStdFeatureReqHandler();
0955  296B     GOTO 0x16B
2709:                      break;
2710:                  case USB_REQUEST_GET_INTERFACE:
2711:                      inPipes[0].pSrc.bRam = (uint8_t*)&USBAlternateInterface[SetupPkt.bIntfID];  // Set source
0956  0864     MOVF 0x164, W
0957  3ED9     ADDLW 0xD9
0958  0022     MOVLB 0x2
0959  00A7     MOVWF inPipes
095A  3001     MOVLW 0x1
095B  294E     GOTO 0x14E
2712:                      inPipes[0].info.bits.ctrl_trf_mem = USB_EP0_RAM;               // Set memory type
2713:                      inPipes[0].wCount.v[0] = 1;                         // Set data count
2714:                      inPipes[0].info.bits.busy = 1;
2715:                      break;
2716:                  case USB_REQUEST_SET_INTERFACE:
2717:                      inPipes[0].info.bits.busy = 1;
095C  0022     MOVLB 0x2
095D  17A9     BSF 0x129, 0x7
2718:                      USBAlternateInterface[SetupPkt.bIntfID] = SetupPkt.bAltID;
095E  0020     MOVLB 0x0
095F  0864     MOVF 0x64, W
0960  3ED9     ADDLW 0xD9
0961  0086     MOVWF FSR1
0962  3001     MOVLW 0x1
0963  0087     MOVWF FSR1H
0964  0862     MOVF 0x62, W
0965  0081     MOVWF INDF1
2719:                      break;
0966  0008     RETURN
2720:                  case USB_REQUEST_SET_DESCRIPTOR:
2721:                      USB_SET_DESCRIPTOR_HANDLER(EVENT_SET_DESCRIPTOR,0,0);
0967  3002     MOVLW 0x2
0968  232B     CALL 0x32B
0969  3182     MOVLP 0x2
096A  2A22     GOTO 0x222
2722:                      break;
2723:                  case USB_REQUEST_SYNCH_FRAME:
2724:                  default:
2725:                      break;
2726:              }//end switch
2727:          }//end USBCheckStdRequest
0941  0008     RETURN
0942  0022     MOVLB 0x2
0943  3008     MOVLW 0x8
0944  17A9     BSF 0x129, 0x7
0945  0021     MOVLB 0x1
0946  00EE     MOVWF USBDeviceState
0947  0008     RETURN
0948  2A30     GOTO 0x230
0949  2AC1     GOTO 0x2C1
094A  306D     MOVLW 0x6D
094B  0022     MOVLB 0x2
094C  00A7     MOVWF inPipes
094D  3001     MOVLW 0x1
094E  00A8     MOVWF 0x128
094F  1429     BSF 0x129, 0x0
0950  01AA     CLRF 0x12A
0951  0AAA     INCF 0x12A, F
0952  17A9     BSF 0x129, 0x7
0953  0008     RETURN
0954  2A7F     GOTO 0x27F
0955  296B     GOTO 0x16B
0956  0864     MOVF 0x164, W
0957  3ED9     ADDLW 0xD9
0958  0022     MOVLB 0x2
0959  00A7     MOVWF inPipes
095A  3001     MOVLW 0x1
095B  294E     GOTO 0x14E
095C  0022     MOVLB 0x2
095D  17A9     BSF 0x129, 0x7
095E  0020     MOVLB 0x0
095F  0864     MOVF 0x64, W
0960  3ED9     ADDLW 0xD9
0961  0086     MOVWF FSR1
0962  3001     MOVLW 0x1
0963  0087     MOVWF FSR1H
0964  0862     MOVF 0x62, W
0965  0081     MOVWF INDF1
0966  0008     RETURN
0967  3002     MOVLW 0x2
0968  232B     CALL 0x32B
0969  3182     MOVLP 0x2
096A  2A22     GOTO 0x222
2728:          
2729:          /********************************************************************
2730:           * Function:        void USBStdFeatureReqHandler(void)
2731:           *
2732:           * PreCondition:    None
2733:           *
2734:           * Input:           None
2735:           *
2736:           * Output:          Can alter BDT entries.  Can also modify USB stack
2737:           *                  Maintained variables.
2738:           *
2739:           * Side Effects:    None
2740:           *
2741:           * Overview:        This routine handles the standard SET & CLEAR
2742:           *                  FEATURES requests
2743:           *
2744:           * Note:            This is a private function, intended for internal 
2745:           *                  use by the USB stack, when processing SET/CLEAR
2746:           *                  feature requests.  
2747:           *******************************************************************/
2748:          static void USBStdFeatureReqHandler(void)
2749:          {
2750:              BDT_ENTRY *p;
2751:              EP_STATUS current_ep_data;
2752:              #if defined(__C32__)
2753:                  uint32_t* pUEP;
2754:              #else
2755:                  unsigned char* pUEP;             
2756:              #endif
2757:              
2758:          
2759:              #ifdef	USB_SUPPORT_OTG
2760:              //Check for USB On-The-Go (OTG) specific requests
2761:              if ((SetupPkt.bFeature == OTG_FEATURE_B_HNP_ENABLE)&&
2762:                  (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2763:              {  
2764:                  inPipes[0].info.bits.busy = 1;
2765:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2766:                      USBOTGEnableHnp();
2767:                  else
2768:                      USBOTGDisableHnp();
2769:              }
2770:          
2771:              if ((SetupPkt.bFeature == OTG_FEATURE_A_HNP_SUPPORT)&&
2772:                  (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2773:              {
2774:                  inPipes[0].info.bits.busy = 1;
2775:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2776:                      USBOTGEnableSupportHnp();
2777:                  else
2778:                      USBOTGDisableSupportHnp();
2779:              }
2780:          
2781:              if ((SetupPkt.bFeature == OTG_FEATURE_A_ALT_HNP_SUPPORT)&&
2782:                  (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
2783:              {
2784:                  inPipes[0].info.bits.busy = 1;
2785:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2786:                      USBOTGEnableAltHnp();
2787:                  else
2788:                      USBOTGDisableAltHnp();
2789:              }
2790:              #endif   //#ifdef USB_SUPPORT_OTG 
2791:          
2792:              //Check if the host sent a valid SET or CLEAR feature (remote wakeup) request.
2793:              if((SetupPkt.bFeature == USB_FEATURE_DEVICE_REMOTE_WAKEUP)&&
2794:                 (SetupPkt.Recipient == USB_SETUP_RECIPIENT_DEVICE_BITFIELD))
096B  0020     MOVLB 0x0
096C  0B62     DECFSZ 0x62, W
096D  297F     GOTO 0x17F
096E  0860     MOVF SetupPkt, W
096F  391F     ANDLW 0x1F
0970  1D03     BTFSS STATUS, 0x2
0971  297F     GOTO 0x17F
2795:              {
2796:                  inPipes[0].info.bits.busy = 1;
0972  0022     MOVLB 0x2
0974  17A9     BSF 0x129, 0x7
2797:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
0973  3003     MOVLW 0x3
0975  0020     MOVLB 0x0
0976  0661     XORWF 0x61, W
0977  1D03     BTFSS STATUS, 0x2
0978  297D     GOTO 0x17D
2798:                      RemoteWakeup = true;
0979  0022     MOVLB 0x2
097A  01D7     CLRF RemoteWakeup
097B  0AD7     INCF RemoteWakeup, F
097C  297F     GOTO 0x17F
2799:                  else
2800:                      RemoteWakeup = false;
097D  0022     MOVLB 0x2
097E  01D7     CLRF RemoteWakeup
2801:              }//end if
2802:          
2803:              //Check if the host sent a valid SET or CLEAR endpoint halt request.
2804:              if((SetupPkt.bFeature == USB_FEATURE_ENDPOINT_HALT)&&
2805:                 (SetupPkt.Recipient == USB_SETUP_RECIPIENT_ENDPOINT_BITFIELD)&&
2806:                 (SetupPkt.EPNum != 0) && (SetupPkt.EPNum <= USB_MAX_EP_NUMBER)&&
2807:                 (USBDeviceState == CONFIGURED_STATE))
097F  0020     MOVLB 0x0
0980  0862     MOVF 0x62, W
0981  1D03     BTFSS STATUS, 0x2
0982  0008     RETURN
0983  0860     MOVF SetupPkt, W
0984  391F     ANDLW 0x1F
0985  3A02     XORLW 0x2
0986  1D03     BTFSS STATUS, 0x2
0987  0008     RETURN
0988  0864     MOVF 0x64, W
0989  390F     ANDLW 0xF
098A  1903     BTFSC STATUS, 0x2
098B  0008     RETURN
098C  0864     MOVF 0x64, W
098D  390F     ANDLW 0xF
098E  00FB     MOVWF HostMoreDataThanDevice
098F  3004     MOVLW 0x4
0990  027B     SUBWF HostMoreDataThanDevice, W
0991  1803     BTFSC STATUS, 0x0
0992  0008     RETURN
0993  3020     MOVLW 0x20
0994  0021     MOVLB 0x1
0995  066E     XORWF USBDeviceState, W
0996  1D03     BTFSS STATUS, 0x2
0997  0008     RETURN
2808:              {
2809:          		//The request was valid.  Take control of the control transfer and
2810:          		//perform the host requested action.
2811:          		inPipes[0].info.bits.busy = 1;
0998  0022     MOVLB 0x2
0999  17A9     BSF 0x129, 0x7
2812:          
2813:                  //Fetch a pointer to the BDT that the host wants to SET/CLEAR halt on.
2814:                  if(SetupPkt.EPDir == OUT_FROM_HOST)
099A  0020     MOVLB 0x0
099B  1BE4     BTFSC 0x64, 0x7
099C  29A4     GOTO 0x1A4
2815:                  {
2816:                      p = (BDT_ENTRY*)pBDTEntryOut[SetupPkt.EPNum];
099D  0864     MOVF 0x64, W
099E  390F     ANDLW 0xF
099F  3E3C     ADDLW 0x3C
09A0  2333     CALL 0x333
09A1  3189     MOVLP 0x9
2817:                      current_ep_data.Val = ep_data_out[SetupPkt.EPNum].Val;
09A2  3ED1     ADDLW 0xD1
09A3  29AA     GOTO 0x1AA
2818:                  }
2819:                  else
2820:                  {
2821:                      p = (BDT_ENTRY*)pBDTEntryIn[SetupPkt.EPNum];
09A4  0864     MOVF 0x64, W
09A5  390F     ANDLW 0xF
09A6  3E38     ADDLW 0x38
09A7  2333     CALL 0x333
09A8  3189     MOVLP 0x9
2822:                      current_ep_data.Val = ep_data_in[SetupPkt.EPNum].Val;
09A9  3ED5     ADDLW 0xD5
09AA  0086     MOVWF FSR1
09AB  0801     MOVF INDF1, W
09AC  0021     MOVLB 0x1
09AD  00A8     MOVWF i
2823:                  }
2824:          
2825:                  //If ping pong buffering is enabled on the requested endpoint, need 
2826:                  //to point to the one that is the active BDT entry which the SIE will 
2827:                  //use for the next attempted transaction on that EP number.
2828:                  #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
2829:                      if(current_ep_data.bits.ping_pong_state == 0) //Check if even
09AE  1828     BTFSC i, 0x0
09AF  29B2     GOTO 0x1B2
2830:                      {
2831:                          USBHALPingPongSetToEven(&p);
09B0  1129     BCF i, 0x2
2832:                      }
09B1  29B3     GOTO 0x1B3
2833:                      else //else must have been odd
2834:                      {
2835:                          USBHALPingPongSetToOdd(&p);
09B2  1529     BSF i, 0x2
2836:                      }
2837:                  #endif
2838:                  
2839:                  //Update the BDT pointers with the new, next entry based on the feature
2840:                  //  request
2841:                  if(SetupPkt.EPDir == OUT_FROM_HOST)
09B3  0020     MOVLB 0x0
09B4  1BE4     BTFSC 0x64, 0x7
09B5  29BA     GOTO 0x1BA
2842:                  {
2843:                      pBDTEntryOut[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
09B6  0864     MOVF 0x64, W
09B7  390F     ANDLW 0xF
09B8  3E3C     ADDLW 0x3C
09B9  29BD     GOTO 0x1BD
2844:                  }
2845:                  else
2846:                  {
2847:                      pBDTEntryIn[SetupPkt.EPNum] = (volatile BDT_ENTRY *)p;
09BA  0864     MOVF 0x64, W
09BB  390F     ANDLW 0xF
09BC  3E38     ADDLW 0x38
09BD  0086     MOVWF FSR1
09BE  3001     MOVLW 0x1
09BF  0087     MOVWF FSR1H
09C0  0021     MOVLB 0x1
09C1  0829     MOVF i, W
09C2  0081     MOVWF INDF1
2848:                  }
2849:          
2850:          		//Check if it was a SET_FEATURE endpoint halt request
2851:                  if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
09C3  3003     MOVLW 0x3
09C4  0020     MOVLB 0x0
09C5  0661     XORWF 0x61, W
09C6  1D03     BTFSS STATUS, 0x2
09C7  29E5     GOTO 0x1E5
2852:                  {
2853:                      if(p->STAT.UOWN == 1)
09C8  0021     MOVLB 0x1
09C9  0829     MOVF i, W
09CA  0086     MOVWF FSR1L
09CB  0187     CLRF FSR1H
09CC  1F81     BTFSS INDF1, 0x7
09CD  29DC     GOTO 0x1DC
2854:                      {
2855:                          //Mark that we are terminating this transfer and that the user
2856:                          //  needs to be notified later
2857:                          if(SetupPkt.EPDir == OUT_FROM_HOST)
09CE  0020     MOVLB 0x0
09CF  1BE4     BTFSC 0x64, 0x7
09D0  29D5     GOTO 0x1D5
2858:                          {
2859:                              ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 1;
09D1  0864     MOVF 0x64, W
09D2  390F     ANDLW 0xF
09D3  3ED1     ADDLW 0xD1
09D4  29D8     GOTO 0x1D8
2860:                          }
2861:                          else
2862:                          {
2863:                              ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 1;
09D5  0864     MOVF 0x64, W
09D6  390F     ANDLW 0xF
09D7  3ED5     ADDLW 0xD5
09D8  0086     MOVWF FSR1
09D9  3001     MOVLW 0x1
09DA  0087     MOVWF FSR1H
09DB  1481     BSF INDF1, 0x1
2864:                          }
2865:                      }
2866:          
2867:          			//Then STALL the endpoint
2868:                      p->STAT.Val |= _BSTALL;
09DC  0021     MOVLB 0x1
09DD  0829     MOVF i, W
09DE  0086     MOVWF FSR1L
09DF  0187     CLRF FSR1H
09E0  1501     BSF INDF1, 0x2
2869:                      p->STAT.Val |= _USIE;
09E1  0829     MOVF i, W
09E2  0086     MOVWF FSR1L
09E3  1781     BSF INDF1, 0x7
2870:                  }//if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
09E4  0008     RETURN
2871:                  else
2872:                  {
2873:          			//Else the request must have been a CLEAR_FEATURE endpoint halt.
2874:                      #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
2875:                          //toggle over the to the non-active BDT
2876:                          USBAdvancePingPongBuffer(&p);  
09E5  3004     MOVLW 0x4
09E6  0021     MOVLB 0x1
09E7  06A9     XORWF i, F
2877:          
2878:                          if(p->STAT.UOWN == 1)
09E8  0829     MOVF i, W
09E9  0086     MOVWF FSR1L
09EA  0187     CLRF FSR1H
09EC  1F81     BTFSS INDF1, 0x7
09ED  29F8     GOTO 0x1F8
2879:                          {
2880:                              //Clear UOWN and set DTS state so it will be correct the next time
2881:                              //the application firmware uses USBTransferOnePacket() on the EP.
2882:                              p->STAT.Val &= (~_USIE);    //Clear UOWN bit
09EB  0829     MOVF i, W
09EE  0086     MOVWF FSR1L
09EF  1381     BCF INDF1, 0x7
2883:                              p->STAT.Val |= _DAT1;       //Set DTS to DATA1
09F0  0086     MOVWF FSR1L
09F2  1701     BSF INDF1, 0x6
2884:                              USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
09F1  3005     MOVLW 0x5
09F3  231F     CALL 0x31F
09F4  3182     MOVLP 0x2
09F5  2222     CALL 0x222
09F6  3189     MOVLP 0x9
2885:                          }
09F7  29FB     GOTO 0x1FB
2886:                          else
2887:                          {
2888:                              //UOWN already clear, but still need to set DTS to DATA1     
2889:          					p->STAT.Val |= _DAT1;
09F8  0086     MOVWF FSR1L
09F9  0187     CLRF FSR1H
09FA  1701     BSF INDF1, 0x6
2890:                          }
2891:          
2892:                          //toggle back to the active BDT (the one the SIE is currently looking at
2893:                          //and will use for the next successful transaction to take place on the EP
2894:                          USBAdvancePingPongBuffer(&p);    
09FB  3004     MOVLW 0x4
09FC  0021     MOVLB 0x1
09FD  06A9     XORWF i, F
2895:                          
2896:                          //Check if we are currently terminating, or have previously terminated
2897:                          //a transaction on the given endpoint.  If so, need to clear UOWN,
2898:                          //set DTS to the proper state, and call the application callback
2899:                          //function.
2900:                          if((current_ep_data.bits.transfer_terminated != 0) || (p->STAT.UOWN == 1))
09FE  18A8     BTFSC i, 0x1
09FF  2A05     GOTO 0x205
0A00  0829     MOVF i, W
0A01  0086     MOVWF FSR1L
0A02  0187     CLRF FSR1H
0A03  1F81     BTFSS INDF1, 0x7
0A04  2A1C     GOTO 0x21C
2901:                          {
2902:                              if(SetupPkt.EPDir == OUT_FROM_HOST)
0A05  0020     MOVLB 0x0
0A06  1BE4     BTFSC 0x64, 0x7
0A07  2A0C     GOTO 0x20C
2903:                              {
2904:                                  ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
0A08  0864     MOVF 0x64, W
0A09  390F     ANDLW 0xF
0A0A  3ED1     ADDLW 0xD1
0A0B  2A0F     GOTO 0x20F
2905:                              }
2906:                              else
2907:                              {
2908:                                  ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
0A0C  0864     MOVF 0x64, W
0A0D  390F     ANDLW 0xF
0A0E  3ED5     ADDLW 0xD5
0A0F  0086     MOVWF FSR1
0A10  3001     MOVLW 0x1
0A11  0087     MOVWF FSR1H
0A12  1081     BCF INDF1, 0x1
2909:                              }
2910:                              //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition     
2911:                              p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL);  
0A13  0021     MOVLB 0x1
0A14  2351     CALL 0x351
0A15  3189     MOVLP 0x9
2912:                              //Call the application event handler callback function, so it can 
2913:          					//decide if the endpoint should get re-armed again or not.
2914:                              USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
0A16  3005     MOVLW 0x5
0A17  231F     CALL 0x31F
0A18  3182     MOVLP 0x2
0A19  2222     CALL 0x222
0A1A  3189     MOVLP 0x9
2915:                          }
0A1B  2A1D     GOTO 0x21D
2916:                          else
2917:                          {
2918:                              //clear UOWN, clear DTS to DATA0, and finally remove the STALL condition     
2919:                              p->STAT.Val &= ~(_USIE | _DAT1 | _BSTALL); 
0A1C  2351     CALL 0x351
2920:                          } 
2921:                      #else //else we must not be using ping-pong buffering on the requested endpoint
2922:                          //Check if we need to call the user transfer terminated event callback function.
2923:                          //We should call the callback, if the endpoint was previously terminated,
2924:                          //or the endpoint is currently armed, and the host is performing clear
2925:                          //endpoint halt, even though the endpoint wasn't stalled.
2926:                          if((current_ep_data.bits.transfer_terminated != 0) || (p->STAT.UOWN == 1))
2927:                          {
2928:                              //We are going to call the user transfer terminated callback.
2929:                              //Clear the flag so we know we took care of it and don't need
2930:                              //to call it again later.
2931:                              if(SetupPkt.EPDir == OUT_FROM_HOST)
2932:                              {
2933:                                  ep_data_out[SetupPkt.EPNum].bits.transfer_terminated = 0;
2934:                              }
2935:                              else
2936:                              {
2937:                                  ep_data_in[SetupPkt.EPNum].bits.transfer_terminated = 0;
2938:                              }
2939:           
2940:                              //Clear UOWN and remove the STALL condition.   
2941:                              //  In this case we also need to set the DTS bit to 1 so that
2942:                              //  it toggles to DATA0 the next time the application firmware
2943:                              //  calls USBTransferOnePacket() (or equivalent macro).  
2944:                              p->STAT.Val &= ~(_USIE | _BSTALL);  
2945:                              p->STAT.Val |= _DAT1;
2946:                              //Let the application firmware know a transaction just
2947:                              //got terminated by the host, and that it is now free to
2948:                              //re-arm the endpoint or do other tasks if desired.                                        
2949:                              USB_TRANSFER_TERMINATED_HANDLER(EVENT_TRANSFER_TERMINATED,p,sizeof(p));
2950:                          }
2951:                          else
2952:                          {
2953:                              //Clear UOWN and remove the STALL condition.   
2954:                              //  In this case we also need to set the DTS bit to 1 so that
2955:                              //  it toggles to DATA0 the next time the application firmware
2956:                              //  calls USBTransferOnePacket() (or equivalent macro).  
2957:                              p->STAT.Val &= ~(_USIE | _BSTALL);  
2958:                              p->STAT.Val |= _DAT1;
2959:                          } 
2960:                      #endif //end of #if (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)   
2961:                      
2962:          			//Get a pointer to the appropriate UEPn register
2963:                      #if defined(__C32__)
2964:                          pUEP = (uint32_t*)(&U1EP0);
2965:                          pUEP += (SetupPkt.EPNum*4);
2966:                      #else
2967:                          pUEP = (unsigned char*)(&U1EP0+SetupPkt.EPNum);
0A1D  0020     MOVLB 0x0
0A1E  0864     MOVF 0x64, W
0A1F  390F     ANDLW 0xF
0A20  3E98     ADDLW 0x98
0A21  00FB     MOVWF HostMoreDataThanDevice
0A22  300E     MOVLW 0xE
0A23  01FC     CLRF i
0A24  3DFC     ADDWFC i, F
0A25  087B     MOVF HostMoreDataThanDevice, W
0A26  0021     MOVLB 0x1
0A27  00A6     MOVWF p
0A28  087C     MOVF 0xFC, W
0A29  00A7     MOVWF 0xA7
2968:                      #endif
2969:          
2970:          			//Clear the STALL bit in the UEP register
2971:                      *pUEP &= ~UEP_STALL;            
0A2A  0826     MOVF p, W
0A2B  0086     MOVWF FSR1L
0A2C  0827     MOVF 0xA7, W
0A2D  0087     MOVWF FSR1H
0A2E  1001     BCF INDF1, 0x0
2972:                  }//end if(SetupPkt.bRequest == USB_REQUEST_SET_FEATURE)
2973:              }//end if (lots of checks for set/clear endpoint halt)
2974:          }//end USBStdFeatureReqHandler
0A2F  0008     RETURN
2975:          
2976:          
2977:          
2978:          
2979:          /**************************************************************************
2980:              Function:
2981:                  void USBIncrement1msInternalTimers(void)
2982:          
2983:              Description:
2984:                  This function increments internal 1ms time base counters, which are
2985:                  useful for application code (that can use a 1ms time base/counter), and
2986:                  for certain USB event timing specific purposes.
2987:          
2988:                  In USB full speed applications, the application code does not need to (and should
2989:                  not) explicitly call this function, as the USBDeviceTasks() function will
2990:                  automatically call this function whenever a 1ms time interval has elapsed
2991:                  (assuming the code is calling USBDeviceTasks() frequently enough in USB_POLLING
2992:                  mode, or that USB interrupts aren't being masked for more than 1ms at a time
2993:                  in USB_INTERRUPT mode).
2994:          
2995:                  In USB low speed applications, the application firmware is responsible for
2996:                  periodically calling this function at a ~1ms rate.  This can be done using
2997:                  a general purpose microcontroller timer set to interrupt every 1ms for example.
2998:                  If the low speed application code does not call this function, the internal timers
2999:                  will not increment, and the USBGet1msTickCount() API function will not be available.
3000:                  Additionally, certain USB stack operations (like control transfer timeouts)
3001:                  may be unavailable.
3002:          
3003:              Precondition:
3004:                  This function should be called only after USBDeviceInit() has been
3005:                  called (at least once at the start of the application).  Ordinarily,
3006:                  application code should never call this function, unless it is a low speed
3007:                  USB device.
3008:          
3009:              Parameters:
3010:                  None
3011:          
3012:              Return Values:
3013:                  None
3014:          
3015:              Remarks:
3016:                  This function does not need to be called during USB suspend conditions, when
3017:                  the USB module/stack is disabled, or when the USB cable is detached from the host.
3018:            ***************************************************************************/
3019:          void USBIncrement1msInternalTimers(void)
3020:          {
3021:              #if(USB_SPEED_OPTION == USB_LOW_SPEED)
3022:                  #warning "For low speed USB applications, read the function comments for the USBIncrement1msInternalTimers() function, and implement code to call this function periodically."
3023:              #endif
3024:          
3025:              //Increment timekeeping 1ms tick counters.  Useful for other APIs/code
3026:              //that needs a 1ms time base that is active during USB non-suspended operation.
3027:              USB1msTickCount++;
3028:              if(USBIsBusSuspended() == false)
0297  0022     MOVLB 0x2
0298  0856     MOVF USBBusIsSuspended, W
0299  1D03     BTFSS STATUS, 0x2
029A  0008     RETURN
3029:              {
3030:                  USBTicksSinceSuspendEnd++;
029B  0ACE     INCF USBTicksSinceSuspendEnd, F
3031:                  //Check for 8-bit wraparound.  If so, force it to saturate at 255.
3032:                  if(USBTicksSinceSuspendEnd == 0)
029C  084E     MOVF USBTicksSinceSuspendEnd, W
029D  1D03     BTFSS STATUS, 0x2
029E  0008     RETURN
3033:                  {
3034:                      USBTicksSinceSuspendEnd = 255;
029F  30FF     MOVLW 0xFF
02A0  00CE     MOVWF USBTicksSinceSuspendEnd
3035:                  }
3036:              }
3037:          }
02A1  0008     RETURN
3038:          
3039:          
3040:          
3041:          
3042:          /**************************************************************************
3043:              Function:
3044:                  uint32_t USBGet1msTickCount(void)
3045:          
3046:              Description:
3047:                  This function retrieves a 32-bit unsigned integer that normally increments by
3048:                  one every one millisecond.  The count value starts from zero when the
3049:                  USBDeviceInit() function is first called.  See the remarks section for
3050:                  details on special circumstances where the tick count will not increment.
3051:          
3052:              Precondition:
3053:                  This function should be called only after USBDeviceInit() has been
3054:                  called (at least once at the start of the application).
3055:          
3056:              Parameters:
3057:                  None
3058:          
3059:              Return Values:
3060:                  uint32_t representing the approximate millisecond count, since the time the
3061:                  USBDeviceInit() function was first called.
3062:          
3063:              Remarks:
3064:                  On 8-bit USB full speed devices, the internal counter is incremented on
3065:                  every SOF packet detected.  Therefore, it will not increment during suspend
3066:                  or when the USB cable is detached.  However, on 16-bit devices, the T1MSECIF
3067:                  hardware interrupt source is used to increment the internal counter.  Therefore,
3068:                  on 16-bit devices, the count continue to increment during USB suspend or
3069:                  detach events, so long as the application code has not put the microcontroller
3070:                  to sleep during these events, and the application firmware is regularly
3071:                  calling the USBDeviceTasks() function (or allowing it to execute, if using
3072:                  USB_INTERRUPT mode operation).
3073:          
3074:                  In USB low speed applications, the host does not broadcast SOF packets to
3075:                  the device, so the application firmware becomes responsible for calling
3076:                  USBIncrement1msInternalTimers() periodically (ex: from a general purpose
3077:                  timer interrupt handler), or else the returned value from this function will
3078:                  not increment.
3079:                  
3080:                  Prior to calling USBDeviceInit() for the first time the returned value will
3081:                  be unpredictable.
3082:          
3083:                  This function is USB_INTERRUPT mode safe and may be called from main loop
3084:                  code without risk of retrieving a partially updated 32-bit number.
3085:          
3086:                  However, this value only increments when the USBDeviceTasks() function is allowed
3087:                  to execute.  If USB_INTERRUPT mode is used, it is allowable to block on this
3088:                  function.  If however USB_POLLING mode is used, one must not block on this
3089:                  function without also calling USBDeviceTasks() continuously for the blocking
3090:                  duration (since the USB stack must still be allowed to execute, and the USB
3091:                  stack is also responsible for updating the tick counter internally).
3092:          
3093:                  If the application is operating in USB_POLLING mode, this function should
3094:                  only be called from the main loop context, and not from an interrupt handler,
3095:                  as the returned value could be incorrect, if the main loop context code was in
3096:                  the process of updating the internal count at the moment of the interrupt event.
3097:             ***************************************************************************/
3098:          uint32_t USBGet1msTickCount(void)
3099:          {
3100:              #if defined (USB_INTERRUPT)
3101:                  uint32_t localContextValue;
3102:          
3103:                  //Repeatedly read the interrupt context variable, until we get a stable/unchanging
3104:                  //value.  This ensures that the complete 32-bit value got read without
3105:                  //getting interrupted in between bytes.
3106:                  do
3107:                  {
3108:                      localContextValue = USB1msTickCount;
3109:                  }while(localContextValue != USB1msTickCount);
3110:          
3111:                  return localContextValue;    
3112:              
3113:              #else
3114:                  return USB1msTickCount;
3115:              #endif
3116:          }
3117:          
3118:          
3119:          
3120:          
3121:          
3122:          
3123:          /** EOF USBDevice.c *****************************************************/
---  /home/phil/Projects/XPRESS-Loader/MPLAB.X/tmr2.c  --------------------------------------------------
1:             /**
2:               TMR2 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr2.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR2 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR2.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.77
17:                    Device            :  PIC16F1455
18:                    Driver Version    :  2.01
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.05 and above
21:                    MPLAB 	          :  MPLAB X 5.20
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "tmr2.h"
53:            
54:            /**
55:              Section: Global Variables Definitions
56:            */
57:            
58:            /**
59:              Section: TMR2 APIs
60:            */
61:            
62:            void TMR2_Initialize(void)
63:            {
64:                // Set TMR2 to the options selected in the User Interface
65:            
66:                // PR2 37; 
67:                PR2 = 0x50;
016D  3050     MOVLW 0x50
016E  009B     MOVWF 0x11B
68:            
69:                // TMR2 0; 
70:                TMR2 = 0x00;
016F  019A     CLRF 0x11A
71:            
72:                // Clearing IF flag.
73:                PIR1bits.TMR2IF = 0;
0170  1091     BCF CM1CON0, 0x1
74:            
75:                // T2CKPS 1:4; T2OUTPS 1:1; TMR2ON on; 
76:                T2CON = 0x05;
0171  3005     MOVLW 0x5
0172  009C     MOVWF 0x11C
77:            }
0173  0008     RETURN
78:            
79:            void TMR2_StartTimer(void)
80:            {
81:                // Start the Timer by writing to TMRxON bit
82:                T2CONbits.TMR2ON = 1;
0174  151C     BSF 0x11C, 0x2
83:            }
0175  0008     RETURN
84:            
85:            void TMR2_StopTimer(void)
86:            {
87:                // Stop the Timer by writing to TMRxON bit
88:                T2CONbits.TMR2ON = 0;
89:            }
90:            
91:            uint8_t TMR2_ReadTimer(void)
92:            {
93:                uint8_t readVal;
94:            
95:                readVal = TMR2;
96:            
97:                return readVal;
98:            }
99:            
100:           void TMR2_WriteTimer(uint8_t timerVal)
101:           {
102:               // Write to the Timer2 register
103:               TMR2 = timerVal;
104:           }
105:           
106:           void TMR2_LoadPeriodRegister(uint8_t periodVal)
107:           {
108:              PR2 = periodVal;
109:           }
110:           
111:           bool TMR2_HasOverflowOccured(void)
112:           {
113:               // check if  overflow has occurred by checking the TMRIF bit
114:               bool status = PIR1bits.TMR2IF;
115:               if(status)
116:               {
117:                   // Clearing IF flag.
118:                   PIR1bits.TMR2IF = 0;
119:               }
120:               return status;
121:           }
122:           /**
123:             End of File
124:           */
---  /home/phil/Projects/XPRESS-Loader/MPLAB.X/tmr1.c  --------------------------------------------------
1:             /**
2:               TMR1 Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 tmr1.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the TMR1 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This source file provides APIs for TMR1.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.77
17:                    Device            :  PIC16F1455
18:                    Driver Version    :  2.11
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.05 and above
21:                    MPLAB 	          :  MPLAB X 5.20
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "tmr1.h"
53:            
54:            /**
55:              Section: Global Variables Definitions
56:            */
57:            volatile uint16_t timer1ReloadVal;
58:            
59:            /**
60:              Section: TMR1 APIs
61:            */
62:            
63:            void TMR1_Initialize(void)
64:            {
65:                //Set the Timer to the options selected in the GUI
66:            
67:                //T1GSS T1G_pin; TMR1GE disabled; T1GTM disabled; T1GPOL low; T1GGO_nDONE done; T1GSPM disabled; 
68:                T1GCON = 0x00;
0158  0020     MOVLB 0x0
0159  0199     CLRF T1GCON
69:            
70:                //TMR1H 255; 
71:                TMR1H = 0xFF;
015A  30FF     MOVLW 0xFF
015B  0097     MOVWF TMR1H
72:            
73:                //TMR1L 62; 
74:                TMR1L = 0x3E;
015C  303E     MOVLW 0x3E
015D  0096     MOVWF TMR1
75:            
76:                // Load the TMR value to reload variable
77:                timer1ReloadVal=(uint16_t)((TMR1H << 8) | TMR1L);
015E  0817     MOVF TMR1H, W
015F  0022     MOVLB 0x2
0160  00C5     MOVWF 0x145
0161  01C4     CLRF timer1ReloadVal
0162  0020     MOVLB 0x0
0163  0816     MOVF TMR1, W
0164  0022     MOVLB 0x2
0165  04C4     IORWF timer1ReloadVal, F
78:            
79:                // Clearing IF flag.
80:                PIR1bits.TMR1IF = 0;
0166  0020     MOVLB 0x0
0167  1011     BCF PIR1, 0x0
81:            
82:                // T1CKPS 1:8; T1OSCEN disabled; nT1SYNC do_not_synchronize; TMR1CS LFINTOSC; TMR1ON enabled; 
83:                T1CON = 0xF5;
0168  30F5     MOVLW 0xF5
0169  0098     MOVWF T1CON
84:            }
016A  0008     RETURN
85:            
86:            void TMR1_StartTimer(void)
87:            {
88:                // Start the Timer by writing to TMRxON bit
89:                T1CONbits.TMR1ON = 1;
016B  1418     BSF T1CON, 0x0
90:            }
016C  0008     RETURN
91:            
92:            void TMR1_StopTimer(void)
93:            {
94:                // Stop the Timer by writing to TMRxON bit
95:                T1CONbits.TMR1ON = 0;
96:            }
97:            
98:            uint16_t TMR1_ReadTimer(void)
99:            {
100:               uint16_t readVal;
101:               uint8_t readValHigh;
102:               uint8_t readValLow;
103:               
104:           	
105:               readValLow = TMR1L;
106:               readValHigh = TMR1H;
107:               
108:               readVal = ((uint16_t)readValHigh << 8) | readValLow;
109:           
110:               return readVal;
111:           }
112:           
113:           void TMR1_WriteTimer(uint16_t timerVal)
114:           {
115:               if (T1CONbits.nT1SYNC == 1)
05EA  0020     MOVLB 0x0
05EB  1D18     BTFSS T1CON, 0x2
05EC  2DF4     GOTO 0x5F4
116:               {
117:                   // Stop the Timer by writing to TMRxON bit
118:                   T1CONbits.TMR1ON = 0;
05ED  1018     BCF T1CON, 0x0
119:           
120:                   // Write to the Timer1 register
121:                   TMR1H = (timerVal >> 8);
05EE  0871     MOVF data, W
05EF  0097     MOVWF TMR1H
122:                   TMR1L = timerVal;
05F0  0870     MOVF __pcstackCOMMON, W
05F1  0096     MOVWF TMR1
123:           
124:                   // Start the Timer after writing to the register
125:                   T1CONbits.TMR1ON =1;
05F2  1418     BSF T1CON, 0x0
126:               }
05F3  0008     RETURN
127:               else
128:               {
129:                   // Write to the Timer1 register
130:                   TMR1H = (timerVal >> 8);
05F4  0871     MOVF data, W
05F5  0097     MOVWF TMR1H
131:                   TMR1L = timerVal;
05F6  0870     MOVF __pcstackCOMMON, W
05F7  0096     MOVWF TMR1
132:               }
133:           }
05F8  0008     RETURN
134:           
135:           void TMR1_Reload(void)
136:           {
137:               TMR1_WriteTimer(timer1ReloadVal);
02C6  0022     MOVLB 0x2
02C7  0845     MOVF 0x145, W
02C8  00F1     MOVWF 0x171
02C9  0844     MOVF timer1ReloadVal, W
02CA  00F0     MOVWF 0x170
02CB  2DEA     GOTO 0x5EA
138:           }
139:           
140:           void TMR1_StartSinglePulseAcquisition(void)
141:           {
142:               T1GCONbits.T1GGO_nDONE = 1;
143:           }
144:           
145:           uint8_t TMR1_CheckGateValueStatus(void)
146:           {
147:               return (T1GCONbits.T1GVAL);
148:           }
149:           
150:           bool TMR1_HasOverflowOccured(void)
151:           {
152:               // check if  overflow has occurred by checking the TMRIF bit
153:               return(PIR1bits.TMR1IF);
02C3  0811     MOVF CM1CON0, W
02C4  3901     ANDLW 0x1
154:           }
02C5  0008     RETURN
155:           /**
156:             End of File
157:           */
---  /home/phil/Projects/XPRESS-Loader/MPLAB.X/system_config/XPRESS/system.c  ---------------------------
1:             /*******************************************************************************
2:             Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:             
4:             System Initialization 
5:               
6:             Licensed under the Apache License, Version 2.0 (the "License");
7:             you may not use this file except in compliance with the License.
8:             You may obtain a copy of the License at
9:             
10:                http://www.apache.org/licenses/LICENSE-2.0
11:            
12:            Unless required by applicable law or agreed to in writing, software
13:            distributed under the License is distributed on an "AS IS" BASIS,
14:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
15:            See the License for the specific language governing permissions and
16:            limitations under the License.
17:            
18:            *******************************************************************************/
19:            
20:            #include <xc.h>
21:            #include "system.h"
22:            #include "system_config.h"
23:            #include "usb.h"
24:            #include "fileio.h"
25:            #include "direct.h"
26:            
27:            
28:            // CONFIG1
29:            #pragma config FOSC = INTOSC    // Oscillator Selection Bits->INTOSC oscillator: I/O function on CLKIN pin
30:            #pragma config WDTE = OFF    // Watchdog Timer Enable->WDT disabled
31:            #pragma config PWRTE = OFF    // Power-up Timer Enable->PWRT disabled
32:            #pragma config MCLRE = ON    // MCLR Pin Function Select->MCLR/VPP pin function is MCLR
33:            #pragma config CP = OFF    // Flash Program Memory Code Protection->Program memory code protection is disabled
34:            #pragma config BOREN = ON    // Brown-out Reset Enable->Brown-out Reset enabled
35:            #pragma config CLKOUTEN = OFF    // Clock Out Enable->CLKOUT function is disabled. I/O or oscillator function on the CLKOUT pin
36:            #pragma config IESO = ON    // Internal/External Switchover Mode->Internal/External Switchover Mode is enabled
37:            #pragma config FCMEN = ON    // Fail-Safe Clock Monitor Enable->Fail-Safe Clock Monitor is enabled
38:            
39:            // CONFIG2
40:            #pragma config WRT = OFF    // Flash Memory Self-Write Protection->Write protection off
41:            #pragma config CPUDIV = NOCLKDIV    // CPU System Clock Selection Bit->NO CPU system divide
42:            #pragma config USBLSCLK = 48MHz    // USB Low SPeed Clock Selection bit->System clock expects 48 MHz, FS/LS USB CLKENs divide-by is set to 8.
43:            #pragma config PLLMULT = 3x    // PLL Multipler Selection Bit->3x Output Frequency Selected
44:            #pragma config PLLEN = ENABLED    // PLL Enable Bit->3x or 4x PLL Enabled
45:            #pragma config STVREN = ON    // Stack Overflow/Underflow Reset Enable->Stack Overflow or Underflow will cause a Reset
46:            #pragma config BORV = LO    // Brown-out Reset Voltage Selection->Brown-out Reset Voltage (Vbor), low trip point selected.
47:            #pragma config LPBOR = OFF    // Low-Power Brown Out Reset->Low-Power BOR is disabled
48:            #pragma config LVP = ON    // Low-Voltage Programming Enable->Low-voltage programming enabled
49:            
50:            
51:            void OSCILLATOR_Initialize(void)
52:            {
53:                // SCS FOSC; SPLLMULT 3xPLL; SPLLEN disabled; IRCF 16MHz_HF; 
54:                OSCCON = 0x7C;
007E  307C     MOVLW 0x7C
007F  0021     MOVLB 0x1
0080  0099     MOVWF OSCCON
55:                // TUN 0; 
56:                OSCTUNE = 0x00;
0081  0198     CLRF OSCTUNE
57:                // ACTSRC SOSC; ACTUD enabled; ACTEN disabled; 
58:                ACTCON = 0x00;
0082  0027     MOVLB 0x7
0083  019B     CLRF ACTCON
59:                // SBOREN disabled; BORFS disabled; 
60:                BORCON = 0x00;
0084  0022     MOVLB 0x2
0085  0196     CLRF BORCON
61:                // Wait for PLL to stabilize
62:                while(PLLRDY == 0)
63:                {
64:                }
0086  0021     MOVLB 0x1
0087  1B1A     BTFSC OSCSTAT, 0x6
0088  0008     RETURN
0089  2886     GOTO 0x86
65:            }
66:            
67:            /*********************************************************************
68:            * Function: void SYSTEM_Initialize(void)
69:            *
70:            * Overview: Initializes the system.
71:            *
72:            * PreCondition: None
73:            *
74:            * Input:  SYSTEM_STATE - the state to initialize the system into
75:            *
76:            * Output: None
77:            *
78:            ********************************************************************/
79:            void SYSTEM_Initialize(void)
80:            {
81:                //Configure oscillator settings for clock settings compatible with USB
82:                //operation.  Note: Proper settings depends on USB speed (full or low).
83:                OSCILLATOR_Initialize();
0064  207E     CALL 0x7E
0065  3180     MOVLP 0x0
84:               
85:               
86:            //	The USB specifications require that USB peripheral devices must never source
87:            //	current onto the Vbus pin.  Additionally, USB peripherals should not source
88:            //	current on D+ or D- when the host/hub is not actively powering the Vbus line.
89:            //	When designing a self powered (as opposed to bus powered) USB peripheral
90:            //	device, the firmware should make sure not to turn on the USB module and D+
91:            //	or D- pull up resistor unless Vbus is actively powered.  Therefore, the
92:            //	firmware needs some means to detect when Vbus is being powered by the host.
93:            //	A 5V tolerant I/O pin can be connected to Vbus (through a resistor), and
94:            // 	can be used to detect when Vbus is high (host actively powering), or low
95:            //	(host is shut down or otherwise not supplying power).  The USB firmware
96:            // 	can then periodically poll this I/O pin to know when it is okay to turn on
97:            //	the USB module/D+/D- pull up resistor.  When designing a purely bus powered
98:            //	peripheral device, it is not possible to source current on D+ or D- when the
99:            //	host is not actively providing power on Vbus. Therefore, implementing this
100:           //	bus sense feature is optional.  This firmware can be made to use this bus
101:           //	sense feature by making sure "USE_USB_BUS_SENSE_IO" has been defined in the
102:           //	HardwareProfile.h file.
103:               #if defined(USE_USB_BUS_SENSE_IO)
104:               tris_usb_bus_sense = INPUT_PIN;
105:               #endif
106:           
107:           //	If the host PC sends a GetStatus (device) request, the firmware must respond
108:           //	and let the host know if the USB peripheral device is currently bus powered
109:           //	or self powered.  See chapter 9 in the official USB specifications for details
110:           //	regarding this request.  If the peripheral device is capable of being both
111:           //	self and bus powered, it should not return a hard coded value for this request.
112:           //	Instead, firmware should check if it is currently self or bus powered, and
113:           //	respond accordingly.  If the hardware has been configured like demonstrated
114:           //	on the PICDEM FS USB Demo Board, an I/O pin can be polled to determine the
115:           //	currently selected power source.  On the PICDEM FS USB Demo Board, "RA2"
116:           //	is used for	this purpose.  If using this feature, make sure "USE_SELF_POWER_SENSE_IO"
117:           //	has been defined in HardwareProfile.h, and that an appropriate I/O pin has been mapped
118:           //	to it in HardwareProfile.h.
119:               #if defined(USE_SELF_POWER_SENSE_IO)
120:               tris_self_power = INPUT_PIN;
121:               #endif
122:           
123:               DIRECT_Initialize();
0066  2072     CALL 0x72
0067  3180     MOVLP 0x0
124:               USBDeviceInit();	//usb_device.c.  Initializes USB module SFRs and firmware
0068  20E5     CALL 0xE5
125:               					//variables to known states.
126:               TRISCbits.TRISC3 = 0;
0069  118E     BCF TRISC, 0x3
127:               ANSELAbits.ANSA4 = 0;
006A  0023     MOVLB 0x3
006B  120C     BCF ANSELA, 0x4
128:               OPTION_REGbits.nWPUEN = 0;
006C  0021     MOVLB 0x1
006D  1395     BCF OPTION_REG, 0x7
129:               WPUAbits.WPUA5 = 1;
006E  0024     MOVLB 0x4
006F  168C     BSF WPUA, 0x5
130:               WPUAbits.WPUA4 = 0;
0070  120C     BCF WPUA, 0x4
131:           }
0071  0008     RETURN
132:           
133:           			
134:           			
135:           void interrupt SYS_InterruptHigh(void)
0004  147E     BSF 0x27E, 0x0
0005  3180     MOVLP 0x0
136:           {
137:               #if defined(USB_INTERRUPT)
138:                   USBDeviceTasks();
139:               #endif
140:           }
0006  107E     BCF 0x27E, 0x0
0007  0009     RETFIE
141:           
---  /home/phil/Projects/XPRESS-Loader/MPLAB.X/pwm2.c  --------------------------------------------------
1:              /**
2:                PWM2 Generated Driver File
3:              
4:                @Company
5:                  Microchip Technology Inc.
6:              
7:                @File Name
8:                  pwm2.c
9:              
10:               @Summary
11:                 This is the generated driver implementation file for the PWM2 driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:             
13:               @Description
14:                 This source file provides implementations for driver APIs for PWM2.
15:                 Generation Information :
16:                     Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.77
17:                     Device            :  PIC16F1455
18:                     Driver Version    :  2.01
19:                 The generated drivers are tested against the following:
20:                     Compiler          :  XC8 2.05 and above or later
21:                     MPLAB             :  MPLAB X 5.20
22:             */ 
23:            
24:             /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:             
47:             /**
48:               Section: Included Files
49:             */
50:            
51:             #include <xc.h>
52:             #include "pwm2.h"
53:            
54:             /**
55:               Section: PWM Module APIs
56:             */
57:            
58:             void PWM2_Initialize(void)
59:             {
60:                // Set the PWM to the options selected in the PIC10 / PIC12 / PIC16 / PIC18 MCUs.
61:                // PWM2POL active_hi; PWM2OE enabled; PWM2EN enabled; 
62:                PWM2CON = 0xC0;   
00E1  30C0     MOVLW 0xC0
00E2  002C     MOVLB 0xC
00E3  0096     MOVWF PWM2CON
63:            
64:             }
00E4  0008     RETURN
65:            
66:             void PWM2_LoadDutyValue(uint8_t dutyValue)
02BF  00F0     MOVWF 0x670
67:             {
68:                 // Writing to 8 MSBs of PWM duty cycle in PWMDCH register
69:                 // This ignores the bottom two bits of PWM2DCH
70:                 PWM2DCH = dutyValue;
02C0  002C     MOVLB 0xC
02C1  0095     MOVWF PWM2DCH
71:                 
72:             }
02C2  0008     RETURN
73:             
74:             void PWM2_Off(void) {
75:                 // turn PWM off
76:                 PWM2CON = 0x00;
0154  002C     MOVLB 0xC
0155  0196     CLRF PWM2CON
77:             }
0156  0008     RETURN
78:             /**
79:              End of File
80:             */
---  /home/phil/Projects/XPRESS-Loader/MPLAB.X/memory.c  ------------------------------------------------
1:             /**
2:               MEMORY Generated Driver File
3:             
4:               @Company
5:                 Microchip Technology Inc.
6:             
7:               @File Name
8:                 memory.c
9:             
10:              @Summary
11:                This is the generated driver implementation file for the MEMORY driver using PIC10 / PIC12 / PIC16 / PIC18 MCUs
12:            
13:              @Description
14:                This file provides implementations of driver APIs for MEMORY.
15:                Generation Information :
16:                    Product Revision  :  PIC10 / PIC12 / PIC16 / PIC18 MCUs - 1.77
17:                    Device            :  PIC16F1455
18:                    Driver Version    :  2.01
19:                The generated drivers are tested against the following:
20:                    Compiler          :  XC8 2.05 and above
21:                    MPLAB             :  MPLAB X 5.20
22:            */
23:            
24:            /*
25:                (c) 2018 Microchip Technology Inc. and its subsidiaries. 
26:                
27:                Subject to your compliance with these terms, you may use Microchip software and any 
28:                derivatives exclusively with Microchip products. It is your responsibility to comply with third party 
29:                license terms applicable to your use of third party software (including open source software) that 
30:                may accompany Microchip software.
31:                
32:                THIS SOFTWARE IS SUPPLIED BY MICROCHIP "AS IS". NO WARRANTIES, WHETHER 
33:                EXPRESS, IMPLIED OR STATUTORY, APPLY TO THIS SOFTWARE, INCLUDING ANY 
34:                IMPLIED WARRANTIES OF NON-INFRINGEMENT, MERCHANTABILITY, AND FITNESS 
35:                FOR A PARTICULAR PURPOSE.
36:                
37:                IN NO EVENT WILL MICROCHIP BE LIABLE FOR ANY INDIRECT, SPECIAL, PUNITIVE, 
38:                INCIDENTAL OR CONSEQUENTIAL LOSS, DAMAGE, COST OR EXPENSE OF ANY KIND 
39:                WHATSOEVER RELATED TO THE SOFTWARE, HOWEVER CAUSED, EVEN IF MICROCHIP 
40:                HAS BEEN ADVISED OF THE POSSIBILITY OR THE DAMAGES ARE FORESEEABLE. TO 
41:                THE FULLEST EXTENT ALLOWED BY LAW, MICROCHIP'S TOTAL LIABILITY ON ALL 
42:                CLAIMS IN ANY WAY RELATED TO THIS SOFTWARE WILL NOT EXCEED THE AMOUNT 
43:                OF FEES, IF ANY, THAT YOU HAVE PAID DIRECTLY TO MICROCHIP FOR THIS 
44:                SOFTWARE.
45:            */
46:            
47:            /**
48:              Section: Included Files
49:            */
50:            
51:            #include <xc.h>
52:            #include "memory.h"
53:            
54:            /**
55:              Section: Flash Module APIs
56:            */
57:            
58:            int8_t FLASH_WriteBlock(uint16_t writeAddr, uint16_t *flashWordArray)
59:            {
60:                uint16_t    blockStartAddr  = (uint16_t )(writeAddr & ((END_FLASH-1) ^ (ERASE_FLASH_BLOCKSIZE-1)));
127A  30FF     MOVLW 0xFF
127B  00FA     MOVWF 0x67A
127C  301F     MOVLW 0x1F
127D  00FB     MOVWF 0x67B
127E  06FA     XORWF 0x67A, F
127F  0873     MOVF 0x673, W
1280  05FA     ANDWF 0x67A, F
1281  0874     MOVF 0x674, W
1282  05FB     ANDWF 0x67B, F
61:                uint8_t     GIEBitValue = INTCONbits.GIE;   // Save interrupt enable
1283  3000     MOVLW 0x0
1284  1B8B     BTFSC INTCON, 0x7
1285  3001     MOVLW 0x1
1286  00F9     MOVWF 0x679
62:                uint8_t i;
63:            
64:                // Flash write must start at the beginning of a row
65:                if( writeAddr != blockStartAddr )
1287  087B     MOVF 0x67B, W
1288  0674     XORWF 0x674, W
1289  1D03     BTFSS STATUS, 0x2
128A  2A8D     GOTO 0x28D
128B  087A     MOVF 0x67A, W
128C  0673     XORWF 0x673, W
128D  1D03     BTFSS STATUS, 0x2
128E  0008     RETURN
66:                {
67:                    return -1;
68:                }
69:            
70:                INTCONbits.GIE = 0;         // Disable interrupts
128F  138B     BCF INTCON, 0x7
71:            
72:                // Block erase sequence
73:                FLASH_EraseBlock(writeAddr);
1290  0874     MOVF 0x674, W
1291  00F1     MOVWF 0x671
1292  0873     MOVF 0x673, W
1293  00F0     MOVWF 0x670
1294  22C7     CALL 0x2C7
1295  3191     MOVLP 0x11
74:            
75:                // Block write sequence
76:                PMCON1bits.CFGS = 0;    // Deselect Configuration space
1296  1315     BCF PWM2DCH, 0x6
77:                PMCON1bits.WREN = 1;    // Enable wrties
1297  1515     BSF PWM2DCH, 0x2
78:                PMCON1bits.LWLO = 1;    // Only load write latches
1298  1695     BSF PWM2DCH, 0x5
79:            
80:                for (i=0; i<WRITE_FLASH_BLOCKSIZE; i++)
1299  01FC     CLRF 0x67C
12BE  3020     MOVLW 0x20
12BF  0AFC     INCF 0x67C, F
12C0  027C     SUBWF 0x67C, W
12C1  1C03     BTFSS STATUS, 0x0
12C2  2A9A     GOTO 0x29A
81:                {
82:                    // Load lower 8 bits of write address
83:                    PMADRL = (writeAddr & 0xFF);
129A  0873     MOVF 0x673, W
129B  0023     MOVLB 0x3
129C  0091     MOVWF PMADR
84:                    // Load upper 6 bits of write address
85:                    PMADRH = ((writeAddr & 0xFF00) >> 8);
129D  0874     MOVF 0x1F4, W
129E  0092     MOVWF PMADRH
86:            
87:            	// Load data in current address
88:                    PMDATL = flashWordArray[i];
129F  357C     LSLF 0x1FC, W
12A0  0775     ADDWF 0x1F5, W
12A1  00F6     MOVWF 0x1F6
12A2  0086     MOVWF FSR1L
12A3  3003     MOVLW 0x3
12A4  0087     MOVWF FSR1H
12A5  0801     MOVF INDF1, W
12A6  0093     MOVWF PMDAT
89:                    PMDATH = ((flashWordArray[i] & 0xFF00) >> 8);
12A7  357C     LSLF 0x1FC, W
12A8  0775     ADDWF 0x1F5, W
12A9  00F6     MOVWF 0x1F6
12AA  0086     MOVWF FSR1L
12AB  3F40     MOVIW 0[FSR1]
12AC  00F7     MOVWF 0x1F7
12AD  3F41     MOVIW 1[FSR1]
12AE  00F8     MOVWF 0x1F8
12AF  0094     MOVWF PMDATH
90:            
91:                    if(i == (WRITE_FLASH_BLOCKSIZE-1))
12B0  301F     MOVLW 0x1F
12B1  067C     XORWF 0x1FC, W
12B2  1903     BTFSC STATUS, 0x2
92:                    {
93:                        // Start Flash program memory write
94:                        PMCON1bits.LWLO = 0;
12B3  1295     BCF PMCON1, 0x5
95:                    }
96:            
97:                    PMCON2 = 0x55;
12B4  3055     MOVLW 0x55
12B5  0096     MOVWF PMCON2
98:                    PMCON2 = 0xAA;
12B6  30AA     MOVLW 0xAA
12B7  0096     MOVWF PMCON2
99:                    PMCON1bits.WR = 1;
12B8  1495     BSF PMCON1, 0x1
100:                   NOP();
12B9  0000     NOP
101:                   NOP();
12BA  0000     NOP
102:           
103:           	writeAddr++;
12BB  0AF3     INCF 0x1F3, F
12BC  1903     BTFSC STATUS, 0x2
12BD  0AF4     INCF 0x1F4, F
104:               }
105:           
106:               PMCON1bits.WREN = 0;       // Disable writes
12C3  0023     MOVLB 0x3
12C4  1115     BCF PMCON1, 0x2
107:               INTCONbits.GIE = GIEBitValue;   // Restore interrupt enable
12C5  0C79     RRF 0x1F9, W
12C6  2AFB     GOTO 0x2FB
108:           
109:               return 0;
110:           }
111:           
112:           void FLASH_EraseBlock(uint16_t startAddr)
113:           {
114:               uint8_t GIEBitValue = INTCONbits.GIE;   // Save interrupt enable
12C7  3000     MOVLW 0x0
12C8  1B8B     BTFSC INTCON, 0x7
12C9  3001     MOVLW 0x1
12CA  00F2     MOVWF 0x1F2
115:           
116:           
117:               INTCONbits.GIE = 0; // Disable interrupts
12CB  138B     BCF INTCON, 0x7
118:               // Load lower 8 bits of erase address boundary
119:               PMADRL = (startAddr & 0xFF);
12CC  0870     MOVF 0x1F0, W
12CD  0023     MOVLB 0x3
12CE  0091     MOVWF PMADR
120:               // Load upper 6 bits of erase address boundary
121:               PMADRH = ((startAddr & 0xFF00) >> 8);
12CF  0871     MOVF 0x1F1, W
12D0  0092     MOVWF PMADRH
122:           
123:               // Block erase sequence
124:               PMCON1bits.CFGS = 0;    // Deselect Configuration space
12D1  1315     BCF PMCON1, 0x6
125:               PMCON1bits.FREE = 1;    // Specify an erase operation
12D2  1615     BSF PMCON1, 0x4
126:               PMCON1bits.WREN = 1;    // Allows erase cycles
12D3  1515     BSF PMCON1, 0x2
127:           
128:               // Start of required sequence to initiate erase
129:               PMCON2 = 0x55;
12D4  3055     MOVLW 0x55
12D5  0096     MOVWF PMCON2
130:               PMCON2 = 0xAA;
12D6  30AA     MOVLW 0xAA
12D7  0096     MOVWF PMCON2
131:               PMCON1bits.WR = 1;      // Set WR bit to begin erase
12D8  1495     BSF PMCON1, 0x1
132:               NOP();
12D9  0000     NOP
133:               NOP();
12DA  0000     NOP
134:           
135:               PMCON1bits.WREN = 0;       // Disable writes
12DB  0023     MOVLB 0x3
12DC  1115     BCF PMCON1, 0x2
136:               INTCONbits.GIE = GIEBitValue;	// Restore interrupt enable
12DD  0C72     RRF 0x1F2, W
12DE  2AFB     GOTO 0x2FB
137:           }
138:           /**
139:            End of File
140:           */
---  /home/phil/Projects/XPRESS-Loader/MPLAB.X/main.c  --------------------------------------------------
1:             /*******************************************************************************
2:             Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:             
4:              MSD Loader and CDC Interface for the MPLAB XPRESS Evaluation Board
5:                
6:             Licensed under the Apache License, Version 2.0 (the "License");
7:             you may not use this file except in compliance with the License.
8:             You may obtain a copy of the License at
9:             
10:                http://www.apache.org/licenses/LICENSE-2.0
11:            
12:            Unless required by applicable law or agreed to in writing, software
13:            distributed under the License is distributed on an "AS IS" BASIS,
14:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
15:            See the License for the specific language governing permissions and
16:            limitations under the License.
17:             
18:            *******************************************************************************/
19:            
20:            /** INCLUDES *******************************************************/
21:            #include "system.h"     // find release MAJOR/MINOR and DATE in here!!!
22:            #include "system_config.h"
23:            
24:            #include "usb.h"
25:            #include "usb_device_msd.h"
26:            
27:            #include "app_device_msd.h"
28:            #include "direct.h"
29:            #include "tmr1.h"
30:            #include "tmr2.h"
31:            #include "pwm2.h"
32:            
33:            /********************************************************************
34:             * Function:        void main(void)
35:             *******************************************************************/
36:            inline void goto_app(void) {
37:                PWM2CONbits.PWM2EN = 0;
008A  002C     MOVLB 0xC
008B  1396     BCF PWM2CON, 0x7
38:                LATCbits.LATC3 = 0;    
008C  0022     MOVLB 0x2
008D  118E     BCF LATC, 0x3
39:                asm ("movlp 0x16"); 
008E  3196     MOVLP 0x16
40:                asm ("goto 0x600");    
008F  2E00     GOTO 0x600
41:            }
0090  0008     RETURN
42:            
43:            inline void throb(void) {
44:                static uint8_t duty = PWM2_MAX_VALUE;
45:                static bool throb_up = false;
46:                if (TMR1_HasOverflowOccured()) {
00B2  22C3     CALL 0x2C3
00B3  3180     MOVLP 0x0
00B4  3A00     XORLW 0x0
00B5  1903     BTFSC STATUS, 0x2
00B6  28AC     GOTO 0xAC
00B7  28B9     GOTO 0xB9
00B8  28AC     GOTO 0xAC
47:                    PWM2_Initialize();
00B9  20E1     CALL 0xE1
00BA  3180     MOVLP 0x0
48:                    if (throb_up) {
00BB  0022     MOVLB 0x2
00BC  085E     MOVF 0x15E, W
00BD  1903     BTFSC STATUS, 0x2
00BE  28CA     GOTO 0xCA
00BF  28C1     GOTO 0xC1
00C0  28CA     GOTO 0xCA
49:                        duty++;
00C1  0AEE     INCF __pdataBANK2, F
50:                        if (duty >= PWM2_MAX_VALUE) throb_up = false;
00C2  3028     MOVLW 0x28
00C3  026E     SUBWF __pdataBANK2, W
00C4  1C03     BTFSS STATUS, 0x0
00C5  28D3     GOTO 0xD3
00C6  28C8     GOTO 0xC8
00C7  28D3     GOTO 0xD3
00C8  01DE     CLRF 0x15E
00C9  28D3     GOTO 0xD3
51:                    } else {
52:                        duty--;
00CA  03EE     DECF __pdataBANK2, F
53:                        if (duty <= 6) throb_up = true;                
00CB  3007     MOVLW 0x7
00CC  026E     SUBWF __pdataBANK2, W
00CD  1803     BTFSC STATUS, 0x0
00CE  28D3     GOTO 0xD3
00CF  28D1     GOTO 0xD1
00D0  28D3     GOTO 0xD3
00D1  01DE     CLRF 0x15E
00D2  0ADE     INCF 0x15E, F
54:                    }
55:                    PWM2_LoadDutyValue(duty);
00D3  086E     MOVF __pdataBANK2, W
00D4  22BF     CALL 0x2BF
00D5  3180     MOVLP 0x0
56:                    PIR1bits.TMR1IF = 0;
00D6  0020     MOVLB 0x0
00D7  1011     BCF PIR1, 0x0
57:                    TMR1_Reload();
00D8  22C6     CALL 0x2C6
00D9  3180     MOVLP 0x0
00DA  28AC     GOTO 0xAC
58:                }
59:            }
60:            
61:            #define charged() (PORTAbits.RA5)
62:            
63:            void run_usb(void) {
64:                USBDeviceInit();
0098  20E5     CALL 0xE5
0099  3180     MOVLP 0x0
65:                USBDeviceAttach();
66:                TMR1_Initialize();
009A  2158     CALL 0x158
009B  3180     MOVLP 0x0
67:                TMR1_StartTimer();
009C  216B     CALL 0x16B
009D  3180     MOVLP 0x0
68:                TMR2_Initialize();
009E  216D     CALL 0x16D
009F  3180     MOVLP 0x0
69:                TMR2_StartTimer();
00A0  2174     CALL 0x174
00A1  3180     MOVLP 0x0
70:                PWM2_Initialize();
00A2  20E1     CALL 0xE1
00A3  3180     MOVLP 0x0
71:                while(1)
72:                {
73:                    SYSTEM_Tasks();
74:            
75:                    #if defined(USB_POLLING)
76:                        USBDeviceTasks();
00A4  2176     CALL 0x176
00A5  3180     MOVLP 0x0
77:                    #endif
78:                        if (charged()) {
00A6  1E8C     BTFSS PORTA, 0x5
00A7  28B2     GOTO 0xB2
79:                            PWM2_Off();
00A8  2154     CALL 0x154
00A9  3180     MOVLP 0x0
80:                            LATCbits.LATC3 = 1;
00AA  0022     MOVLB 0x2
00AB  158E     BSF LATC, 0x3
81:                            
82:                        } else {
83:                            throb();
84:                        }
85:                    
86:                    /* If the USB device isn't configured yet, we can't really do anything
87:                     * else since we don't have a host to talk to.  So jump back to the
88:                     * top of the while loop. */
89:                    if( USBGetDeviceState() < CONFIGURED_STATE )
00AC  3020     MOVLW 0x20
00AD  0021     MOVLB 0x1
00AE  026E     SUBWF USBDeviceState, W
00AF  1803     BTFSC STATUS, 0x0
00B0  28DB     GOTO 0xDB
00B1  28A4     GOTO 0xA4
90:                    {   /* USB connection not available or not yet complete */
91:                        // implement nMCLR button 
92:                        /* Jump back to the top of the while loop. */
93:                        continue;
94:                    }
95:            
96:                    /* If we are currently suspended, then we need to see if we need to
97:                     * issue a remote wakeup.  In either case, we shouldn't process any
98:                     * keyboard commands since we aren't currently communicating to the host
99:                     * thus just continue back to the start of the while loop. */
100:                   if( USBIsDeviceSuspended() == true )
00DB  003D     MOVLB 0x1D
00DC  188E     BTFSC UCON, 0x1
00DD  28A4     GOTO 0xA4
101:                   {
102:                       /* Jump back to the top of the while loop. */
103:                       continue;
104:                   }
105:                   //Application specific tasks
106:                   APP_DeviceMSDTasks();
00DE  2157     CALL 0x157
00DF  3180     MOVLP 0x0
00E0  28A4     GOTO 0xA4
107:               }//end while    
108:           }
109:           
110:           bool isUSBPower(void) {
111:               return !PORTAbits.RA4;
0091  1003     BCF STATUS, 0x0
0092  0020     MOVLB 0x0
0093  1E0C     BTFSS PORTA, 0x4
0094  1403     BSF STATUS, 0x0
0095  3000     MOVLW 0x0
0096  3D09     ADDWFC WREG, W
112:           }
0097  0008     RETURN
113:           
114:           
115:           MAIN_RETURN main(void)
116:           {
117:               SYSTEM_Initialize();
004C  2064     CALL 0x64
004D  3180     MOVLP 0x0
118:               LATCbits.LATC3 = 0;
004E  0022     MOVLB 0x2
004F  118E     BCF LATC, 0x3
119:               __delay_ms(1);
0050  3010     MOVLW 0x10
0051  0021     MOVLB 0x1
0052  00E4     MOVWF 0xE4
0053  3094     MOVLW 0x94
0054  0B89     DECFSZ WREG, F
0055  2854     GOTO 0x54
0056  0BE4     DECFSZ 0xE4, F
0057  2854     GOTO 0x54
0058  0000     NOP
120:               if (isUSBPower()) {
0059  2091     CALL 0x91
005A  3180     MOVLP 0x0
005B  3A00     XORLW 0x0
005C  1903     BTFSC STATUS, 0x2
005D  2861     GOTO 0x61
121:                   run_usb();
005E  2098     CALL 0x98
005F  3180     MOVLP 0x0
122:               } else {
0060  2862     GOTO 0x62
123:                   goto_app();
0061  208A     CALL 0x8A
124:               } 
125:           }//end main
0062  3180     MOVLP 0x0
0063  2808     GOTO 0x8
126:           
127:           
128:           /*******************************************************************
129:            * Function:        bool USER_USB_CALLBACK_EVENT_HANDLER(
130:            *                        USB_EVENT event, void *pdata, uint16_t size)
131:            *
132:            * PreCondition:    None
133:            *
134:            * Input:           USB_EVENT event - the type of event
135:            *                  void *pdata - pointer to the event data
136:            *                  uint16_t size - size of the event data
137:            *
138:            * Output:          None
139:            *
140:            * Side Effects:    None
141:            *
142:            * Overview:        This function is called from the USB stack to
143:            *                  notify a user application that a USB event
144:            *                  occured.  This callback is in interrupt context
145:            *                  when the USB_INTERRUPT option is selected.
146:            *
147:            * Note:            None
148:            *******************************************************************/
149:           bool USER_USB_CALLBACK_EVENT_HANDLER(USB_EVENT event, void *pdata, uint16_t size)
150:           {
151:               switch((int)event)
0222  2A43     GOTO 0x243
0243  0821     MOVF sector_addr, W
0244  3A00     XORLW 0x0
0245  1903     BTFSC STATUS, 0x2
0246  2A4B     GOTO 0x24B
0247  3A7F     XORLW 0x7F
0248  1903     BTFSC STATUS, 0x2
0249  2A65     GOTO 0x265
024A  2A6A     GOTO 0x26A
024B  0820     MOVF __pcstackBANK1, W
024C  3A01     XORLW 0x1
024D  1903     BTFSC STATUS, 0x2
024E  2A23     GOTO 0x223
024F  3A03     XORLW 0x3
0250  1903     BTFSC STATUS, 0x2
0251  2A6A     GOTO 0x26A
0252  3A01     XORLW 0x1
0253  1903     BTFSC STATUS, 0x2
0254  2A24     GOTO 0x224
0255  3A06     XORLW 0x6
0256  1903     BTFSC STATUS, 0x2
0257  2A26     GOTO 0x226
0258  3A77     XORLW 0x77
0259  1903     BTFSC STATUS, 0x2
025A  2A6A     GOTO 0x26A
025B  3A01     XORLW 0x1
025C  1903     BTFSC STATUS, 0x2
025D  2A6A     GOTO 0x26A
025E  3A07     XORLW 0x7
025F  1903     BTFSC STATUS, 0x2
0260  2A6A     GOTO 0x26A
0261  3A01     XORLW 0x1
0262  1903     BTFSC STATUS, 0x2
0263  2A6A     GOTO 0x26A
0264  2A6A     GOTO 0x26A
0265  0820     MOVF __pcstackBANK1, W
0266  3AFF     XORLW 0xFF
0267  1903     BTFSC STATUS, 0x2
0268  2A6A     GOTO 0x26A
0269  2A6A     GOTO 0x26A
152:               {
153:                   case EVENT_TRANSFER:
154:                       //Add application specific callback task or callback function here if desired.
155:                       break;
156:           
157:                   case EVENT_SOF:
158:                       break;
159:           
160:                   case EVENT_SUSPEND:
161:                       break;
162:           
163:                   case EVENT_RESUME:
164:                       break;
165:           
166:                   case EVENT_CONFIGURED:
167:                       /* When the device is configured, we can (re)initialize the demo
168:                        * code. */
169:                       APP_DeviceMSDInitialize();
0223  2D75     GOTO 0x575
170:           
171:                       break;
172:           
173:                   case EVENT_SET_DESCRIPTOR:
174:                       break;
175:           
176:                   case EVENT_EP0_REQUEST:
177:                       /* We have received a non-standard USB request.  The MSD driver
178:                        * needs to check to see if the request was for it. */
179:                       USBCheckMSDRequest();
0224  3188     MOVLP 0x8
0225  28B9     GOTO 0xB9
180:           
181:                       break;
182:           
183:                   case EVENT_BUS_ERROR:
184:                       break;
185:           
186:                   case EVENT_TRANSFER_TERMINATED:
187:                       //Add application specific callback task or callback function here if desired.
188:                       //The EVENT_TRANSFER_TERMINATED event occurs when the host performs a CLEAR
189:                       //FEATURE (endpoint halt) request on an application endpoint which was
190:                       //previously armed (UOWN was = 1).  Here would be a good place to:
191:                       //1.  Determine which endpoint the transaction that just got terminated was
192:                       //      on, by checking the handle value in the *pdata.
193:                       //2.  Re-arm the endpoint if desired (typically would be the case for OUT
194:                       //      endpoints).
195:           
196:                       //Check if the host recently did a clear endpoint halt on the MSD OUT endpoint.
197:                       //In this case, we want to re-arm the MSD OUT endpoint, so we are prepared
198:                       //to receive the next CBW that the host might want to send.
199:                       //Note: If however the STALL was due to a CBW not valid condition,
200:                       //then we are required to have a persistent STALL, where it cannot
201:                       //be cleared (until MSD reset recovery takes place).  See MSD BOT
202:                       //specs v1.0, section 6.6.1.
203:                       if(MSDWasLastCBWValid() == false)
0226  0022     MOVLB 0x2
0227  085F     MOVF MSDCBWValid, W
0228  1D03     BTFSS STATUS, 0x2
0229  2A32     GOTO 0x232
204:                       {
205:                           //Need to re-stall the endpoints, for persistent STALL behavior.
206:                           USBStallEndpoint(MSD_DATA_IN_EP, IN_TO_HOST);
022A  3001     MOVLW 0x1
022B  01F0     CLRF 0x170
022C  0AF0     INCF 0x170, F
022D  226B     CALL 0x26B
022E  3180     MOVLP 0x0
207:                           USBStallEndpoint(MSD_DATA_OUT_EP, OUT_FROM_HOST);
022F  3001     MOVLW 0x1
0230  01F0     CLRF 0x170
0231  2A6B     GOTO 0x26B
208:                       }
209:                       else
210:                       {
211:                           //Check if the host cleared halt on the bulk out endpoint.  In this
212:                           //case, we should re-arm the endpoint, so we can receive the next CBW.
213:                           if((USB_HANDLE)pdata == USBGetNextHandle(MSD_DATA_OUT_EP, OUT_FROM_HOST))
0232  083D     MOVF 0x13D, W
0233  00FA     MOVWF 0x17A
0234  3000     MOVLW 0x0
0235  0021     MOVLB 0x1
0236  0623     XORWF 0xA3, W
0237  1D03     BTFSS STATUS, 0x2
0238  2A3B     GOTO 0x23B
0239  087A     MOVF 0xFA, W
023A  0622     XORWF chk, W
023B  1D03     BTFSS STATUS, 0x2
023C  0008     RETURN
023D  2598     CALL 0x598
023E  3180     MOVLP 0x0
214:                           {
215:                               USBMSDOutHandle = USBRxOnePacket(MSD_DATA_OUT_EP, (uint8_t*)&msd_cbw, MSD_OUT_EP_SIZE);
023F  2427     CALL 0x427
0240  0021     MOVLB 0x1
0241  00ED     MOVWF USBMSDOutHandle
0242  0008     RETURN
216:                           }
217:                       }
218:                       break;
219:           
220:                   default:
221:                       break;
222:               }
223:               return true;
224:           }
026A  0008     RETURN
225:           
226:           /*******************************************************************************
227:            End of File
228:           */
229:           
---  /home/phil/Projects/XPRESS-Loader/MPLAB.X/files.c  -------------------------------------------------
1:             /*******************************************************************************
2:             Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:             
4:              Memory Disk Drive File System Emulator
5:                 64-byte bulk-packet optimized
6:             
7:             Licensed under the Apache License, Version 2.0 (the "License");
8:             you may not use this file except in compliance with the License.
9:             You may obtain a copy of the License at
10:            
11:                http://www.apache.org/licenses/LICENSE-2.0
12:            
13:            Unless required by applicable law or agreed to in writing, software
14:            distributed under the License is distributed on an "AS IS" BASIS,
15:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
16:            See the License for the specific language governing permissions and
17:            limitations under the License.
18:            
19:            *******************************************************************************/
20:             
21:            #include "files.h"
22:            #include "string.h"
23:            
24:            //------------------------------------------------------------------------------
25:            //Master boot record (MBR) at LBA = 0
26:            //------------------------------------------------------------------------------
27:            void MasterBootRecordGet( uint8_t * buffer, uint8_t seg) 
1382  00F9     MOVWF 0xF9
28:            {  // fabricate an MBR structure in the RAM buffer segment
29:                memset( buffer, 0, MSD_OUT_EP_SIZE);  // clear buffer  
1383  246C     CALL 0x46C
1384  3185     MOVLP 0x5
1385  2526     CALL 0x526
1386  3193     MOVLP 0x13
30:                if (seg < 6)   return; // segments 0-5 from 0x000 - 0x17f are empty
1387  3006     MOVLW 0x6
1388  0278     SUBWF 0xF8, W
1389  1C03     BTFSS STATUS, 0x0
138A  0008     RETURN
31:            //Code Area
32:            // 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,	//0x0000
33:            // ...
34:            // 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                     //0x0180
35:            // IBM 9 byte/entry x 4 entries primary partition table
36:            // 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                             //0x018A
37:            // 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x0190
38:            // 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,             //0x01A0
39:            //
40:            // 0x00, 0x00,                                                                                     //0x01AE
41:            // 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,                                                 //0x01B0
42:            
43:                if (seg < 7)    {   // segment 6: 0x180 - 0x1bf 
138B  3007     MOVLW 0x7
138C  0278     SUBWF 0xF8, W
138E  1803     BTFSC STATUS, 0x0
138F  2BB0     GOTO 0x3B0
44:                    // Disk signature             //0x01B8
45:                    buffer[ 0x1b8-0x180] = 0xF5; buffer[ 0x1b9-0x180] = 0x8B; 
138D  0879     MOVF 0xF9, W
1390  3E38     ADDLW 0x38
1391  0086     MOVWF FSR1L
1392  3002     MOVLW 0x2
1393  0087     MOVWF FSR1H
1394  30F5     MOVLW 0xF5
1395  0081     MOVWF INDF1
1396  0879     MOVF 0xF9, W
1397  3E39     ADDLW 0x39
1398  0086     MOVWF FSR1L
1399  308B     MOVLW 0x8B
139A  0081     MOVWF INDF1
46:                    buffer[ 0x1ba-0x180] = 0x16; buffer[ 0x1bb-0x180] = 0xEA;                                                                 
139B  0879     MOVF 0xF9, W
139C  3E3A     ADDLW 0x3A
139D  0086     MOVWF FSR1L
139E  3016     MOVLW 0x16
139F  0081     MOVWF INDF1
13A0  0879     MOVF 0xF9, W
13A1  3E3B     ADDLW 0x3B
13A2  0086     MOVWF FSR1L
13A3  30EA     MOVLW 0xEA
13A4  0081     MOVWF INDF1
47:            
48:                // Table of Primary Partitions (16 bytes/entry x 4 entries)
49:                // Note: Multi-byte fields are in little endian format.
50:                // Partition Entry 1                                                                             //0x01BE
51:                    buffer[ 0x1be-0x180] = 0x00;                  // Status - 0x80 (bootable), 0x00 (not bootable), other (error)
13A5  0879     MOVF 0xF9, W
13A6  3E3E     ADDLW 0x3E
13A7  0086     MOVWF FSR1L
13A8  0181     CLRF INDF1
52:                    buffer[ 0x1bf-0x180] = 0x01;                  // Cylinder
13A9  0879     MOVF 0xF9, W
13AA  3E3F     ADDLW 0x3F
13AB  0086     MOVWF FSR1L
13AC  3002     MOVLW 0x2
13AD  0181     CLRF INDF1
13AE  0A81     INCF INDF1, F
53:                }
13AF  0008     RETURN
54:                else { // segment 7: 0x1c0 - 0x1ff 
55:                    buffer[ 0x1c0-0x1c0] = 0x01;                  // Head
13B0  0086     MOVWF FSR1L
13B1  3002     MOVLW 0x2
13B2  0087     MOVWF FSR1H
13B3  0181     CLRF INDF1
13B4  0A81     INCF INDF1, F
56:                    buffer[ 0x1c1-0x1c0] = 0x00;                  // Sector address of first sector in partition
13B5  0A79     INCF 0xF9, W
13B6  0086     MOVWF FSR1L
13B7  0181     CLRF INDF1
57:                    buffer[ 0x1c2-0x1c0] = 0x01;                  // Partition type - 0x01 = FAT12 up to 2MB -0xE = FAT16
13B8  0879     MOVF 0xF9, W
13B9  3E02     ADDLW 0x2
13BA  0086     MOVWF FSR1L
13BB  0181     CLRF INDF1
13BC  0A81     INCF INDF1, F
58:                    buffer[ 0x1c3-0x1c0] = 0x07;                  // Cylinder
13BD  0879     MOVF 0xF9, W
13BE  3E03     ADDLW 0x3
13BF  0086     MOVWF FSR1L
13C0  3007     MOVLW 0x7
13C1  0081     MOVWF INDF1
59:                    buffer[ 0x1c4-0x1c0] = 0xFF;                  // Head
13C2  0879     MOVF 0xF9, W
13C3  3E04     ADDLW 0x4
13C4  0086     MOVWF FSR1L
13C5  30FF     MOVLW 0xFF
13C6  0081     MOVWF INDF1
60:                    buffer[ 0x1c5-0x1c0] = 0xE6;                  // Sector address of last sector in partition
13C7  0879     MOVF 0xF9, W
13C8  3E05     ADDLW 0x5
13C9  0086     MOVWF FSR1L
13CA  30E6     MOVLW 0xE6
13CB  0081     MOVWF INDF1
61:                    buffer[ 0x1c6-0x1c0] = 0x01;                  // Logical Block Address (LBA) of first sector in partition
13CC  0879     MOVF 0xF9, W
13CD  3E06     ADDLW 0x6
13CE  0086     MOVWF FSR1L
13CF  0181     CLRF INDF1
13D0  0A81     INCF INDF1, F
62:                    // 00. 00. 00
63:                    buffer[ 0x1ca-0x1c0] = (uint8_t) DRV_FILEIO_INTERNAL_FLASH_PARTITION_SIZE;
13D1  0879     MOVF 0xF9, W
13D2  3E0A     ADDLW 0xA
13D3  0086     MOVWF FSR1L
13D4  3003     MOVLW 0x3
13D5  0081     MOVWF INDF1
64:                    buffer[ 0x1cb-0x1c0] = (uint8_t)(DRV_FILEIO_INTERNAL_FLASH_PARTITION_SIZE >>  8); 
13D6  0879     MOVF 0xF9, W
13D7  3E0B     ADDLW 0xB
13D8  0086     MOVWF FSR1L
13D9  0181     CLRF INDF1
13DA  0A81     INCF INDF1, F
65:                    buffer[ 0x1cc-0x1c0] = (uint8_t)(DRV_FILEIO_INTERNAL_FLASH_PARTITION_SIZE >> 16); 
13DB  0879     MOVF 0xF9, W
13DC  3E0C     ADDLW 0xC
13DD  0086     MOVWF FSR1L
13DE  0181     CLRF INDF1
66:                    buffer[ 0x1cd-0x1c0] = (uint8_t)(DRV_FILEIO_INTERNAL_FLASH_PARTITION_SIZE >> 24); // Length of partition in sectors 
13DF  0879     MOVF 0xF9, W
13E0  3E0D     ADDLW 0xD
13E1  0086     MOVWF FSR1L
13E2  0181     CLRF INDF1
67:                    // Note: (MBR sits at LBA = 0, and is not in the partition.)
68:                //Partition Entry 2
69:                // 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x01CE
70:                //Partition Entry 3
71:                // 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x01DE
72:                //Partition Entry 4
73:                // 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, //0x01EE
74:                //MBR signature         //0x01FE
75:                    buffer[ 0x1fe-0x1c0] = 0x55; 
13E3  0879     MOVF 0xF9, W
13E4  3E3E     ADDLW 0x3E
13E5  0086     MOVWF FSR1L
13E6  3055     MOVLW 0x55
13E7  0081     MOVWF INDF1
76:                    buffer[ 0x1ff-0x1c0] = 0xAA;
13E8  0879     MOVF 0xF9, W
13E9  2C75     GOTO 0x475
77:                }
78:            }
79:            //------------------------------------------------------------------------------
80:            // Partition BOOT sector at LBA = 1
81:            //------------------------------------------------------------------------------
82:            // Physical Sector - 1, Logical Sector - 0.  
83:            // This is the first sector in the partition, known as the VBR, "volume boot record" 
84:            const uint8_t VBR[] = {
85:                0xEB,                                // (legacy) Jump instruction
86:                0x3C,
87:                0x90,                          
88:                'M','S','D','O','S','5','.','0',   // OEM Name "MSDOS5.0"
89:                (FILEIO_CONFIG_MEDIA_SECTOR_SIZE & 0xFF),        // Bytes per sector 
90:                (FILEIO_CONFIG_MEDIA_SECTOR_SIZE>>8),            
91:                0x01,                              // Sectors per cluster
92:                0x01,  // Reserved sector count (1 for FAT12 or FAT16)
93:                0x00,			
94:                0x01,                              // number of FATs 
95:                DRV_FILEIO_CONFIG_INTERNAL_FLASH_MAX_NUM_FILES_IN_ROOT,
96:                0x00,		// Max number of root directory entries - 16 files allowed
97:                0x00, 0x00,  // total sectors (0x0000 means: use the 4 byte field at offset 0x20 instead)
98:                0xF8,			    //Media Descriptor
99:                DRV_FILEIO_INTERNAL_FLASH_NUM_FAT_SECTORS,
100:               0x00,                                            // Sectors per FAT
101:               0x3F, 
102:               0x00,                                            // Sectors per track
103:               0xFF, 
104:               0x00,                                            // Number of heads
105:               0x01,  0x00, 0x00, 0x00,         // Hidden sectors (previous partition)
106:               (uint8_t)  DRV_FILEIO_INTERNAL_FLASH_PARTITION_SIZE,
107:               (uint8_t)( DRV_FILEIO_INTERNAL_FLASH_PARTITION_SIZE >> 8),
108:               (uint8_t)( DRV_FILEIO_INTERNAL_FLASH_PARTITION_SIZE >> 16),
109:               (uint8_t)( DRV_FILEIO_INTERNAL_FLASH_PARTITION_SIZE >> 24),	//Total sectors (when uint16_t value at offset 20 is 0x0000)
110:           
111:               0x00,			// Physical drive number
112:               0x00,			// Reserved("current head")
113:               0x29,			// Signature
114:               0x32,          // ID (serial number)
115:               0x67, 
116:               0x94, 
117:               0xC4,
118:               'S','O','L','A','S',' ',' ',' ',' ',' ',' ',  // Volume Label (11 bytes)
119:               'F','A','T','1','2',' ',' ',' '     // FAT system ( 8 bytes)
120:           };
121:           
122:           void VolumeBootRecordGet( uint8_t * buffer, uint8_t seg) 
1416  00FA     MOVWF 0xFA
1417  246C     CALL 0x46C
123:           {  // fabricate an MBR structure in the RAM buffer
124:               memset( buffer, 0, MSD_OUT_EP_SIZE);              // clear buffer  
1418  3185     MOVLP 0x5
1419  2526     CALL 0x526
141A  3193     MOVLP 0x13
125:               if (seg == 0) { // segment from 000 to 0x03f
141B  0878     MOVF 0xF8, W
141C  1D03     BTFSS STATUS, 0x2
141D  2C30     GOTO 0x430
126:                   memcpy(buffer,VBR,sizeof(VBR));
141E  087A     MOVF 0xFA, W
141F  0086     MOVWF FSR1L
1420  3002     MOVLW 0x2
1421  0087     MOVWF FSR1H
1422  3000     MOVLW 0x0
1423  0084     MOVWF FSR0L
1424  3090     MOVLW 0x90
1425  0085     MOVWF FSR0H
1426  303E     MOVLW 0x3E
1427  00F9     MOVWF 0xF9
1428  0879     MOVF 0xF9, W
1429  1903     BTFSC STATUS, 0x2
142A  0008     RETURN
142B  0012     MOVIW FSR0++
142C  001E     MOVWI FSR1++
142D  0BF9     DECFSZ 0xF9, F
142E  2C2B     GOTO 0x42B
142F  0008     RETURN
127:                   return;
128:               }
129:               if ( seg < 7) return;  // segments 1-6 from 0x040 to 0x1c0 are empty
1430  3007     MOVLW 0x7
1431  0278     SUBWF 0xF8, W
1432  1C03     BTFSS STATUS, 0x0
1433  0008     RETURN
130:           //Operating system boot code
131:           // 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
132:           // ...
133:               else {
134:                   buffer[ 0x1fe-0x1c0] = 0x55; 
1434  087A     MOVF 0xFA, W
1435  3E3E     ADDLW 0x3E
1436  0086     MOVWF FSR1L
1437  3002     MOVLW 0x2
1438  0087     MOVWF FSR1H
1439  3055     MOVLW 0x55
143A  0081     MOVWF INDF1
135:                   buffer[ 0x1ff-0x1c0] = 0xAA;			// signature End of sector (0x55AA)
143B  087A     MOVF 0xFA, W
143C  2C75     GOTO 0x475
136:               }
137:           }
138:           
139:           //------------------------------------------------------------------------------
140:           // First FAT sector at LBA = 2
141:           // Note: This table consists of a series of 12-bit entries, and are fully packed 
142:           // (no pad bits).  This means every other byte is a "shared" byte, that is split
143:           // down the middle and is part of two adjacent 12-bit entries.  
144:           // The entries are in little endian format.
145:           
146:           void FATRecordInit( void)
147:           {
148:           }
149:           
150:           void FATRecordGet( uint8_t * buffer, uint8_t seg)
1360  00F9     MOVWF 0xF9
1361  246C     CALL 0x46C
151:           {
152:               memset( (void*)buffer, 0, MSD_IN_EP_SIZE);
1362  3185     MOVLP 0x5
1363  2526     CALL 0x526
1364  3193     MOVLP 0x13
153:               if (seg == 0) {
1365  0878     MOVF 0xF8, W
1366  1D03     BTFSS STATUS, 0x2
1367  0008     RETURN
154:                   buffer[ 0] = 0xF8;      // Copy of the media descriptor 0xFF8
1368  0879     MOVF 0xF9, W
1369  0086     MOVWF FSR1L
136A  3002     MOVLW 0x2
136B  0087     MOVWF FSR1H
136C  30F8     MOVLW 0xF8
136D  0081     MOVWF INDF1
155:                   buffer[ 1] = 0xFF;   
136E  0A79     INCF 0xF9, W
136F  0086     MOVWF FSR1L
1370  30FF     MOVLW 0xFF
1371  0081     MOVWF INDF1
156:                   buffer[ 2] = 0xFF;
1372  0879     MOVF 0xF9, W
1373  3E02     ADDLW 0x2
1374  0086     MOVWF FSR1L
1375  30FF     MOVLW 0xFF
1376  0081     MOVWF INDF1
157:                   buffer[ 3] = 0xFF;      // 2 - first/last cluster in short file chain
1377  0879     MOVF 0xF9, W
1378  3E03     ADDLW 0x3
1379  0086     MOVWF FSR1L
137A  30FF     MOVLW 0xFF
137B  0081     MOVWF INDF1
158:                   buffer[ 4] = 0x0F;      // readme.htm
137C  0879     MOVF 0xF9, W
137D  3E04     ADDLW 0x4
137E  0086     MOVWF FSR1L
137F  300F     MOVLW 0xF
1380  0081     MOVWF INDF1
159:               }
160:           }
1381  0008     RETURN
161:           
162:           void FATRecordSet( uint8_t * buffer, uint8_t seg)
163:           {   
164:           }
07C8  0008     RETURN
165:           
166:           //------------------------------------------------------------------------------
167:           // ROOT sector at LBA = 3
168:           
169:           const char readme[] = "Copy your downloaded files here to transfer them to solas";
170:           
171:           uint8_t readme_size( void) {
172:               return sizeof( readme);     // required by direct.c (external references return always size 0!?)
135F  343A     RETLW 0x3A
173:           }
174:           
175:           const uint8_t entry0[ ROOT_ENTRY_SIZE] = { 
176:               'S','O','L','A','S',' ',' ',' ',' ',' ',' ',  // Drive Name (11 characters, padded with spaces)
177:               0x08, //specify this entry as a volume label
178:               0x00, //Reserved
179:           
180:               0x00,           // Creation time, fine res 10 ms units (0-199)
181:               TIMEL(MAJOR, MINOR, 0),     // Creation time, hour/min/sec
182:               TIMEH(MAJOR, MINOR, 0),     // Creation time, hour/min/sec
183:               DATEL(YEAR, MONTH, DAY),    // Creation date, YMD 
184:               DATEH(YEAR, MONTH, DAY),    // Creation date, YMD
185:               
186:               DATEL(YEAR, MONTH, DAY),    // Last Access date, YMD
187:               DATEH(YEAR, MONTH, DAY),    // Last Access date, YMD
188:               0x00, 0x00,     // Extended Attributes
189:               
190:               TIMEL(MAJOR, MINOR, 0),     // Last Modified time h/m/s
191:               TIMEH(MAJOR, MINOR, 0),     // Last Modified time h/m/s
192:               DATEL(YEAR, MONTH, DAY),    // Last Modified date, YMD
193:               DATEH(YEAR, MONTH, DAY),    // Last Modified date, YMD
194:           
195:               0x00, 0x00,                 // First FAT cluster (none)
196:               0x00, 0x00, 0x00, 0x00,     // File Size (number of bytes)
197:            };
198:           
199:           
200:            const  uint8_t entry1[ ROOT_ENTRY_SIZE] = {
201:               'R','E','A','D','M','E',' ',' ',    // File name (exactly 8 characters)
202:               'T','X','T',                        // File extension (exactly 3 characters)
203:               0x20,           // specify this entry as a regular file
204:               0x00,           // Reserved
205:               0x00,           // Creation time, fine res 10 ms units (0-199)
206:               TIMEL(MAJOR, MINOR, 0),     // Creation time, hour/min/sec
207:               TIMEH(MAJOR, MINOR, 0),     // Creation time, hour/min/sec
208:               DATEL(YEAR, MONTH, DAY),    // Creation date, YMD 
209:               DATEH(YEAR, MONTH, DAY),    // Creation date, YMD
210:               
211:               DATEL(YEAR, MONTH, DAY),    // Last Access date, YMD
212:               DATEH(YEAR, MONTH, DAY),    // Last Access date, YMD
213:               0x00, 0x00,     // Extended Attributes
214:               
215:               TIMEL(MAJOR, MINOR, 0),     // Last Modified time h/m/s
216:               TIMEH(MAJOR, MINOR, 0),     // Last Modified time h/m/s
217:               DATEL(YEAR, MONTH, DAY),    // Last Modified date, YMD
218:               DATEH(YEAR, MONTH, DAY),    // Last Modified date, YMD
219:               
220:               0x02, 0x00,     // First FAT cluster (#2 is the first available)
221:               sizeof(readme), 0x00, 0x00, 0x00,         // README string size (<256)
222:           };
223:           
224:           void RootRecordInit( void)
225:           {
226:           }
227:           
228:           void RootRecordGet( uint8_t * buffer, uint8_t seg)
13EA  00FA     MOVWF 0xFA
13EB  246C     CALL 0x46C
229:           {
230:              memset( (void*)buffer, 0, MSD_IN_EP_SIZE);  // buffer is only 64 bytes large!
13EC  3185     MOVLP 0x5
13ED  2526     CALL 0x526
13EE  3193     MOVLP 0x13
231:              if (seg == 0) {
13EF  0878     MOVF 0xF8, W
13F0  1D03     BTFSS STATUS, 0x2
13F1  0008     RETURN
232:                   memcpy( (void*)&buffer[ 0], (const void*)entry0, ROOT_ENTRY_SIZE ); 
13F2  087A     MOVF 0xFA, W
13F3  0086     MOVWF FSR1L
13F4  3002     MOVLW 0x2
13F5  0087     MOVWF FSR1H
13F6  30BC     MOVLW 0xBC
13F7  0084     MOVWF FSR0L
13F8  3090     MOVLW 0x90
13F9  0085     MOVWF FSR0H
13FA  3020     MOVLW 0x20
13FB  00F9     MOVWF 0xF9
13FC  0879     MOVF 0xF9, W
13FD  1903     BTFSC STATUS, 0x2
13FE  2C03     GOTO 0x403
13FF  0012     MOVIW FSR0++
1400  001E     MOVWI FSR1++
1401  0BF9     DECFSZ 0xF9, F
1402  2BFF     GOTO 0x3FF
233:                   // add the README.HTM file
234:                   memcpy( (void*)&buffer[ ROOT_ENTRY_SIZE], (const void*)entry1, ROOT_ENTRY_SIZE );
1403  087A     MOVF 0xFA, W
1404  3E20     ADDLW 0x20
1405  0086     MOVWF FSR1L
1406  3002     MOVLW 0x2
1407  0087     MOVWF FSR1H
1408  309C     MOVLW 0x9C
1409  0084     MOVWF FSR0L
140A  3090     MOVLW 0x90
140B  0085     MOVWF FSR0H
140C  3020     MOVLW 0x20
140D  00F9     MOVWF 0xF9
140E  0879     MOVF 0xF9, W
140F  1903     BTFSC STATUS, 0x2
1410  0008     RETURN
1411  0012     MOVIW FSR0++
1412  001E     MOVWI FSR1++
1413  0BF9     DECFSZ 0xF9, F
1414  2C11     GOTO 0x411
1415  0008     RETURN
235:               }
236:           }
237:           
238:           void RootRecordSet( uint8_t *buffer, uint8_t seg)
239:           {
240:           }
07C9  0008     RETURN
---  /home/phil/Projects/XPRESS-Loader/MPLAB.X/direct.c  ------------------------------------------------
1:             /*******************************************************************************
2:             Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:             
4:             MSD Direct Programming (ICSP) Interface
5:             
6:             Licensed under the Apache License, Version 2.0 (the "License");
7:             you may not use this file except in compliance with the License.
8:             You may obtain a copy of the License at
9:             
10:                http://www.apache.org/licenses/LICENSE-2.0
11:            
12:            Unless required by applicable law or agreed to in writing, software
13:            distributed under the License is distributed on an "AS IS" BASIS,
14:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
15:            See the License for the specific language governing permissions and
16:            limitations under the License.
17:            
18:            *******************************************************************************/
19:            #include <xc.h>
20:            #include <string.h>
21:            #include <fileio_config.h>
22:            #include "fileio.h"
23:            #include "direct.h"
24:            #include "files.h"
25:            #include "memory.h"
26:            #include "pwm2.h"
27:            #include <stdint.h>
28:            #include <stdbool.h>
29:            
30:            /******************************************************************************
31:             * Global Variables
32:             *****************************************************************************/
33:            static FILEIO_MEDIA_INFORMATION mediaInformation;
34:            bool ParseHex(char c);
35:            
36:            /******************************************************************************
37:             * Function:        uint8_t MediaDetect(void* config)
38:             * PreCondition:    InitIO() function has been executed.
39:             * Input:           void
40:             * Output:          true   - Card detected
41:             *                  false   - No card detected
42:             *****************************************************************************/
43:            uint8_t DIRECT_MediaDetect(void* config)
44:            {
45:                return true;
0002  3401     RETLW 0x1
46:            }//end MediaDetect
47:            
48:            /******************************************************************************
49:             * Function:        uint16_t SectorSizeRead(void)
50:             * PreCondition:    MediaInitialize() is complete
51:             * Input:           void
52:             * Output:          uint16_t - size of the sectors for this physical media.
53:             *****************************************************************************/
54:            uint16_t DIRECT_SectorSizeRead(void* config)
55:            {
56:                return FILEIO_CONFIG_MEDIA_SECTOR_SIZE;
0845  3002     MOVLW 0x2
0846  01F0     CLRF 0xF0
0847  00F1     MOVWF 0xF1
57:            }
0848  0008     RETURN
58:            
59:            /******************************************************************************
60:             * Function:        uint32_t ReadCapacity(void)
61:             * PreCondition:    MediaInitialize() is complete
62:             * Input:           void
63:             * Output:          uint32_t - size of the "disk" - 1 (in terms of sector count).
64:             *                  Ex: In other words, this function returns the last valid 
65:             *                  LBA address that may be read/written to.
66:             *****************************************************************************/
67:            uint32_t DIRECT_CapacityRead(void* config)
68:            {
69:                    
70:                return ((uint32_t)DRV_FILEIO_INTERNAL_FLASH_TOTAL_DISK_SIZE - 1);
084F  3001     MOVLW 0x1
0850  01F3     CLRF 0xF3
0851  01F2     CLRF 0xF2
0852  00F1     MOVWF 0xF1
0853  3003     MOVLW 0x3
0854  00F0     MOVWF 0xF0
71:            }
0855  0008     RETURN
72:            
73:            /******************************************************************************
74:             * Function:        uint8_t InitIO(void)
75:             * PreCondition:    None
76:             * Input:           void
77:             * Output:          true   - Card initialized
78:             *                  false   - Card not initialized
79:             *****************************************************************************/
80:            uint8_t DIRECT_InitIO (void* config)
81:            {
82:                return  true;
83:            }
84:            
85:            /******************************************************************************
86:             * Function:        uint8_t MediaInitialize(void)
87:             * Input:           None
88:             * Output:          Returns a pointer to a MEDIA_INFORMATION structure
89:             * Overview:        MediaInitialize initializes the media card and supporting variables.
90:             *****************************************************************************/
91:            FILEIO_MEDIA_INFORMATION * DIRECT_MediaInitialize(void* config)
92:            {
93:                mediaInformation.validityFlags.bits.sectorSize = true;
0856  0024     MOVLB 0x4
0858  1454     BSF 0x254, 0x0
94:                mediaInformation.sectorSize = FILEIO_CONFIG_MEDIA_SECTOR_SIZE;
0857  3002     MOVLW 0x2
0859  01D5     CLRF 0x255
085A  00D6     MOVWF 0x256
95:                mediaInformation.errorCode = MEDIA_NO_ERROR;
085C  01D3     CLRF mediaInformation
96:                return &mediaInformation;
085B  3053     MOVLW 0x53
97:            } 
085D  0008     RETURN
98:            
99:            /******************************************************************************
100:            * Function:   uint8_t SectorRead(uint32_t sector_addr, uint8_t *buffer, seg)
101:            * Input:      sector_addr - Sector address, each sector contains 512-byte
102:            *             buffer      - Buffer where data will be stored
103:            *             seg         - 64-byte segment of a sector
104:            * Output:     Returns true if read successful, false otherwise
105:            *****************************************************************************/
106:           uint8_t DIRECT_SectorRead(void* config, uint32_t sector_addr, uint8_t* buffer, uint8_t seg)
107:           {
108:               // Read a sector worth of data, and copy it to the specified RAM "buffer"
109:               if      ( 0 == sector_addr)     MasterBootRecordGet( buffer, seg);
130B  0824     MOVF msd_cbw, W
130C  0423     IORWF 0x223, W
130D  0422     IORWF 0x222, W
130E  0421     IORWF 0x221, W
130F  1D03     BTFSS STATUS, 0x2
1310  2B16     GOTO 0x316
1311  0826     MOVF 0x226, W
1312  00F8     MOVWF 0x278
1313  0825     MOVF 0x225, W
1314  2382     CALL 0x382
1315  3401     RETLW 0x1
110:               else if ( 1 == sector_addr)     VolumeBootRecordGet( buffer, seg);
1316  0321     DECF 0x221, W
1317  0422     IORWF 0x222, W
1318  0423     IORWF 0x223, W
1319  0424     IORWF msd_cbw, W
131A  1D03     BTFSS STATUS, 0x2
131B  2B21     GOTO 0x321
131C  0826     MOVF 0x226, W
131D  00F8     MOVWF 0x278
131E  0825     MOVF 0x225, W
131F  2416     CALL 0x416
1320  3401     RETLW 0x1
111:               else if ( 2 == sector_addr)     {
1321  3002     MOVLW 0x2
1322  247A     CALL 0x47A
1323  3193     MOVLP 0x13
1324  1D03     BTFSS STATUS, 0x2
1325  2B2B     GOTO 0x32B
112:                   FATRecordGet( buffer, seg);
1326  0826     MOVF 0x226, W
1327  00F8     MOVWF 0x278
1328  0825     MOVF 0x225, W
1329  2360     CALL 0x360
113:               }
132A  3401     RETLW 0x1
114:               else if ( 3 == sector_addr)     {
132B  3003     MOVLW 0x3
132C  247A     CALL 0x47A
132D  3193     MOVLP 0x13
132E  1D03     BTFSS STATUS, 0x2
132F  2B35     GOTO 0x335
115:                   RootRecordGet( buffer, seg);
1330  0826     MOVF 0x226, W
1331  00F8     MOVWF 0x278
1332  0825     MOVF 0x225, W
1333  23EA     CALL 0x3EA
116:               }
1334  3401     RETLW 0x1
117:               else {
118:                   memset(buffer, '\0', MSD_IN_EP_SIZE); // empty buffer
1335  0825     MOVF 0x225, W
1336  246C     CALL 0x46C
1337  3185     MOVLP 0x5
1338  2526     CALL 0x526
1339  3193     MOVLP 0x13
119:                   if ( 4 == sector_addr) {        // Service README.HTM
133A  3004     MOVLW 0x4
133B  0021     MOVLB 0x1
133C  0621     XORWF sector_addr, W
133D  0422     IORWF chk, W
133E  0423     IORWF 0xA3, W
133F  0424     IORWF i, W
1340  1D03     BTFSS STATUS, 0x2
1341  3401     RETLW 0x1
120:                       if ( seg < ( (readme_size() + 63) % 64) ) 
1342  235F     CALL 0x35F
1343  3193     MOVLP 0x13
1344  3E3F     ADDLW 0x3F
1345  393F     ANDLW 0x3F
1346  0226     SUBWF p, W
1347  1803     BTFSC STATUS, 0x0
1348  3401     RETLW 0x1
121:                           strncpy( (void*)buffer, 
122:                                    (void*)&readme[seg*64], 
123:                                    64);  // at most 64 bytes at a time
1349  303E     MOVLW 0x3E
134A  00F0     MOVWF 0xF0
134B  3090     MOVLW 0x90
134C  00F1     MOVWF 0xF1
134D  0826     MOVF p, W
134E  00FB     MOVWF 0xFB
134F  3006     MOVLW 0x6
1350  01FC     CLRF 0xFC
1351  35FB     LSLF 0xFB, F
1352  0DFC     RLF 0xFC, F
1353  0B89     DECFSZ WREG, F
1354  2B51     GOTO 0x351
1355  087B     MOVF 0xFB, W
1356  07F0     ADDWF 0xF0, F
1357  087C     MOVF 0xFC, W
1358  3DF1     ADDWFC 0xF1, F
1359  3040     MOVLW 0x40
135A  00F2     MOVWF 0xF2
135B  01F3     CLRF 0xF3
135C  0825     MOVF address, W
135D  243D     CALL 0x43D
124:                   }
125:               }
126:           	return true;
135E  3401     RETLW 0x1
127:           }//end SectorRead
128:           
129:           /******************************************************************************
130:            * Function:        uint8_t SectorWrite(uint32_t sector_addr, uint8_t *buffer, uint8_t seg)
131:            * Input:           sector_addr - Sector address, each sector contains 512-byte
132:            *                  buffer      - Buffer where data will be read from
133:            *                  seg         - 64-byte segment of a 512 sector
134:            * Output:          Returns true if write successful, false otherwise
135:            *****************************************************************************/
136:           uint8_t DIRECT_SectorWrite(void* config, uint32_t sector_addr, uint8_t* buffer, uint8_t seg)
137:           {
138:               if (( sector_addr < 2) ||(sector_addr >= DRV_FILEIO_INTERNAL_FLASH_TOTAL_DISK_SIZE))
05F9  0844     MOVF 0xC4, W
05FA  1D03     BTFSS STATUS, 0x2
05FB  2E06     GOTO 0x606
05FC  0843     MOVF 0xC3, W
05FD  1D03     BTFSS STATUS, 0x2
05FE  2E06     GOTO 0x606
05FF  0842     MOVF 0xC2, W
0600  1D03     BTFSS STATUS, 0x2
0601  2E06     GOTO 0x606
0602  3002     MOVLW 0x2
0603  0241     SUBWF sector_addr, W
0604  1C03     BTFSS STATUS, 0x0
0605  3400     RETLW 0x0
0606  0844     MOVF 0xC4, W
0607  1D03     BTFSS STATUS, 0x2
0608  3400     RETLW 0x0
0609  0843     MOVF 0xC3, W
060A  1D03     BTFSS STATUS, 0x2
060B  3400     RETLW 0x0
060C  3004     MOVLW 0x4
060D  0241     SUBWF sector_addr, W
060E  3001     MOVLW 0x1
060F  3B42     SUBWFB 0xC2, W
0610  1803     BTFSC STATUS, 0x0
139:               {
140:                   return false;
0611  3400     RETLW 0x0
141:               }  
142:               if ( 2 == sector_addr) {            // updating the FAT table - RAM
0612  3002     MOVLW 0x2
0613  27DB     CALL 0x7DB
0614  3185     MOVLP 0x5
0615  1D03     BTFSS STATUS, 0x2
0616  2E21     GOTO 0x621
143:                   FATRecordSet( buffer, seg);     // update the RAM (fabricated) image 
0617  0846     MOVF seg, W
0618  00F0     MOVWF 0xF0
0619  0845     MOVF buffer, W
061A  27C8     CALL 0x7C8
144:                   return true;
0620  3401     RETLW 0x1
145:               }
146:               if ( 3 == sector_addr) {            // update of the root directory
061B  3401     RETLW 0x1
0621  3003     MOVLW 0x3
0622  27DB     CALL 0x7DB
0623  3185     MOVLP 0x5
0624  1903     BTFSC STATUS, 0x2
0625  2E1C     GOTO 0x61C
147:                   RootRecordSet( buffer, seg);
061C  0846     MOVF seg, W
061D  00F0     MOVWF 0xF0
061E  0845     MOVF buffer, W
061F  27C9     CALL 0x7C9
148:                   return true;
149:               }
150:           
151:               // all remaining data sectors are parsed and programmed directly into the device
152:               uint16_t i=0;
0626  01C9     CLRF i
0627  01CA     CLRF 0xCA
153:               while( (i++ < 64) && ParseHex(*buffer++));
0628  0021     MOVLB 0x1
0629  084A     MOVF 0xCA, W
062A  00C8     MOVWF 0xC8
062B  0849     MOVF i, W
062C  00C7     MOVWF 0xC7
062D  0AC9     INCF i, F
062E  1903     BTFSC STATUS, 0x2
062F  0ACA     INCF 0xCA, F
0630  3000     MOVLW 0x0
0631  0248     SUBWF 0xC8, W
0632  3040     MOVLW 0x40
0633  1903     BTFSC STATUS, 0x2
0634  0247     SUBWF 0xC7, W
0635  1803     BTFSC STATUS, 0x0
0636  3401     RETLW 0x1
0637  0845     MOVF buffer, W
0638  0086     MOVWF FSR1L
0639  3002     MOVLW 0x2
063A  0087     MOVWF FSR1H
063B  0AC5     INCF buffer, F
063C  0801     MOVF INDF1, W
063D  2643     CALL 0x643
063E  3185     MOVLP 0x5
063F  3A00     XORLW 0x0
0640  1903     BTFSC STATUS, 0x2
0641  3401     RETLW 0x1
0642  2E28     GOTO 0x628
154:               
155:               return true;
156:           } // SectorWrite
157:           
158:           /******************************************************************************
159:            * Function:        uint8_t WriteProtectState(void)
160:            * Output:          uint8_t    - Returns always false (never protected)
161:            *****************************************************************************/
162:           uint8_t DIRECT_WriteProtectStateGet(void* config)
163:           {
164:               return false;
0003  3400     RETLW 0x0
165:           }
166:           
167:           /*******************************************************************************
168:            Direct Hex File Parsing and Programming State Machine
169:            
170:            This is a simple state machine that parses an input stream to detect and decode
171:            the INTEL Hex file format produced by the MPLAB XC8 compiler
172:            Bytes are assembled in Words 
173:            Words are assembled in Rows (currently supporting fixed size of 32-words)
174:            Rows are aligned (normalized) and written directly to the target using LVP ICSP
175:            Special treatment is reserved for words written to 'configuration' addresses 
176:            ******************************************************************************/
177:           #define ROW_SIZE     32      // for all pic16f188xx
178:           #define CFG_ADDRESS 0x8000   // for all pic16f188xx
179:           #define CFG_NUM      5       // number of config words for PIC16F188xx
180:           
181:           // internal state
182:           uint16_t row[ ROW_SIZE];    // buffer containing row being formed
183:           uint32_t row_address;       // destination address of current row 
184:           bool     lvp;               // flag: low voltage programming in progress
185:           
186:           /** 
187:            * State machine initialization
188:            */
189:           void DIRECT_Initialize( void) {
190:               memset((void*)row, 0xff, sizeof(row));    // fill buffer with blanks
0072  3192     MOVLP 0x12
0073  22DF     CALL 0x2DF
0074  3180     MOVLP 0x0
0075  2526     CALL 0x526
191:               row_address = 0x8000;
0076  0022     MOVLB 0x2
0077  3080     MOVLW 0x80
0078  01B7     CLRF 0x137
0079  01B6     CLRF 0x136
007A  00B5     MOVWF 0x135
007B  3000     MOVLW 0x0
007C  01B4     CLRF row_address
192:               lvp = false;
193:           }
007D  0008     RETURN
194:           
195:           /**
196:            * Test if Low Voltage - In Circuit Serial Programming in progress
197:            * @return  true if lvp sequence in progress
198:            */
199:           bool DIRECT_ProgrammingInProgress( void) {
200:               return lvp;
201:           }
202:           
203:           bool isDigit( char * c){
07A7  00F0     MOVWF 0x170
204:               if (*c < '0') return false;
07A8  0086     MOVWF FSR1L
07A9  3030     MOVLW 0x30
07AA  0187     CLRF FSR1H
07AB  0201     SUBWF INDF1, W
07AC  1C03     BTFSS STATUS, 0x0
07AD  3400     RETLW 0x0
205:               *c -= '0'; if (*c > 9) *c-=7;
07AE  0870     MOVF 0x170, W
07AF  0086     MOVWF FSR1L
07B0  3030     MOVLW 0x30
07B1  0281     SUBWF INDF1, F
07B2  0870     MOVF 0x170, W
07B3  0086     MOVWF FSR1L
07B4  300A     MOVLW 0xA
07B5  0201     SUBWF INDF1, W
07B6  0870     MOVF 0x170, W
07B7  0086     MOVWF FSR1L
07B8  1C03     BTFSS STATUS, 0x0
07B9  2FBE     GOTO 0x7BE
07BA  3007     MOVLW 0x7
07BB  0281     SUBWF INDF1, F
206:               if (*c > 0xf)  return false;
07BC  0870     MOVF 0x170, W
07BD  0086     MOVWF FSR1L
07BE  3010     MOVLW 0x10
07BF  0187     CLRF FSR1H
07C0  0201     SUBWF INDF1, W
07C1  1C03     BTFSS STATUS, 0x0
07C3  3400     RETLW 0x0
207:               return true;
07C2  3401     RETLW 0x1
07C3  3400     RETLW 0x0
208:           }
209:               
210:           void lvpWrite( void){
211:               // check for first entry in lvp 
212:               if (row_address >= CFG_ADDRESS) {    // use the special cfg word sequence
125E  0022     MOVLB 0x2
125F  0837     MOVF 0x137, W
1260  1D03     BTFSS STATUS, 0x2
1261  0008     RETURN
1262  0836     MOVF 0x136, W
1263  1D03     BTFSS STATUS, 0x2
1264  0008     RETURN
1265  3080     MOVLW 0x80
1266  0235     SUBWF 0x135, W
1267  1803     BTFSC STATUS, 0x0
1268  0008     RETURN
213:                   //do nothing...
214:                   //LVP_cfgWrite( &row[7], CFG_NUM);
215:               }
216:               else { // normal row programming sequence
217:                   if (row_address >=0x1600) {
1269  0837     MOVF 0x137, W
126A  1D03     BTFSS STATUS, 0x2
126B  2A73     GOTO 0x273
126C  0836     MOVF 0x136, W
126D  1D03     BTFSS STATUS, 0x2
126E  2A73     GOTO 0x273
126F  3016     MOVLW 0x16
1270  0235     SUBWF 0x135, W
1271  1C03     BTFSS STATUS, 0x0
1272  0008     RETURN
218:                       FLASH_WriteBlock(row_address, row);
1273  0835     MOVF 0x135, W
1274  00F4     MOVWF 0x174
1275  0834     MOVF row_address, W
1276  00F3     MOVWF 0x173
1277  3020     MOVLW 0x20
1278  00F5     MOVWF 0x175
1279  2A7A     GOTO 0x27A
219:                   }
220:                   //LVP_addressLoad( row_address);
221:                   //LVP_rowWrite( row, ROW_SIZE);
222:               }
223:           }
224:           
225:           void writeRow( void) {
226:               // latch and program a row, skip if blank
227:               uint8_t i;
228:               uint16_t chk = 0xffff;
122E  30FF     MOVLW 0xFF
122F  00A2     MOVWF 0x122
1230  00A3     MOVWF 0x123
229:               for( i=0; i< ROW_SIZE; i++) chk &= row[i];  // blank check
1231  01A4     CLRF 0x124
1232  3524     LSLF 0x124, W
1233  3E20     ADDLW 0x20
1234  0086     MOVWF FSR1L
1235  3003     MOVLW 0x3
1236  0087     MOVWF FSR1H
1237  3F40     MOVIW 0[FSR1]
1238  00A0     MOVWF outPipes
1239  3F41     MOVIW 1[FSR1]
123A  00A1     MOVWF 0x121
123B  0820     MOVF outPipes, W
123C  05A2     ANDWF 0x122, F
123D  0821     MOVF 0x121, W
123E  05A3     ANDWF 0x123, F
123F  3020     MOVLW 0x20
1240  0AA4     INCF 0x124, F
1241  0224     SUBWF 0x124, W
1242  1C03     BTFSS STATUS, 0x0
1243  2A32     GOTO 0x232
230:               if (chk != 0xffff) { 
1244  0F22     INCFSZ 0x122, W
1245  2A49     GOTO 0x249
1246  0A23     INCF 0x123, W
1247  1903     BTFSC STATUS, 0x2
1248  2A4F     GOTO 0x24F
231:                   lvpWrite();
1249  225E     CALL 0x25E
124A  3191     MOVLP 0x11
124B  22DF     CALL 0x2DF
232:                   memset((void*)row, 0xff, sizeof(row));    // fill buffer with blanks
124C  3185     MOVLP 0x5
124D  2526     CALL 0x526
124E  3191     MOVLP 0x11
233:               }
234:               PWM2_Off();
124F  3181     MOVLP 0x1
1250  2154     CALL 0x154
1251  3191     MOVLP 0x11
235:               LATCbits.LATC3 = !LATCbits.LATC3;
1252  1003     BCF STATUS, 0x0
1253  0022     MOVLB 0x2
1254  1D8E     BTFSS LATC, 0x3
1255  1403     BSF STATUS, 0x0
1256  1C03     BTFSS STATUS, 0x0
1257  2A5B     GOTO 0x25B
1258  0022     MOVLB 0x2
1259  158E     BSF LATC, 0x3
125A  0008     RETURN
125B  0022     MOVLB 0x2
125C  118E     BCF LATC, 0x3
236:           }
125D  0008     RETURN
237:           
238:           /**
239:            * Align and pack words in rows, ready for lvp programming
240:            * @param address       starting address 
241:            * @param data          buffer
242:            * @param data_count    number of bytes 
243:            */
244:           void packRow( uint32_t address, uint8_t *data, uint8_t data_count) {
245:               // copy only the bytes from the current data packet up to the boundary of a row 
246:               uint8_t  index = (address & 0x3e)>>1; 
11A3  3625     LSRF 0x125, W
11A4  00B7     MOVWF 0x137
11A5  301F     MOVLW 0x1F
11A6  05B7     ANDWF 0x137, F
247:               uint32_t new_row = (address & 0xfffc0)>>1;
11A7  0825     MOVF 0x125, W
11A8  00AB     MOVWF 0x12B
11A9  0826     MOVF 0x126, W
11AA  00AC     MOVWF LBA
11AB  0827     MOVF inPipes, W
11AC  00AD     MOVWF 0x12D
11AD  0828     MOVF 0x128, W
11AE  00AE     MOVWF 0x12E
11AF  36AE     LSRF 0x12E, F
11B0  0CAD     RRF 0x12D, F
11B1  0CAC     RRF LBA, F
11B2  0CAB     RRF 0x12B, F
11B3  082E     MOVF 0x12E, W
11B4  00B6     MOVWF 0x136
11B5  082D     MOVF 0x12D, W
11B6  00B5     MOVWF 0x135
11B7  082C     MOVF LBA, W
11B8  00B4     MOVWF row_address
11B9  082B     MOVF 0x12B, W
11BA  00B3     MOVWF 0x133
11BB  30E0     MOVLW 0xE0
11BC  05B3     ANDWF 0x133, F
11BD  30FF     MOVLW 0xFF
11BE  05B4     ANDWF row_address, F
11BF  3007     MOVLW 0x7
11C0  05B5     ANDWF 0x135, F
11C1  01B6     CLRF 0x136
248:               if (new_row != row_address) {
11C2  0022     MOVLB 0x2
11C3  0837     MOVF 0x137, W
11C4  0021     MOVLB 0x1
11C5  0636     XORWF 0xB6, W
11C6  1D03     BTFSS STATUS, 0x2
11C7  29D8     GOTO 0x1D8
11C8  0022     MOVLB 0x2
11C9  0836     MOVF 0x136, W
11CA  0021     MOVLB 0x1
11CB  0635     XORWF 0xB5, W
11CC  1D03     BTFSS STATUS, 0x2
11CD  29D8     GOTO 0x1D8
11CE  0022     MOVLB 0x2
11CF  0835     MOVF 0x135, W
11D0  0021     MOVLB 0x1
11D1  0634     XORWF 0xB4, W
11D2  1D03     BTFSS STATUS, 0x2
11D3  29D8     GOTO 0x1D8
11D4  0022     MOVLB 0x2
11D5  0834     MOVF row_address, W
11D6  0021     MOVLB 0x1
11D7  0633     XORWF new_row, W
11D8  1903     BTFSC STATUS, 0x2
11D9  29EC     GOTO 0x1EC
249:                   writeRow();
11DA  222E     CALL 0x22E
11DB  3191     MOVLP 0x11
250:                   row_address = new_row;
11DC  0021     MOVLB 0x1
11DD  0836     MOVF 0xB6, W
11DE  0022     MOVLB 0x2
11DF  00B7     MOVWF 0x137
11E0  0021     MOVLB 0x1
11E1  0835     MOVF 0xB5, W
11E2  0022     MOVLB 0x2
11E3  00B6     MOVWF 0x136
11E4  0021     MOVLB 0x1
11E5  0834     MOVF 0xB4, W
11E6  0022     MOVLB 0x2
11E7  00B5     MOVWF 0x135
11E8  0021     MOVLB 0x1
11E9  0833     MOVF new_row, W
11EA  0022     MOVLB 0x2
11EB  00B4     MOVWF row_address
251:               }
252:               // ensure data is always even (rounding up)
253:               data_count = (data_count+1) & 0xfe;
11EC  0021     MOVLB 0x1
11ED  0AAA     INCF data_count, F
11EE  102A     BCF data_count, 0x0
254:               // copy data up to the row boundaries
255:               while ((data_count > 0) && (index < ROW_SIZE)){
11EF  2A04     GOTO 0x204
11F0  3020     MOVLW 0x20
11F1  0237     SUBWF index, W
11F2  1803     BTFSC STATUS, 0x0
11F3  2A07     GOTO 0x207
1204  082A     MOVF data_count, W
1205  1D03     BTFSS STATUS, 0x2
1206  29F0     GOTO 0x1F0
256:                   uint16_t word = *data++;
11F4  2300     CALL 0x300
11F5  3191     MOVLP 0x11
11F6  00AF     MOVWF word
11F7  01B0     CLRF 0xB0
11F8  22EA     CALL 0x2EA
11F9  3191     MOVLP 0x11
257:                   word += ((uint16_t)(*data++)<<8);
11FA  07AF     ADDWF word, F
11FB  082C     MOVF 0xAC, W
11FC  3DB0     ADDWFC 0xB0, F
11FD  22F4     CALL 0x2F4
11FE  3191     MOVLP 0x11
258:                   row[index++] = word;
11FF  082F     MOVF word, W
1200  3FC0     MOVWI 0[FSR1]
1201  0830     MOVF 0xB0, W
1202  2306     CALL 0x306
1203  3191     MOVLP 0x11
259:                   data_count -= 2;
260:               }
261:               // if a complete row was filled, proceed to programming
262:               if (index == ROW_SIZE) { 
1207  3020     MOVLW 0x20
1208  0637     XORWF index, W
1209  1D03     BTFSS STATUS, 0x2
120A  0008     RETURN
263:                   writeRow();
120B  222E     CALL 0x22E
120C  3191     MOVLP 0x11
264:                   // next consider the split row scenario
265:                   if (data_count > 0) {   // leftover must spill into next row
120D  0021     MOVLB 0x1
120E  082A     MOVF data_count, W
120F  1903     BTFSC STATUS, 0x2
1210  0008     RETURN
266:                       row_address += ROW_SIZE;
1211  3020     MOVLW 0x20
1212  0022     MOVLB 0x2
1213  07B4     ADDWF row_address, F
1214  3000     MOVLW 0x0
1215  3DB5     ADDWFC 0x135, F
1216  3DB6     ADDWFC 0x136, F
1217  3DB7     ADDWFC 0x137, F
267:                       index = 0;
1218  0021     MOVLB 0x1
1219  01B7     CLRF index
268:                       while (data_count > 0){
121A  082A     MOVF data_count, W
121B  1903     BTFSC STATUS, 0x2
121C  0008     RETURN
121D  2300     CALL 0x300
121E  3191     MOVLP 0x11
122D  2A1A     GOTO 0x21A
269:                           uint16_t word = *data++;
121F  00B1     MOVWF word
1220  01B2     CLRF 0xB2
1221  22EA     CALL 0x2EA
1222  3191     MOVLP 0x11
270:                           word += ((uint16_t)(*data++)<<8);
1223  07B1     ADDWF word, F
1224  082C     MOVF 0xAC, W
1225  3DB2     ADDWFC 0xB2, F
1226  22F4     CALL 0x2F4
1227  3191     MOVLP 0x11
271:                           row[index++] = word;
1228  0831     MOVF word, W
1229  3FC0     MOVWI 0[FSR1]
122A  0832     MOVF 0xB2, W
122B  2306     CALL 0x306
122C  3191     MOVLP 0x11
122D  2A1A     GOTO 0x21A
272:                           data_count -= 2;
273:                       }
274:                   }
275:               }
276:           }
277:           
278:           void programLastRow( void) {
279:               writeRow();
07C4  3192     MOVLP 0x12
07C5  222E     CALL 0x22E
280:               //LVP_exit();
281:               lvp = false;    
282:               LATCbits.LATC3 = 0;
07C6  118E     BCF TRISC, 0x3
283:           }
07C7  0008     RETURN
284:           
285:           // the actual state machine - Hex Machina
286:           enum hexstate { SOL, BYTE_COUNT, ADDRESS, RECORD_TYPE, DATA, CHKSUM};
287:           
288:           /**
289:            * Parser, main state machine decoding engine
290:            * 
291:            * @param c     input character 
292:            * @return      true = success, false = decoding failure/invalid file contents
293:            */
294:           bool ParseHex(char c)
0643  00FD     MOVWF 0xFD
295:           {
296:               static enum hexstate state = SOL;
297:               static uint8_t  bc;
298:               static uint8_t  data_count;
299:               static uint32_t address;
300:               static uint32_t ext_address = 0;
301:               static uint8_t  checksum;
302:               static uint8_t  record_type;
303:               static uint8_t  data_byte, data_index, data[16];
304:           
305:               switch( state){
0644  2F9B     GOTO 0x79B
079B  0022     MOVLB 0x2
079C  085D     MOVF state, W
079D  0084     MOVWF FSR0L
079E  3006     MOVLW 0x6
079F  0204     SUBWF FSR0L, W
07A0  1803     BTFSC STATUS, 0x0
07A1  3401     RETLW 0x1
07A2  3188     MOVLP 0x8
07A3  3504     LSLF FSR0L, W
07A4  3E00     ADDLW 0x0
07A5  0082     MOVWF PCL
0800  3186     MOVLP 0x6
306:                   case SOL:
307:                       if (c == '\r') break;
0645  300D     MOVLW 0xD
0646  067D     XORWF 0x17D, W
0647  1903     BTFSC STATUS, 0x2
0648  3401     RETLW 0x1
308:                       if (c == '\n') break;
0649  300A     MOVLW 0xA
064A  067D     XORWF 0x17D, W
064B  1903     BTFSC STATUS, 0x2
064C  3401     RETLW 0x1
309:                       if (c != ':') return false; 
064D  303A     MOVLW 0x3A
064E  067D     XORWF 0x17D, W
064F  1D03     BTFSS STATUS, 0x2
0650  3400     RETLW 0x0
310:                       state = BYTE_COUNT;
0651  01DD     CLRF state
0652  0ADD     INCF state, F
311:                       bc = 0;
0653  0021     MOVLB 0x1
0654  01EC     CLRF bc
312:                       address = 0;
0655  0022     MOVLB 0x2
0656  01B0     CLRF address
0657  01B1     CLRF 0x131
0658  01B2     CLRF 0x132
0659  01B3     CLRF 0x133
313:                       checksum = 0;
065A  01DC     CLRF checksum
314:                       break;
065B  3401     RETLW 0x1
315:                   case BYTE_COUNT:
316:                       if ( isDigit( &c) == false) { state = SOL; return false; }
065C  307D     MOVLW 0x7D
065D  27A7     CALL 0x7A7
065E  3185     MOVLP 0x5
065F  3A00     XORLW 0x0
0660  1D03     BTFSS STATUS, 0x2
0661  2E65     GOTO 0x665
0662  0022     MOVLB 0x2
0663  01DD     CLRF state
0664  3400     RETLW 0x0
317:                       bc++;
0665  0021     MOVLB 0x1
0666  0AEC     INCF bc, F
318:                       if (bc == 1) 
0667  0B6C     DECFSZ bc, W
0668  2E6B     GOTO 0x66B
319:                           data_count = c;
0669  087D     MOVF 0xFD, W
066A  00EB     MOVWF data_count
320:                       if (bc == 2 )  {  
066B  3002     MOVLW 0x2
066C  066C     XORWF bc, W
066D  1D03     BTFSS STATUS, 0x2
066E  3401     RETLW 0x1
321:                           data_count = (data_count << 4) + c;
066F  0E6B     SWAPF data_count, W
0670  39F0     ANDLW 0xF0
0671  077D     ADDWF 0xFD, W
0672  00EB     MOVWF data_count
322:                           checksum += data_count;
0673  0022     MOVLB 0x2
0674  07DC     ADDWF checksum, F
323:                           bc = 0; 
0675  0021     MOVLB 0x1
0677  01EC     CLRF bc
324:                           if (data_count > 16) { state = SOL; return false; }
0676  3011     MOVLW 0x11
0678  026B     SUBWF data_count, W
0679  1803     BTFSC STATUS, 0x0
067A  2E62     GOTO 0x662
325:                           state = ADDRESS;
067B  3002     MOVLW 0x2
067C  2EF7     GOTO 0x6F7
326:                       }
327:                       break;            
328:                   case ADDRESS:
329:                       if ( isDigit( &c) == false) { state = SOL; return false;}
067D  307D     MOVLW 0x7D
067E  27A7     CALL 0x7A7
067F  3185     MOVLP 0x5
0680  3A00     XORLW 0x0
0681  1903     BTFSC STATUS, 0x2
0682  2E62     GOTO 0x662
330:                       bc++;
0683  0021     MOVLB 0x1
0684  0AEC     INCF bc, F
331:                       if (bc == 1) 
0685  0B6C     DECFSZ bc, W
0686  2E8E     GOTO 0x68E
332:                           address = c;
0687  087D     MOVF 0xFD, W
0688  0022     MOVLB 0x2
0689  00B0     MOVWF address
068A  01B1     CLRF 0x131
068B  01B2     CLRF 0x132
068C  01B3     CLRF 0x133
068D  3401     RETLW 0x1
333:                       else  {  
334:                           address = (address << 4) + (uint32_t)c;
068E  087D     MOVF 0x17D, W
068F  00B8     MOVWF pBDTEntryIn
0690  01B9     CLRF 0x139
0691  01BA     CLRF 0x13A
0692  01BB     CLRF 0x13B
0693  0022     MOVLB 0x2
0694  0830     MOVF address, W
0695  0021     MOVLB 0x1
0696  00BC     MOVWF 0xBC
0697  0022     MOVLB 0x2
0698  0831     MOVF 0x131, W
0699  0021     MOVLB 0x1
069A  00BD     MOVWF 0xBD
069B  0022     MOVLB 0x2
069C  0832     MOVF 0x132, W
069D  0021     MOVLB 0x1
069E  00BE     MOVWF 0xBE
069F  0022     MOVLB 0x2
06A0  0833     MOVF 0x133, W
06A1  0021     MOVLB 0x1
06A2  00BF     MOVWF 0xBF
06A3  3004     MOVLW 0x4
06A4  35BC     LSLF 0xBC, F
06A5  0DBD     RLF 0xBD, F
06A6  0DBE     RLF 0xBE, F
06A7  0DBF     RLF 0xBF, F
06A8  0B89     DECFSZ WREG, F
06A9  2EA4     GOTO 0x6A4
06AA  27CA     CALL 0x7CA
06AB  3185     MOVLP 0x5
06AC  0022     MOVLB 0x2
06AD  00B3     MOVWF 0x133
06AE  0021     MOVLB 0x1
06AF  083A     MOVF 0xBA, W
06B0  0022     MOVLB 0x2
06B1  00B2     MOVWF 0x132
06B2  0021     MOVLB 0x1
06B3  0839     MOVF 0xB9, W
06B4  0022     MOVLB 0x2
06B5  00B1     MOVWF 0x131
06B6  0021     MOVLB 0x1
06B7  0838     MOVF 0xB8, W
06B8  0022     MOVLB 0x2
06B9  00B0     MOVWF address
335:                           if (bc == 4) {
06BA  3004     MOVLW 0x4
06BB  0021     MOVLB 0x1
06BC  066C     XORWF bc, W
06BD  1D03     BTFSS STATUS, 0x2
06BE  3401     RETLW 0x1
336:                               checksum += (address>>8) + address;
06BF  0022     MOVLB 0x2
06C0  0831     MOVF 0x131, W
06C1  0730     ADDWF address, W
06C2  07DC     ADDWF checksum, F
337:                               bc = 0; 
06C3  0021     MOVLB 0x1
06C5  01EC     CLRF bc
338:                               state = RECORD_TYPE;
06C4  3003     MOVLW 0x3
06C6  2EF7     GOTO 0x6F7
339:                           }
340:                       }
341:                       break;                        
342:                   case RECORD_TYPE:
343:                       if ( isDigit( &c) == false) { state = SOL; return false;}
06C7  307D     MOVLW 0x7D
06C8  27A7     CALL 0x7A7
06C9  3185     MOVLP 0x5
06CA  3A00     XORLW 0x0
06CB  1903     BTFSC STATUS, 0x2
06CC  2E62     GOTO 0x662
344:                       bc++;
06CD  0021     MOVLB 0x1
06CE  0AEC     INCF bc, F
345:                       if (bc == 1) 
06CF  0B6C     DECFSZ bc, W
06D0  2ED4     GOTO 0x6D4
346:                           if (c != 0) { state = SOL; return false; }
06D1  087D     MOVF 0xFD, W
06D2  1D03     BTFSS STATUS, 0x2
06D3  2E62     GOTO 0x662
347:                       if (bc == 2)  {  
06D4  3002     MOVLW 0x2
06D5  066C     XORWF bc, W
06D6  1D03     BTFSS STATUS, 0x2
06D7  3401     RETLW 0x1
348:                           record_type = c;
06D8  087D     MOVF 0xFD, W
06D9  00EA     MOVWF record_type
349:                           checksum += c;
06DA  087D     MOVF 0xFD, W
06DB  0022     MOVLB 0x2
06DC  07DC     ADDWF checksum, F
350:                           bc = 0; 
06DD  0021     MOVLB 0x1
06DF  01EC     CLRF bc
351:                           state = DATA;  // default
06DE  3004     MOVLW 0x4
06E0  0022     MOVLB 0x2
06E1  00DD     MOVWF state
352:                           data_index = 0;
06E3  01DB     CLRF data_index
353:                           memset(data, 0xff, sizeof(data));
06E2  3043     MOVLW 0x43
06E4  00F0     MOVWF 0x170
06E5  3002     MOVLW 0x2
06E6  00F1     MOVWF 0x171
06E7  30FF     MOVLW 0xFF
06E8  00F2     MOVWF 0x172
06E9  3010     MOVLW 0x10
06EA  01F3     CLRF 0x173
06EB  00F4     MOVWF 0x174
06EC  01F5     CLRF 0x175
06ED  3185     MOVLP 0x5
06EE  2526     CALL 0x526
06EF  3185     MOVLP 0x5
354:                           if (record_type == 0) break; // data record
06F0  0021     MOVLB 0x1
06F1  086A     MOVF record_type, W
06F2  1903     BTFSC STATUS, 0x2
06F3  3401     RETLW 0x1
355:                           if (record_type == 1) { state = CHKSUM; break; }  // EOF record
06F4  0B6A     DECFSZ record_type, W
06F5  2EFA     GOTO 0x6FA
06F6  3005     MOVLW 0x5
06F7  0022     MOVLB 0x2
06F8  00DD     MOVWF state
06F9  3401     RETLW 0x1
356:                           if (record_type == 4) break; // extended address record
06FA  3004     MOVLW 0x4
06FB  066A     XORWF 0x16A, W
06FC  1903     BTFSC STATUS, 0x2
06FD  3401     RETLW 0x1
06FE  2E62     GOTO 0x662
357:                           state = SOL; 
358:                           return false;
359:                       }
360:                       break;            
361:                   case DATA:
362:                       if ( isDigit( &c) == false) { state = SOL; return false;}
06FF  307D     MOVLW 0x7D
0700  27A7     CALL 0x7A7
0701  3185     MOVLP 0x5
0702  3A00     XORLW 0x0
0703  1903     BTFSC STATUS, 0x2
0704  2E62     GOTO 0x662
363:                       bc++;
0705  0021     MOVLB 0x1
0706  0AEC     INCF bc, F
364:                       if (bc == 1) 
0707  0B6C     DECFSZ bc, W
0708  2F0E     GOTO 0x70E
365:                           data[data_index] = (c<<4);
0709  27D4     CALL 0x7D4
070A  3185     MOVLP 0x5
070B  0E7D     SWAPF 0xFD, W
070C  39F0     ANDLW 0xF0
070D  0081     MOVWF INDF1
366:                       if (bc == 2)  {  
070E  3002     MOVLW 0x2
070F  0021     MOVLB 0x1
0710  066C     XORWF bc, W
0711  1D03     BTFSS STATUS, 0x2
0712  3401     RETLW 0x1
367:                           bc = 0;
0713  01EC     CLRF bc
0714  27D4     CALL 0x7D4
0715  3185     MOVLP 0x5
368:                           data[data_index] += c;
0716  087D     MOVF 0xFD, W
0717  0781     ADDWF INDF1, F
369:                           checksum +=  data[data_index];
0718  085B     MOVF 0xDB, W
0719  3E43     ADDLW 0x43
071A  0086     MOVWF FSR1L
071B  0801     MOVF INDF1, W
071C  07DC     ADDWF i, F
370:                           data_index++;
071D  0ADB     INCF 0xDB, F
371:                           if (data_index == data_count) { 
071E  085B     MOVF 0xDB, W
071F  0021     MOVLB 0x1
0720  066B     XORWF data_count, W
0721  1D03     BTFSS STATUS, 0x2
0722  3401     RETLW 0x1
0723  2EF6     GOTO 0x6F6
372:                               state = CHKSUM; 
373:                           }
374:                       }
375:                       break;            
376:                   case CHKSUM:
377:                       if ( isDigit( &c) == false) { state = SOL; return false;}
0724  307D     MOVLW 0x7D
0725  27A7     CALL 0x7A7
0726  3185     MOVLP 0x5
0727  3A00     XORLW 0x0
0728  1903     BTFSC STATUS, 0x2
0729  2E62     GOTO 0x662
378:                       bc++;
072A  0021     MOVLB 0x1
072B  0AEC     INCF bc, F
379:                       if (bc == 1) 
072C  0B6C     DECFSZ bc, W
072D  2F32     GOTO 0x732
380:                           checksum += (c<<4);
072E  0E7D     SWAPF 0xFD, W
072F  39F0     ANDLW 0xF0
0730  0022     MOVLB 0x2
0731  07DC     ADDWF checksum, F
381:                       if (bc == 2)  {  
0732  3002     MOVLW 0x2
0733  0021     MOVLB 0x1
0734  066C     XORWF bc, W
0735  1D03     BTFSS STATUS, 0x2
0736  3401     RETLW 0x1
382:                           bc = 0;
0737  01EC     CLRF bc
383:                           checksum += c;
0738  087D     MOVF 0xFD, W
0739  0022     MOVLB 0x2
073A  07DC     ADDWF checksum, F
384:                           if (checksum != 0) { 
073B  085C     MOVF checksum, W
073C  1D03     BTFSS STATUS, 0x2
073D  2E62     GOTO 0x662
385:                               state = SOL; 
386:                               return false; 
387:                           }
388:                           // chksum is good 
389:                           state = SOL; 
073E  01DD     CLRF state
390:                           if (record_type == 0) 
073F  0021     MOVLB 0x1
0740  086A     MOVF record_type, W
0741  1D03     BTFSS STATUS, 0x2
0742  2F6A     GOTO 0x76A
391:                               packRow( ext_address + address, data, data_count);
0743  0024     MOVLB 0x4
0744  0820     MOVF __pbssBANK4, W
0745  0022     MOVLB 0x2
0746  0730     ADDWF address, W
0747  0021     MOVLB 0x1
0748  00B8     MOVWF 0xB8
0749  0024     MOVLB 0x4
074A  0821     MOVF 0x221, W
074B  0022     MOVLB 0x2
074C  3D31     ADDWFC 0x131, W
074D  0021     MOVLB 0x1
074E  00B9     MOVWF 0xB9
074F  0024     MOVLB 0x4
0750  0822     MOVF 0x222, W
0751  0022     MOVLB 0x2
0752  3D32     ADDWFC 0x132, W
0753  0021     MOVLB 0x1
0754  00BA     MOVWF 0xBA
0755  0024     MOVLB 0x4
0756  0823     MOVF 0x223, W
0757  0022     MOVLB 0x2
0758  3D33     ADDWFC 0x133, W
0759  0021     MOVLB 0x1
075A  00BB     MOVWF 0xBB
075B  083B     MOVF 0xBB, W
075C  00A8     MOVWF i
075D  083A     MOVF 0xBA, W
075E  00A7     MOVWF 0xA7
075F  0839     MOVF 0xB9, W
0760  00A6     MOVWF p
0761  0838     MOVF 0xB8, W
0762  00A5     MOVWF address
0763  3043     MOVLW 0x43
0764  00A9     MOVWF i
0765  086B     MOVF data_count, W
0766  00AA     MOVWF data_count
0767  3191     MOVLP 0x11
0768  21A3     CALL 0x1A3
0769  3401     RETLW 0x1
392:                           else if (record_type == 4) 
076A  3004     MOVLW 0x4
076B  066A     XORWF record_type, W
076C  1D03     BTFSS STATUS, 0x2
076D  2F92     GOTO 0x792
393:                               ext_address = ((uint32_t)(data[0]) << 24) + ((uint32_t)(data[1]) << 16);
076E  0024     MOVLB 0x4
076F  0844     MOVF 0x244, W
0770  0021     MOVLB 0x1
0771  00B8     MOVWF 0xB8
0772  01B9     CLRF 0xB9
0773  01BA     CLRF 0xBA
0774  01BB     CLRF 0xBB
0775  0839     MOVF 0xB9, W
0776  00BB     MOVWF 0xBB
0777  0838     MOVF 0xB8, W
0778  00BA     MOVWF 0xBA
0779  01B9     CLRF 0xB9
077A  01B8     CLRF 0xB8
077B  0024     MOVLB 0x4
077C  0843     MOVF data, W
077D  0021     MOVLB 0x1
077E  00BF     MOVWF 0xBF
077F  01BE     CLRF 0xBE
0780  01BD     CLRF 0xBD
0781  01BC     CLRF 0xBC
0782  27CA     CALL 0x7CA
0783  0024     MOVLB 0x4
0784  00A3     MOVWF 0x223
0785  0021     MOVLB 0x1
0786  083A     MOVF 0xBA, W
0787  0024     MOVLB 0x4
0788  00A2     MOVWF 0x222
0789  0021     MOVLB 0x1
078A  0839     MOVF 0xB9, W
078B  0024     MOVLB 0x4
078C  00A1     MOVWF 0x221
078D  0021     MOVLB 0x1
078E  0838     MOVF 0xB8, W
078F  0024     MOVLB 0x4
0790  00A0     MOVWF __pbssBANK4
0791  3401     RETLW 0x1
394:                           else if (record_type == 1) { 
0792  0B6A     DECFSZ 0x26A, W
0793  3400     RETLW 0x0
395:                               programLastRow();
0794  27C4     CALL 0x7C4
396:                               ext_address = 0;
0795  0024     MOVLB 0x4
0796  01A0     CLRF __pbssBANK4
0797  01A1     CLRF 0x221
0798  01A2     CLRF 0x222
0799  01A3     CLRF 0x223
397:                           }
079A  3401     RETLW 0x1
398:                           else return false;
399:                       }
400:                       break;            
401:                   default:
402:                       break;
403:               }
404:               return true;
07A6  3401     RETLW 0x1
405:           }
---  /home/phil/Projects/XPRESS-Loader/MPLAB.X/app_device_msd.c  ----------------------------------------
1:             /*******************************************************************************
2:             Copyright 2016 Microchip Technology Inc. (www.microchip.com)
3:             
4:              MSD Device Implementation
5:               
6:             Licensed under the Apache License, Version 2.0 (the "License");
7:             you may not use this file except in compliance with the License.
8:             You may obtain a copy of the License at
9:             
10:                http://www.apache.org/licenses/LICENSE-2.0
11:            
12:            Unless required by applicable law or agreed to in writing, software
13:            distributed under the License is distributed on an "AS IS" BASIS,
14:            WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
15:            See the License for the specific language governing permissions and
16:            limitations under the License.
17:            
18:            *******************************************************************************/
19:            
20:            #include "system.h"
21:            #include "system_config.h"
22:            
23:            #include "usb.h"
24:            #include "usb_device_msd.h"
25:            
26:            #include "direct.h"
27:            
28:            
29:            //The LUN variable definition is critical to the MSD function driver.  This
30:            //  array is a structure of function pointers that are the functions that
31:            //  will take care of each of the physical media.  For each additional LUN
32:            //  that is added to the system, an entry into this array needs to be added
33:            //  so that the stack can know where to find the physical layer functions.
34:            //  In this example the media initialization function is named
35:            //  "MediaInitialize", the read capacity function is named "ReadCapacity",
36:            //  etc.
37:            LUN_FUNCTIONS LUN[MAX_LUN + 1] =
38:            {
39:                {
40:                    (FILEIO_MEDIA_INFORMATION* (*)(void *))&DIRECT_MediaInitialize,
41:                    (uint32_t (*)(void *))&DIRECT_CapacityRead,
42:                    (uint16_t (*)(void *))&DIRECT_SectorSizeRead,
43:                    (bool  (*)(void *))&DIRECT_MediaDetect,
44:                    (uint8_t  (*)(void *, uint32_t, uint8_t*, uint8_t))&DIRECT_SectorRead,
45:                    (uint8_t  (*)(void *))&DIRECT_WriteProtectStateGet,
46:                    (uint8_t  (*)(void *, uint32_t, uint8_t*, uint8_t))&DIRECT_SectorWrite,
47:                    (void *)NULL
48:                }
49:            };
50:            
51:            /* Standard Response to INQUIRY command stored in ROM 	*/
52:            const InquiryResponse inq_resp = {
53:            	0x00,		// peripheral device is connected, direct access block device
54:            	0x80,           // removable
55:            	0x04,	 	// version = 00=> does not conform to any standard, 4=> SPC-2
56:            	0x02,		// response is in format specified by SPC-2
57:            	0x20,		// n-4 = 36-4=32= 0x20
58:            	0x00,		// sccs etc.
59:            	0x00,		// bque=1 and cmdque=0,indicates simple queueing 00 is obsolete,
60:            			// but as in case of other device, we are just using 00
61:            	0x00,		// 00 obsolete, 0x80 for basic task queueing
62:            	'M','i','c','r','o','c','h','p',    // this is the T10 assigned Vendor ID
63:            	'M','a','s','s',' ','S','t','o','r','a','g','e',' ',' ',' ',' ',
64:            	'0','0','0','1'
65:            };
66:            
67:            
68:            /*********************************************************************
69:            * Function: void APP_DeviceMSDInitialize(void);
70:            *
71:            * Overview: Initializes the Custom HID demo code
72:            *
73:            * PreCondition: None
74:            *
75:            * Input: None
76:            *
77:            * Output: None
78:            *
79:            ********************************************************************/
80:            void APP_DeviceMSDInitialize()
81:            {
82:                #if (MSD_DATA_IN_EP == MSD_DATA_OUT_EP)
83:                    USBEnableEndpoint(MSD_DATA_IN_EP,USB_IN_ENABLED|USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
0575  301E     MOVLW 0x1E
0576  00F4     MOVWF 0x274
0577  3001     MOVLW 0x1
0578  257B     CALL 0x57B
84:                #else
85:                    USBEnableEndpoint(MSD_DATA_IN_EP,USB_IN_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
86:                    USBEnableEndpoint(MSD_DATA_OUT_EP,USB_OUT_ENABLED|USB_HANDSHAKE_ENABLED|USB_DISALLOW_SETUP);
87:                #endif
88:            
89:                USBMSDInit();
0579  3188     MOVLP 0x8
057A  2871     GOTO 0x71
90:            }
91:            
92:            /*********************************************************************
93:            * Function: void APP_DeviceMSDTasks(void);
94:            *
95:            * Overview: Keeps the Custom HID demo running.
96:            *
97:            * PreCondition: The demo should have been initialized and started via
98:            *   the APP_DeviceMSDInitialize() and APP_DeviceMSDStart() demos
99:            *   respectively.
100:           *
101:           * Input: None
102:           *
103:           * Output: None
104:           *
105:           ********************************************************************/
106:           void APP_DeviceMSDTasks()
107:           {
108:               MSDTasks();
0157  2ACC     GOTO 0x2CC
109:           }
